
CarControl.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000017c  00800100  00002b66  00002bfa  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002b66  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000004e  0080027c  0080027c  00002d76  2**0
                  ALLOC
  3 .stab         00004644  00000000  00000000  00002d78  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000033fe  00000000  00000000  000073bc  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 46 00 	jmp	0x8c	; 0x8c <__ctors_end>
       4:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
       8:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
       c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      10:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      14:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      18:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      1c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      20:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      24:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      28:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      2c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      30:	0c 94 cf 0b 	jmp	0x179e	; 0x179e <__vector_12>
      34:	0c 94 96 0b 	jmp	0x172c	; 0x172c <__vector_13>
      38:	0c 94 5d 0b 	jmp	0x16ba	; 0x16ba <__vector_14>
      3c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      40:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      44:	0c 94 07 0d 	jmp	0x1a0e	; 0x1a0e <__vector_17>
      48:	0c 94 5d 06 	jmp	0xcba	; 0xcba <__vector_18>
      4c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      50:	0c 94 96 06 	jmp	0xd2c	; 0xd2c <__vector_20>
      54:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      58:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      5c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      60:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      64:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      68:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      6c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      70:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      74:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      78:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      7c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      80:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      84:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      88:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>

0000008c <__ctors_end>:
      8c:	11 24       	eor	r1, r1
      8e:	1f be       	out	0x3f, r1	; 63
      90:	cf ef       	ldi	r28, 0xFF	; 255
      92:	d0 e1       	ldi	r29, 0x10	; 16
      94:	de bf       	out	0x3e, r29	; 62
      96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_copy_data>:
      98:	12 e0       	ldi	r17, 0x02	; 2
      9a:	a0 e0       	ldi	r26, 0x00	; 0
      9c:	b1 e0       	ldi	r27, 0x01	; 1
      9e:	e6 e6       	ldi	r30, 0x66	; 102
      a0:	fb e2       	ldi	r31, 0x2B	; 43
      a2:	00 e0       	ldi	r16, 0x00	; 0
      a4:	0b bf       	out	0x3b, r16	; 59
      a6:	02 c0       	rjmp	.+4      	; 0xac <__do_copy_data+0x14>
      a8:	07 90       	elpm	r0, Z+
      aa:	0d 92       	st	X+, r0
      ac:	ac 37       	cpi	r26, 0x7C	; 124
      ae:	b1 07       	cpc	r27, r17
      b0:	d9 f7       	brne	.-10     	; 0xa8 <__do_copy_data+0x10>

000000b2 <__do_clear_bss>:
      b2:	12 e0       	ldi	r17, 0x02	; 2
      b4:	ac e7       	ldi	r26, 0x7C	; 124
      b6:	b2 e0       	ldi	r27, 0x02	; 2
      b8:	01 c0       	rjmp	.+2      	; 0xbc <.do_clear_bss_start>

000000ba <.do_clear_bss_loop>:
      ba:	1d 92       	st	X+, r1

000000bc <.do_clear_bss_start>:
      bc:	aa 3c       	cpi	r26, 0xCA	; 202
      be:	b1 07       	cpc	r27, r17
      c0:	e1 f7       	brne	.-8      	; 0xba <.do_clear_bss_loop>
      c2:	0e 94 92 15 	call	0x2b24	; 0x2b24 <main>
      c6:	0c 94 b1 15 	jmp	0x2b62	; 0x2b62 <_exit>

000000ca <__bad_interrupt>:
      ca:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ce <Port_Init>:
#include "MemMap128.h"
#include "../../Services/PORT/Port.h"
#include "../../Services/PORT/Port_Cfg.h"
extern Pin_CfgType PinCfgs[];					   
void Port_Init (void)
{
      ce:	df 93       	push	r29
      d0:	cf 93       	push	r28
      d2:	00 d0       	rcall	.+0      	; 0xd4 <Port_Init+0x6>
      d4:	0f 92       	push	r0
      d6:	cd b7       	in	r28, 0x3d	; 61
      d8:	de b7       	in	r29, 0x3e	; 62
	u8 i=0;
      da:	19 82       	std	Y+1, r1	; 0x01
	for (i=0;i<64;i++)
      dc:	19 82       	std	Y+1, r1	; 0x01
      de:	77 c3       	rjmp	.+1774   	; 0x7ce <Port_Init+0x700>
	{
		switch (PinCfgs[i].Port)
      e0:	89 81       	ldd	r24, Y+1	; 0x01
      e2:	28 2f       	mov	r18, r24
      e4:	30 e0       	ldi	r19, 0x00	; 0
      e6:	c9 01       	movw	r24, r18
      e8:	88 0f       	add	r24, r24
      ea:	99 1f       	adc	r25, r25
      ec:	82 0f       	add	r24, r18
      ee:	93 1f       	adc	r25, r19
      f0:	fc 01       	movw	r30, r24
      f2:	ec 5f       	subi	r30, 0xFC	; 252
      f4:	fd 4f       	sbci	r31, 0xFD	; 253
      f6:	80 81       	ld	r24, Z
      f8:	28 2f       	mov	r18, r24
      fa:	30 e0       	ldi	r19, 0x00	; 0
      fc:	3b 83       	std	Y+3, r19	; 0x03
      fe:	2a 83       	std	Y+2, r18	; 0x02
     100:	8a 81       	ldd	r24, Y+2	; 0x02
     102:	9b 81       	ldd	r25, Y+3	; 0x03
     104:	82 30       	cpi	r24, 0x02	; 2
     106:	91 05       	cpc	r25, r1
     108:	09 f4       	brne	.+2      	; 0x10c <Port_Init+0x3e>
     10a:	6b c1       	rjmp	.+726    	; 0x3e2 <Port_Init+0x314>
     10c:	2a 81       	ldd	r18, Y+2	; 0x02
     10e:	3b 81       	ldd	r19, Y+3	; 0x03
     110:	23 30       	cpi	r18, 0x03	; 3
     112:	31 05       	cpc	r19, r1
     114:	5c f4       	brge	.+22     	; 0x12c <Port_Init+0x5e>
     116:	8a 81       	ldd	r24, Y+2	; 0x02
     118:	9b 81       	ldd	r25, Y+3	; 0x03
     11a:	00 97       	sbiw	r24, 0x00	; 0
     11c:	a1 f0       	breq	.+40     	; 0x146 <Port_Init+0x78>
     11e:	2a 81       	ldd	r18, Y+2	; 0x02
     120:	3b 81       	ldd	r19, Y+3	; 0x03
     122:	21 30       	cpi	r18, 0x01	; 1
     124:	31 05       	cpc	r19, r1
     126:	09 f4       	brne	.+2      	; 0x12a <Port_Init+0x5c>
     128:	b5 c0       	rjmp	.+362    	; 0x294 <Port_Init+0x1c6>
     12a:	4e c3       	rjmp	.+1692   	; 0x7c8 <Port_Init+0x6fa>
     12c:	8a 81       	ldd	r24, Y+2	; 0x02
     12e:	9b 81       	ldd	r25, Y+3	; 0x03
     130:	83 30       	cpi	r24, 0x03	; 3
     132:	91 05       	cpc	r25, r1
     134:	09 f4       	brne	.+2      	; 0x138 <Port_Init+0x6a>
     136:	fc c1       	rjmp	.+1016   	; 0x530 <Port_Init+0x462>
     138:	2a 81       	ldd	r18, Y+2	; 0x02
     13a:	3b 81       	ldd	r19, Y+3	; 0x03
     13c:	24 30       	cpi	r18, 0x04	; 4
     13e:	31 05       	cpc	r19, r1
     140:	09 f4       	brne	.+2      	; 0x144 <Port_Init+0x76>
     142:	9d c2       	rjmp	.+1338   	; 0x67e <Port_Init+0x5b0>
     144:	41 c3       	rjmp	.+1666   	; 0x7c8 <Port_Init+0x6fa>
		{
			case Dio_PORTA:
			if (PinCfgs[i].Dir==Dio_OUTPUT)
     146:	89 81       	ldd	r24, Y+1	; 0x01
     148:	28 2f       	mov	r18, r24
     14a:	30 e0       	ldi	r19, 0x00	; 0
     14c:	c9 01       	movw	r24, r18
     14e:	88 0f       	add	r24, r24
     150:	99 1f       	adc	r25, r25
     152:	82 0f       	add	r24, r18
     154:	93 1f       	adc	r25, r19
     156:	fc 01       	movw	r30, r24
     158:	ea 5f       	subi	r30, 0xFA	; 250
     15a:	fd 4f       	sbci	r31, 0xFD	; 253
     15c:	80 81       	ld	r24, Z
     15e:	88 23       	and	r24, r24
     160:	f9 f4       	brne	.+62     	; 0x1a0 <Port_Init+0xd2>
			{
				SET_BIT(DDRA,PinCfgs[i].Pin);		
     162:	aa e3       	ldi	r26, 0x3A	; 58
     164:	b0 e0       	ldi	r27, 0x00	; 0
     166:	ea e3       	ldi	r30, 0x3A	; 58
     168:	f0 e0       	ldi	r31, 0x00	; 0
     16a:	80 81       	ld	r24, Z
     16c:	48 2f       	mov	r20, r24
     16e:	89 81       	ldd	r24, Y+1	; 0x01
     170:	28 2f       	mov	r18, r24
     172:	30 e0       	ldi	r19, 0x00	; 0
     174:	c9 01       	movw	r24, r18
     176:	88 0f       	add	r24, r24
     178:	99 1f       	adc	r25, r25
     17a:	82 0f       	add	r24, r18
     17c:	93 1f       	adc	r25, r19
     17e:	fc 01       	movw	r30, r24
     180:	eb 5f       	subi	r30, 0xFB	; 251
     182:	fd 4f       	sbci	r31, 0xFD	; 253
     184:	80 81       	ld	r24, Z
     186:	28 2f       	mov	r18, r24
     188:	30 e0       	ldi	r19, 0x00	; 0
     18a:	81 e0       	ldi	r24, 0x01	; 1
     18c:	90 e0       	ldi	r25, 0x00	; 0
     18e:	02 2e       	mov	r0, r18
     190:	02 c0       	rjmp	.+4      	; 0x196 <Port_Init+0xc8>
     192:	88 0f       	add	r24, r24
     194:	99 1f       	adc	r25, r25
     196:	0a 94       	dec	r0
     198:	e2 f7       	brpl	.-8      	; 0x192 <Port_Init+0xc4>
     19a:	84 2b       	or	r24, r20
     19c:	8c 93       	st	X, r24
     19e:	14 c3       	rjmp	.+1576   	; 0x7c8 <Port_Init+0x6fa>
			}
			else if (PinCfgs[i].Dir==Dio_INPUT)
     1a0:	89 81       	ldd	r24, Y+1	; 0x01
     1a2:	28 2f       	mov	r18, r24
     1a4:	30 e0       	ldi	r19, 0x00	; 0
     1a6:	c9 01       	movw	r24, r18
     1a8:	88 0f       	add	r24, r24
     1aa:	99 1f       	adc	r25, r25
     1ac:	82 0f       	add	r24, r18
     1ae:	93 1f       	adc	r25, r19
     1b0:	fc 01       	movw	r30, r24
     1b2:	ea 5f       	subi	r30, 0xFA	; 250
     1b4:	fd 4f       	sbci	r31, 0xFD	; 253
     1b6:	80 81       	ld	r24, Z
     1b8:	81 30       	cpi	r24, 0x01	; 1
     1ba:	01 f5       	brne	.+64     	; 0x1fc <Port_Init+0x12e>
			{
				CLR_BIT(DDRA,PinCfgs[i].Pin);
     1bc:	aa e3       	ldi	r26, 0x3A	; 58
     1be:	b0 e0       	ldi	r27, 0x00	; 0
     1c0:	ea e3       	ldi	r30, 0x3A	; 58
     1c2:	f0 e0       	ldi	r31, 0x00	; 0
     1c4:	80 81       	ld	r24, Z
     1c6:	48 2f       	mov	r20, r24
     1c8:	89 81       	ldd	r24, Y+1	; 0x01
     1ca:	28 2f       	mov	r18, r24
     1cc:	30 e0       	ldi	r19, 0x00	; 0
     1ce:	c9 01       	movw	r24, r18
     1d0:	88 0f       	add	r24, r24
     1d2:	99 1f       	adc	r25, r25
     1d4:	82 0f       	add	r24, r18
     1d6:	93 1f       	adc	r25, r19
     1d8:	fc 01       	movw	r30, r24
     1da:	eb 5f       	subi	r30, 0xFB	; 251
     1dc:	fd 4f       	sbci	r31, 0xFD	; 253
     1de:	80 81       	ld	r24, Z
     1e0:	28 2f       	mov	r18, r24
     1e2:	30 e0       	ldi	r19, 0x00	; 0
     1e4:	81 e0       	ldi	r24, 0x01	; 1
     1e6:	90 e0       	ldi	r25, 0x00	; 0
     1e8:	02 2e       	mov	r0, r18
     1ea:	02 c0       	rjmp	.+4      	; 0x1f0 <Port_Init+0x122>
     1ec:	88 0f       	add	r24, r24
     1ee:	99 1f       	adc	r25, r25
     1f0:	0a 94       	dec	r0
     1f2:	e2 f7       	brpl	.-8      	; 0x1ec <Port_Init+0x11e>
     1f4:	80 95       	com	r24
     1f6:	84 23       	and	r24, r20
     1f8:	8c 93       	st	X, r24
     1fa:	e6 c2       	rjmp	.+1484   	; 0x7c8 <Port_Init+0x6fa>
			}
			else if (PinCfgs[i].Dir==Dio_INPULL)
     1fc:	89 81       	ldd	r24, Y+1	; 0x01
     1fe:	28 2f       	mov	r18, r24
     200:	30 e0       	ldi	r19, 0x00	; 0
     202:	c9 01       	movw	r24, r18
     204:	88 0f       	add	r24, r24
     206:	99 1f       	adc	r25, r25
     208:	82 0f       	add	r24, r18
     20a:	93 1f       	adc	r25, r19
     20c:	fc 01       	movw	r30, r24
     20e:	ea 5f       	subi	r30, 0xFA	; 250
     210:	fd 4f       	sbci	r31, 0xFD	; 253
     212:	80 81       	ld	r24, Z
     214:	82 30       	cpi	r24, 0x02	; 2
     216:	09 f0       	breq	.+2      	; 0x21a <Port_Init+0x14c>
     218:	d7 c2       	rjmp	.+1454   	; 0x7c8 <Port_Init+0x6fa>
			{
				CLR_BIT(DDRA,PinCfgs[i].Pin);
     21a:	aa e3       	ldi	r26, 0x3A	; 58
     21c:	b0 e0       	ldi	r27, 0x00	; 0
     21e:	ea e3       	ldi	r30, 0x3A	; 58
     220:	f0 e0       	ldi	r31, 0x00	; 0
     222:	80 81       	ld	r24, Z
     224:	48 2f       	mov	r20, r24
     226:	89 81       	ldd	r24, Y+1	; 0x01
     228:	28 2f       	mov	r18, r24
     22a:	30 e0       	ldi	r19, 0x00	; 0
     22c:	c9 01       	movw	r24, r18
     22e:	88 0f       	add	r24, r24
     230:	99 1f       	adc	r25, r25
     232:	82 0f       	add	r24, r18
     234:	93 1f       	adc	r25, r19
     236:	fc 01       	movw	r30, r24
     238:	eb 5f       	subi	r30, 0xFB	; 251
     23a:	fd 4f       	sbci	r31, 0xFD	; 253
     23c:	80 81       	ld	r24, Z
     23e:	28 2f       	mov	r18, r24
     240:	30 e0       	ldi	r19, 0x00	; 0
     242:	81 e0       	ldi	r24, 0x01	; 1
     244:	90 e0       	ldi	r25, 0x00	; 0
     246:	02 c0       	rjmp	.+4      	; 0x24c <Port_Init+0x17e>
     248:	88 0f       	add	r24, r24
     24a:	99 1f       	adc	r25, r25
     24c:	2a 95       	dec	r18
     24e:	e2 f7       	brpl	.-8      	; 0x248 <Port_Init+0x17a>
     250:	80 95       	com	r24
     252:	84 23       	and	r24, r20
     254:	8c 93       	st	X, r24
				SET_BIT(PORTA,PinCfgs[i].Pin);
     256:	ab e3       	ldi	r26, 0x3B	; 59
     258:	b0 e0       	ldi	r27, 0x00	; 0
     25a:	eb e3       	ldi	r30, 0x3B	; 59
     25c:	f0 e0       	ldi	r31, 0x00	; 0
     25e:	80 81       	ld	r24, Z
     260:	48 2f       	mov	r20, r24
     262:	89 81       	ldd	r24, Y+1	; 0x01
     264:	28 2f       	mov	r18, r24
     266:	30 e0       	ldi	r19, 0x00	; 0
     268:	c9 01       	movw	r24, r18
     26a:	88 0f       	add	r24, r24
     26c:	99 1f       	adc	r25, r25
     26e:	82 0f       	add	r24, r18
     270:	93 1f       	adc	r25, r19
     272:	fc 01       	movw	r30, r24
     274:	eb 5f       	subi	r30, 0xFB	; 251
     276:	fd 4f       	sbci	r31, 0xFD	; 253
     278:	80 81       	ld	r24, Z
     27a:	28 2f       	mov	r18, r24
     27c:	30 e0       	ldi	r19, 0x00	; 0
     27e:	81 e0       	ldi	r24, 0x01	; 1
     280:	90 e0       	ldi	r25, 0x00	; 0
     282:	02 2e       	mov	r0, r18
     284:	02 c0       	rjmp	.+4      	; 0x28a <Port_Init+0x1bc>
     286:	88 0f       	add	r24, r24
     288:	99 1f       	adc	r25, r25
     28a:	0a 94       	dec	r0
     28c:	e2 f7       	brpl	.-8      	; 0x286 <Port_Init+0x1b8>
     28e:	84 2b       	or	r24, r20
     290:	8c 93       	st	X, r24
     292:	9a c2       	rjmp	.+1332   	; 0x7c8 <Port_Init+0x6fa>
			}
			break;
			case Dio_PORTB:
			if (PinCfgs[i].Dir==Dio_OUTPUT)
     294:	89 81       	ldd	r24, Y+1	; 0x01
     296:	28 2f       	mov	r18, r24
     298:	30 e0       	ldi	r19, 0x00	; 0
     29a:	c9 01       	movw	r24, r18
     29c:	88 0f       	add	r24, r24
     29e:	99 1f       	adc	r25, r25
     2a0:	82 0f       	add	r24, r18
     2a2:	93 1f       	adc	r25, r19
     2a4:	fc 01       	movw	r30, r24
     2a6:	ea 5f       	subi	r30, 0xFA	; 250
     2a8:	fd 4f       	sbci	r31, 0xFD	; 253
     2aa:	80 81       	ld	r24, Z
     2ac:	88 23       	and	r24, r24
     2ae:	f9 f4       	brne	.+62     	; 0x2ee <Port_Init+0x220>
			{
				SET_BIT(DDRB,PinCfgs[i].Pin);
     2b0:	a7 e3       	ldi	r26, 0x37	; 55
     2b2:	b0 e0       	ldi	r27, 0x00	; 0
     2b4:	e7 e3       	ldi	r30, 0x37	; 55
     2b6:	f0 e0       	ldi	r31, 0x00	; 0
     2b8:	80 81       	ld	r24, Z
     2ba:	48 2f       	mov	r20, r24
     2bc:	89 81       	ldd	r24, Y+1	; 0x01
     2be:	28 2f       	mov	r18, r24
     2c0:	30 e0       	ldi	r19, 0x00	; 0
     2c2:	c9 01       	movw	r24, r18
     2c4:	88 0f       	add	r24, r24
     2c6:	99 1f       	adc	r25, r25
     2c8:	82 0f       	add	r24, r18
     2ca:	93 1f       	adc	r25, r19
     2cc:	fc 01       	movw	r30, r24
     2ce:	eb 5f       	subi	r30, 0xFB	; 251
     2d0:	fd 4f       	sbci	r31, 0xFD	; 253
     2d2:	80 81       	ld	r24, Z
     2d4:	28 2f       	mov	r18, r24
     2d6:	30 e0       	ldi	r19, 0x00	; 0
     2d8:	81 e0       	ldi	r24, 0x01	; 1
     2da:	90 e0       	ldi	r25, 0x00	; 0
     2dc:	02 2e       	mov	r0, r18
     2de:	02 c0       	rjmp	.+4      	; 0x2e4 <Port_Init+0x216>
     2e0:	88 0f       	add	r24, r24
     2e2:	99 1f       	adc	r25, r25
     2e4:	0a 94       	dec	r0
     2e6:	e2 f7       	brpl	.-8      	; 0x2e0 <Port_Init+0x212>
     2e8:	84 2b       	or	r24, r20
     2ea:	8c 93       	st	X, r24
     2ec:	6d c2       	rjmp	.+1242   	; 0x7c8 <Port_Init+0x6fa>
			}
			else if (PinCfgs[i].Dir==Dio_INPUT)
     2ee:	89 81       	ldd	r24, Y+1	; 0x01
     2f0:	28 2f       	mov	r18, r24
     2f2:	30 e0       	ldi	r19, 0x00	; 0
     2f4:	c9 01       	movw	r24, r18
     2f6:	88 0f       	add	r24, r24
     2f8:	99 1f       	adc	r25, r25
     2fa:	82 0f       	add	r24, r18
     2fc:	93 1f       	adc	r25, r19
     2fe:	fc 01       	movw	r30, r24
     300:	ea 5f       	subi	r30, 0xFA	; 250
     302:	fd 4f       	sbci	r31, 0xFD	; 253
     304:	80 81       	ld	r24, Z
     306:	81 30       	cpi	r24, 0x01	; 1
     308:	01 f5       	brne	.+64     	; 0x34a <Port_Init+0x27c>
			{
				CLR_BIT(DDRB,PinCfgs[i].Pin);
     30a:	a7 e3       	ldi	r26, 0x37	; 55
     30c:	b0 e0       	ldi	r27, 0x00	; 0
     30e:	e7 e3       	ldi	r30, 0x37	; 55
     310:	f0 e0       	ldi	r31, 0x00	; 0
     312:	80 81       	ld	r24, Z
     314:	48 2f       	mov	r20, r24
     316:	89 81       	ldd	r24, Y+1	; 0x01
     318:	28 2f       	mov	r18, r24
     31a:	30 e0       	ldi	r19, 0x00	; 0
     31c:	c9 01       	movw	r24, r18
     31e:	88 0f       	add	r24, r24
     320:	99 1f       	adc	r25, r25
     322:	82 0f       	add	r24, r18
     324:	93 1f       	adc	r25, r19
     326:	fc 01       	movw	r30, r24
     328:	eb 5f       	subi	r30, 0xFB	; 251
     32a:	fd 4f       	sbci	r31, 0xFD	; 253
     32c:	80 81       	ld	r24, Z
     32e:	28 2f       	mov	r18, r24
     330:	30 e0       	ldi	r19, 0x00	; 0
     332:	81 e0       	ldi	r24, 0x01	; 1
     334:	90 e0       	ldi	r25, 0x00	; 0
     336:	02 2e       	mov	r0, r18
     338:	02 c0       	rjmp	.+4      	; 0x33e <Port_Init+0x270>
     33a:	88 0f       	add	r24, r24
     33c:	99 1f       	adc	r25, r25
     33e:	0a 94       	dec	r0
     340:	e2 f7       	brpl	.-8      	; 0x33a <Port_Init+0x26c>
     342:	80 95       	com	r24
     344:	84 23       	and	r24, r20
     346:	8c 93       	st	X, r24
     348:	3f c2       	rjmp	.+1150   	; 0x7c8 <Port_Init+0x6fa>
			}
			else if (PinCfgs[i].Dir==Dio_INPULL)
     34a:	89 81       	ldd	r24, Y+1	; 0x01
     34c:	28 2f       	mov	r18, r24
     34e:	30 e0       	ldi	r19, 0x00	; 0
     350:	c9 01       	movw	r24, r18
     352:	88 0f       	add	r24, r24
     354:	99 1f       	adc	r25, r25
     356:	82 0f       	add	r24, r18
     358:	93 1f       	adc	r25, r19
     35a:	fc 01       	movw	r30, r24
     35c:	ea 5f       	subi	r30, 0xFA	; 250
     35e:	fd 4f       	sbci	r31, 0xFD	; 253
     360:	80 81       	ld	r24, Z
     362:	82 30       	cpi	r24, 0x02	; 2
     364:	09 f0       	breq	.+2      	; 0x368 <Port_Init+0x29a>
     366:	30 c2       	rjmp	.+1120   	; 0x7c8 <Port_Init+0x6fa>
			{
				CLR_BIT(DDRB,PinCfgs[i].Pin);
     368:	a7 e3       	ldi	r26, 0x37	; 55
     36a:	b0 e0       	ldi	r27, 0x00	; 0
     36c:	e7 e3       	ldi	r30, 0x37	; 55
     36e:	f0 e0       	ldi	r31, 0x00	; 0
     370:	80 81       	ld	r24, Z
     372:	48 2f       	mov	r20, r24
     374:	89 81       	ldd	r24, Y+1	; 0x01
     376:	28 2f       	mov	r18, r24
     378:	30 e0       	ldi	r19, 0x00	; 0
     37a:	c9 01       	movw	r24, r18
     37c:	88 0f       	add	r24, r24
     37e:	99 1f       	adc	r25, r25
     380:	82 0f       	add	r24, r18
     382:	93 1f       	adc	r25, r19
     384:	fc 01       	movw	r30, r24
     386:	eb 5f       	subi	r30, 0xFB	; 251
     388:	fd 4f       	sbci	r31, 0xFD	; 253
     38a:	80 81       	ld	r24, Z
     38c:	28 2f       	mov	r18, r24
     38e:	30 e0       	ldi	r19, 0x00	; 0
     390:	81 e0       	ldi	r24, 0x01	; 1
     392:	90 e0       	ldi	r25, 0x00	; 0
     394:	02 c0       	rjmp	.+4      	; 0x39a <Port_Init+0x2cc>
     396:	88 0f       	add	r24, r24
     398:	99 1f       	adc	r25, r25
     39a:	2a 95       	dec	r18
     39c:	e2 f7       	brpl	.-8      	; 0x396 <Port_Init+0x2c8>
     39e:	80 95       	com	r24
     3a0:	84 23       	and	r24, r20
     3a2:	8c 93       	st	X, r24
				SET_BIT(PORTB,PinCfgs[i].Pin);
     3a4:	a8 e3       	ldi	r26, 0x38	; 56
     3a6:	b0 e0       	ldi	r27, 0x00	; 0
     3a8:	e8 e3       	ldi	r30, 0x38	; 56
     3aa:	f0 e0       	ldi	r31, 0x00	; 0
     3ac:	80 81       	ld	r24, Z
     3ae:	48 2f       	mov	r20, r24
     3b0:	89 81       	ldd	r24, Y+1	; 0x01
     3b2:	28 2f       	mov	r18, r24
     3b4:	30 e0       	ldi	r19, 0x00	; 0
     3b6:	c9 01       	movw	r24, r18
     3b8:	88 0f       	add	r24, r24
     3ba:	99 1f       	adc	r25, r25
     3bc:	82 0f       	add	r24, r18
     3be:	93 1f       	adc	r25, r19
     3c0:	fc 01       	movw	r30, r24
     3c2:	eb 5f       	subi	r30, 0xFB	; 251
     3c4:	fd 4f       	sbci	r31, 0xFD	; 253
     3c6:	80 81       	ld	r24, Z
     3c8:	28 2f       	mov	r18, r24
     3ca:	30 e0       	ldi	r19, 0x00	; 0
     3cc:	81 e0       	ldi	r24, 0x01	; 1
     3ce:	90 e0       	ldi	r25, 0x00	; 0
     3d0:	02 2e       	mov	r0, r18
     3d2:	02 c0       	rjmp	.+4      	; 0x3d8 <Port_Init+0x30a>
     3d4:	88 0f       	add	r24, r24
     3d6:	99 1f       	adc	r25, r25
     3d8:	0a 94       	dec	r0
     3da:	e2 f7       	brpl	.-8      	; 0x3d4 <Port_Init+0x306>
     3dc:	84 2b       	or	r24, r20
     3de:	8c 93       	st	X, r24
     3e0:	f3 c1       	rjmp	.+998    	; 0x7c8 <Port_Init+0x6fa>
			}
			break;
				case Dio_PORTC:
				if (PinCfgs[i].Dir==Dio_OUTPUT)
     3e2:	89 81       	ldd	r24, Y+1	; 0x01
     3e4:	28 2f       	mov	r18, r24
     3e6:	30 e0       	ldi	r19, 0x00	; 0
     3e8:	c9 01       	movw	r24, r18
     3ea:	88 0f       	add	r24, r24
     3ec:	99 1f       	adc	r25, r25
     3ee:	82 0f       	add	r24, r18
     3f0:	93 1f       	adc	r25, r19
     3f2:	fc 01       	movw	r30, r24
     3f4:	ea 5f       	subi	r30, 0xFA	; 250
     3f6:	fd 4f       	sbci	r31, 0xFD	; 253
     3f8:	80 81       	ld	r24, Z
     3fa:	88 23       	and	r24, r24
     3fc:	f9 f4       	brne	.+62     	; 0x43c <Port_Init+0x36e>
				{
					SET_BIT(DDRC,PinCfgs[i].Pin);
     3fe:	a4 e3       	ldi	r26, 0x34	; 52
     400:	b0 e0       	ldi	r27, 0x00	; 0
     402:	e4 e3       	ldi	r30, 0x34	; 52
     404:	f0 e0       	ldi	r31, 0x00	; 0
     406:	80 81       	ld	r24, Z
     408:	48 2f       	mov	r20, r24
     40a:	89 81       	ldd	r24, Y+1	; 0x01
     40c:	28 2f       	mov	r18, r24
     40e:	30 e0       	ldi	r19, 0x00	; 0
     410:	c9 01       	movw	r24, r18
     412:	88 0f       	add	r24, r24
     414:	99 1f       	adc	r25, r25
     416:	82 0f       	add	r24, r18
     418:	93 1f       	adc	r25, r19
     41a:	fc 01       	movw	r30, r24
     41c:	eb 5f       	subi	r30, 0xFB	; 251
     41e:	fd 4f       	sbci	r31, 0xFD	; 253
     420:	80 81       	ld	r24, Z
     422:	28 2f       	mov	r18, r24
     424:	30 e0       	ldi	r19, 0x00	; 0
     426:	81 e0       	ldi	r24, 0x01	; 1
     428:	90 e0       	ldi	r25, 0x00	; 0
     42a:	02 2e       	mov	r0, r18
     42c:	02 c0       	rjmp	.+4      	; 0x432 <Port_Init+0x364>
     42e:	88 0f       	add	r24, r24
     430:	99 1f       	adc	r25, r25
     432:	0a 94       	dec	r0
     434:	e2 f7       	brpl	.-8      	; 0x42e <Port_Init+0x360>
     436:	84 2b       	or	r24, r20
     438:	8c 93       	st	X, r24
     43a:	c6 c1       	rjmp	.+908    	; 0x7c8 <Port_Init+0x6fa>
				}
				else if (PinCfgs[i].Dir==Dio_INPUT)
     43c:	89 81       	ldd	r24, Y+1	; 0x01
     43e:	28 2f       	mov	r18, r24
     440:	30 e0       	ldi	r19, 0x00	; 0
     442:	c9 01       	movw	r24, r18
     444:	88 0f       	add	r24, r24
     446:	99 1f       	adc	r25, r25
     448:	82 0f       	add	r24, r18
     44a:	93 1f       	adc	r25, r19
     44c:	fc 01       	movw	r30, r24
     44e:	ea 5f       	subi	r30, 0xFA	; 250
     450:	fd 4f       	sbci	r31, 0xFD	; 253
     452:	80 81       	ld	r24, Z
     454:	81 30       	cpi	r24, 0x01	; 1
     456:	01 f5       	brne	.+64     	; 0x498 <Port_Init+0x3ca>
				{
					CLR_BIT(DDRC,PinCfgs[i].Pin);
     458:	a4 e3       	ldi	r26, 0x34	; 52
     45a:	b0 e0       	ldi	r27, 0x00	; 0
     45c:	e4 e3       	ldi	r30, 0x34	; 52
     45e:	f0 e0       	ldi	r31, 0x00	; 0
     460:	80 81       	ld	r24, Z
     462:	48 2f       	mov	r20, r24
     464:	89 81       	ldd	r24, Y+1	; 0x01
     466:	28 2f       	mov	r18, r24
     468:	30 e0       	ldi	r19, 0x00	; 0
     46a:	c9 01       	movw	r24, r18
     46c:	88 0f       	add	r24, r24
     46e:	99 1f       	adc	r25, r25
     470:	82 0f       	add	r24, r18
     472:	93 1f       	adc	r25, r19
     474:	fc 01       	movw	r30, r24
     476:	eb 5f       	subi	r30, 0xFB	; 251
     478:	fd 4f       	sbci	r31, 0xFD	; 253
     47a:	80 81       	ld	r24, Z
     47c:	28 2f       	mov	r18, r24
     47e:	30 e0       	ldi	r19, 0x00	; 0
     480:	81 e0       	ldi	r24, 0x01	; 1
     482:	90 e0       	ldi	r25, 0x00	; 0
     484:	02 2e       	mov	r0, r18
     486:	02 c0       	rjmp	.+4      	; 0x48c <Port_Init+0x3be>
     488:	88 0f       	add	r24, r24
     48a:	99 1f       	adc	r25, r25
     48c:	0a 94       	dec	r0
     48e:	e2 f7       	brpl	.-8      	; 0x488 <Port_Init+0x3ba>
     490:	80 95       	com	r24
     492:	84 23       	and	r24, r20
     494:	8c 93       	st	X, r24
     496:	98 c1       	rjmp	.+816    	; 0x7c8 <Port_Init+0x6fa>
				}
				else if (PinCfgs[i].Dir==Dio_INPULL)
     498:	89 81       	ldd	r24, Y+1	; 0x01
     49a:	28 2f       	mov	r18, r24
     49c:	30 e0       	ldi	r19, 0x00	; 0
     49e:	c9 01       	movw	r24, r18
     4a0:	88 0f       	add	r24, r24
     4a2:	99 1f       	adc	r25, r25
     4a4:	82 0f       	add	r24, r18
     4a6:	93 1f       	adc	r25, r19
     4a8:	fc 01       	movw	r30, r24
     4aa:	ea 5f       	subi	r30, 0xFA	; 250
     4ac:	fd 4f       	sbci	r31, 0xFD	; 253
     4ae:	80 81       	ld	r24, Z
     4b0:	82 30       	cpi	r24, 0x02	; 2
     4b2:	09 f0       	breq	.+2      	; 0x4b6 <Port_Init+0x3e8>
     4b4:	89 c1       	rjmp	.+786    	; 0x7c8 <Port_Init+0x6fa>
				{
					CLR_BIT(DDRC,PinCfgs[i].Pin);
     4b6:	a4 e3       	ldi	r26, 0x34	; 52
     4b8:	b0 e0       	ldi	r27, 0x00	; 0
     4ba:	e4 e3       	ldi	r30, 0x34	; 52
     4bc:	f0 e0       	ldi	r31, 0x00	; 0
     4be:	80 81       	ld	r24, Z
     4c0:	48 2f       	mov	r20, r24
     4c2:	89 81       	ldd	r24, Y+1	; 0x01
     4c4:	28 2f       	mov	r18, r24
     4c6:	30 e0       	ldi	r19, 0x00	; 0
     4c8:	c9 01       	movw	r24, r18
     4ca:	88 0f       	add	r24, r24
     4cc:	99 1f       	adc	r25, r25
     4ce:	82 0f       	add	r24, r18
     4d0:	93 1f       	adc	r25, r19
     4d2:	fc 01       	movw	r30, r24
     4d4:	eb 5f       	subi	r30, 0xFB	; 251
     4d6:	fd 4f       	sbci	r31, 0xFD	; 253
     4d8:	80 81       	ld	r24, Z
     4da:	28 2f       	mov	r18, r24
     4dc:	30 e0       	ldi	r19, 0x00	; 0
     4de:	81 e0       	ldi	r24, 0x01	; 1
     4e0:	90 e0       	ldi	r25, 0x00	; 0
     4e2:	02 c0       	rjmp	.+4      	; 0x4e8 <Port_Init+0x41a>
     4e4:	88 0f       	add	r24, r24
     4e6:	99 1f       	adc	r25, r25
     4e8:	2a 95       	dec	r18
     4ea:	e2 f7       	brpl	.-8      	; 0x4e4 <Port_Init+0x416>
     4ec:	80 95       	com	r24
     4ee:	84 23       	and	r24, r20
     4f0:	8c 93       	st	X, r24
					SET_BIT(PORTC,PinCfgs[i].Pin);
     4f2:	a5 e3       	ldi	r26, 0x35	; 53
     4f4:	b0 e0       	ldi	r27, 0x00	; 0
     4f6:	e5 e3       	ldi	r30, 0x35	; 53
     4f8:	f0 e0       	ldi	r31, 0x00	; 0
     4fa:	80 81       	ld	r24, Z
     4fc:	48 2f       	mov	r20, r24
     4fe:	89 81       	ldd	r24, Y+1	; 0x01
     500:	28 2f       	mov	r18, r24
     502:	30 e0       	ldi	r19, 0x00	; 0
     504:	c9 01       	movw	r24, r18
     506:	88 0f       	add	r24, r24
     508:	99 1f       	adc	r25, r25
     50a:	82 0f       	add	r24, r18
     50c:	93 1f       	adc	r25, r19
     50e:	fc 01       	movw	r30, r24
     510:	eb 5f       	subi	r30, 0xFB	; 251
     512:	fd 4f       	sbci	r31, 0xFD	; 253
     514:	80 81       	ld	r24, Z
     516:	28 2f       	mov	r18, r24
     518:	30 e0       	ldi	r19, 0x00	; 0
     51a:	81 e0       	ldi	r24, 0x01	; 1
     51c:	90 e0       	ldi	r25, 0x00	; 0
     51e:	02 2e       	mov	r0, r18
     520:	02 c0       	rjmp	.+4      	; 0x526 <Port_Init+0x458>
     522:	88 0f       	add	r24, r24
     524:	99 1f       	adc	r25, r25
     526:	0a 94       	dec	r0
     528:	e2 f7       	brpl	.-8      	; 0x522 <Port_Init+0x454>
     52a:	84 2b       	or	r24, r20
     52c:	8c 93       	st	X, r24
     52e:	4c c1       	rjmp	.+664    	; 0x7c8 <Port_Init+0x6fa>
				}
				break;
					case Dio_PORTD:
					if (PinCfgs[i].Dir==Dio_OUTPUT)
     530:	89 81       	ldd	r24, Y+1	; 0x01
     532:	28 2f       	mov	r18, r24
     534:	30 e0       	ldi	r19, 0x00	; 0
     536:	c9 01       	movw	r24, r18
     538:	88 0f       	add	r24, r24
     53a:	99 1f       	adc	r25, r25
     53c:	82 0f       	add	r24, r18
     53e:	93 1f       	adc	r25, r19
     540:	fc 01       	movw	r30, r24
     542:	ea 5f       	subi	r30, 0xFA	; 250
     544:	fd 4f       	sbci	r31, 0xFD	; 253
     546:	80 81       	ld	r24, Z
     548:	88 23       	and	r24, r24
     54a:	f9 f4       	brne	.+62     	; 0x58a <Port_Init+0x4bc>
					{
						SET_BIT(DDRD,PinCfgs[i].Pin);
     54c:	a1 e3       	ldi	r26, 0x31	; 49
     54e:	b0 e0       	ldi	r27, 0x00	; 0
     550:	e1 e3       	ldi	r30, 0x31	; 49
     552:	f0 e0       	ldi	r31, 0x00	; 0
     554:	80 81       	ld	r24, Z
     556:	48 2f       	mov	r20, r24
     558:	89 81       	ldd	r24, Y+1	; 0x01
     55a:	28 2f       	mov	r18, r24
     55c:	30 e0       	ldi	r19, 0x00	; 0
     55e:	c9 01       	movw	r24, r18
     560:	88 0f       	add	r24, r24
     562:	99 1f       	adc	r25, r25
     564:	82 0f       	add	r24, r18
     566:	93 1f       	adc	r25, r19
     568:	fc 01       	movw	r30, r24
     56a:	eb 5f       	subi	r30, 0xFB	; 251
     56c:	fd 4f       	sbci	r31, 0xFD	; 253
     56e:	80 81       	ld	r24, Z
     570:	28 2f       	mov	r18, r24
     572:	30 e0       	ldi	r19, 0x00	; 0
     574:	81 e0       	ldi	r24, 0x01	; 1
     576:	90 e0       	ldi	r25, 0x00	; 0
     578:	02 2e       	mov	r0, r18
     57a:	02 c0       	rjmp	.+4      	; 0x580 <Port_Init+0x4b2>
     57c:	88 0f       	add	r24, r24
     57e:	99 1f       	adc	r25, r25
     580:	0a 94       	dec	r0
     582:	e2 f7       	brpl	.-8      	; 0x57c <Port_Init+0x4ae>
     584:	84 2b       	or	r24, r20
     586:	8c 93       	st	X, r24
     588:	1f c1       	rjmp	.+574    	; 0x7c8 <Port_Init+0x6fa>
					}
					else if (PinCfgs[i].Dir==Dio_INPUT)
     58a:	89 81       	ldd	r24, Y+1	; 0x01
     58c:	28 2f       	mov	r18, r24
     58e:	30 e0       	ldi	r19, 0x00	; 0
     590:	c9 01       	movw	r24, r18
     592:	88 0f       	add	r24, r24
     594:	99 1f       	adc	r25, r25
     596:	82 0f       	add	r24, r18
     598:	93 1f       	adc	r25, r19
     59a:	fc 01       	movw	r30, r24
     59c:	ea 5f       	subi	r30, 0xFA	; 250
     59e:	fd 4f       	sbci	r31, 0xFD	; 253
     5a0:	80 81       	ld	r24, Z
     5a2:	81 30       	cpi	r24, 0x01	; 1
     5a4:	01 f5       	brne	.+64     	; 0x5e6 <Port_Init+0x518>
					{
						CLR_BIT(DDRD,PinCfgs[i].Pin);
     5a6:	a1 e3       	ldi	r26, 0x31	; 49
     5a8:	b0 e0       	ldi	r27, 0x00	; 0
     5aa:	e1 e3       	ldi	r30, 0x31	; 49
     5ac:	f0 e0       	ldi	r31, 0x00	; 0
     5ae:	80 81       	ld	r24, Z
     5b0:	48 2f       	mov	r20, r24
     5b2:	89 81       	ldd	r24, Y+1	; 0x01
     5b4:	28 2f       	mov	r18, r24
     5b6:	30 e0       	ldi	r19, 0x00	; 0
     5b8:	c9 01       	movw	r24, r18
     5ba:	88 0f       	add	r24, r24
     5bc:	99 1f       	adc	r25, r25
     5be:	82 0f       	add	r24, r18
     5c0:	93 1f       	adc	r25, r19
     5c2:	fc 01       	movw	r30, r24
     5c4:	eb 5f       	subi	r30, 0xFB	; 251
     5c6:	fd 4f       	sbci	r31, 0xFD	; 253
     5c8:	80 81       	ld	r24, Z
     5ca:	28 2f       	mov	r18, r24
     5cc:	30 e0       	ldi	r19, 0x00	; 0
     5ce:	81 e0       	ldi	r24, 0x01	; 1
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	02 2e       	mov	r0, r18
     5d4:	02 c0       	rjmp	.+4      	; 0x5da <Port_Init+0x50c>
     5d6:	88 0f       	add	r24, r24
     5d8:	99 1f       	adc	r25, r25
     5da:	0a 94       	dec	r0
     5dc:	e2 f7       	brpl	.-8      	; 0x5d6 <Port_Init+0x508>
     5de:	80 95       	com	r24
     5e0:	84 23       	and	r24, r20
     5e2:	8c 93       	st	X, r24
     5e4:	f1 c0       	rjmp	.+482    	; 0x7c8 <Port_Init+0x6fa>
					}
					else if (PinCfgs[i].Dir==Dio_INPULL)
     5e6:	89 81       	ldd	r24, Y+1	; 0x01
     5e8:	28 2f       	mov	r18, r24
     5ea:	30 e0       	ldi	r19, 0x00	; 0
     5ec:	c9 01       	movw	r24, r18
     5ee:	88 0f       	add	r24, r24
     5f0:	99 1f       	adc	r25, r25
     5f2:	82 0f       	add	r24, r18
     5f4:	93 1f       	adc	r25, r19
     5f6:	fc 01       	movw	r30, r24
     5f8:	ea 5f       	subi	r30, 0xFA	; 250
     5fa:	fd 4f       	sbci	r31, 0xFD	; 253
     5fc:	80 81       	ld	r24, Z
     5fe:	82 30       	cpi	r24, 0x02	; 2
     600:	09 f0       	breq	.+2      	; 0x604 <Port_Init+0x536>
     602:	e2 c0       	rjmp	.+452    	; 0x7c8 <Port_Init+0x6fa>
					{
						CLR_BIT(DDRD,PinCfgs[i].Pin);
     604:	a1 e3       	ldi	r26, 0x31	; 49
     606:	b0 e0       	ldi	r27, 0x00	; 0
     608:	e1 e3       	ldi	r30, 0x31	; 49
     60a:	f0 e0       	ldi	r31, 0x00	; 0
     60c:	80 81       	ld	r24, Z
     60e:	48 2f       	mov	r20, r24
     610:	89 81       	ldd	r24, Y+1	; 0x01
     612:	28 2f       	mov	r18, r24
     614:	30 e0       	ldi	r19, 0x00	; 0
     616:	c9 01       	movw	r24, r18
     618:	88 0f       	add	r24, r24
     61a:	99 1f       	adc	r25, r25
     61c:	82 0f       	add	r24, r18
     61e:	93 1f       	adc	r25, r19
     620:	fc 01       	movw	r30, r24
     622:	eb 5f       	subi	r30, 0xFB	; 251
     624:	fd 4f       	sbci	r31, 0xFD	; 253
     626:	80 81       	ld	r24, Z
     628:	28 2f       	mov	r18, r24
     62a:	30 e0       	ldi	r19, 0x00	; 0
     62c:	81 e0       	ldi	r24, 0x01	; 1
     62e:	90 e0       	ldi	r25, 0x00	; 0
     630:	02 c0       	rjmp	.+4      	; 0x636 <Port_Init+0x568>
     632:	88 0f       	add	r24, r24
     634:	99 1f       	adc	r25, r25
     636:	2a 95       	dec	r18
     638:	e2 f7       	brpl	.-8      	; 0x632 <Port_Init+0x564>
     63a:	80 95       	com	r24
     63c:	84 23       	and	r24, r20
     63e:	8c 93       	st	X, r24
						SET_BIT(PORTD,PinCfgs[i].Pin);
     640:	a2 e3       	ldi	r26, 0x32	; 50
     642:	b0 e0       	ldi	r27, 0x00	; 0
     644:	e2 e3       	ldi	r30, 0x32	; 50
     646:	f0 e0       	ldi	r31, 0x00	; 0
     648:	80 81       	ld	r24, Z
     64a:	48 2f       	mov	r20, r24
     64c:	89 81       	ldd	r24, Y+1	; 0x01
     64e:	28 2f       	mov	r18, r24
     650:	30 e0       	ldi	r19, 0x00	; 0
     652:	c9 01       	movw	r24, r18
     654:	88 0f       	add	r24, r24
     656:	99 1f       	adc	r25, r25
     658:	82 0f       	add	r24, r18
     65a:	93 1f       	adc	r25, r19
     65c:	fc 01       	movw	r30, r24
     65e:	eb 5f       	subi	r30, 0xFB	; 251
     660:	fd 4f       	sbci	r31, 0xFD	; 253
     662:	80 81       	ld	r24, Z
     664:	28 2f       	mov	r18, r24
     666:	30 e0       	ldi	r19, 0x00	; 0
     668:	81 e0       	ldi	r24, 0x01	; 1
     66a:	90 e0       	ldi	r25, 0x00	; 0
     66c:	02 2e       	mov	r0, r18
     66e:	02 c0       	rjmp	.+4      	; 0x674 <Port_Init+0x5a6>
     670:	88 0f       	add	r24, r24
     672:	99 1f       	adc	r25, r25
     674:	0a 94       	dec	r0
     676:	e2 f7       	brpl	.-8      	; 0x670 <Port_Init+0x5a2>
     678:	84 2b       	or	r24, r20
     67a:	8c 93       	st	X, r24
     67c:	a5 c0       	rjmp	.+330    	; 0x7c8 <Port_Init+0x6fa>
					}
					break;
					case Dio_PORTE:
					if (PinCfgs[i].Dir==Dio_OUTPUT)
     67e:	89 81       	ldd	r24, Y+1	; 0x01
     680:	28 2f       	mov	r18, r24
     682:	30 e0       	ldi	r19, 0x00	; 0
     684:	c9 01       	movw	r24, r18
     686:	88 0f       	add	r24, r24
     688:	99 1f       	adc	r25, r25
     68a:	82 0f       	add	r24, r18
     68c:	93 1f       	adc	r25, r19
     68e:	fc 01       	movw	r30, r24
     690:	ea 5f       	subi	r30, 0xFA	; 250
     692:	fd 4f       	sbci	r31, 0xFD	; 253
     694:	80 81       	ld	r24, Z
     696:	88 23       	and	r24, r24
     698:	f9 f4       	brne	.+62     	; 0x6d8 <Port_Init+0x60a>
					{
						SET_BIT(DDRE,PinCfgs[i].Pin);
     69a:	a2 e2       	ldi	r26, 0x22	; 34
     69c:	b0 e0       	ldi	r27, 0x00	; 0
     69e:	e2 e2       	ldi	r30, 0x22	; 34
     6a0:	f0 e0       	ldi	r31, 0x00	; 0
     6a2:	80 81       	ld	r24, Z
     6a4:	48 2f       	mov	r20, r24
     6a6:	89 81       	ldd	r24, Y+1	; 0x01
     6a8:	28 2f       	mov	r18, r24
     6aa:	30 e0       	ldi	r19, 0x00	; 0
     6ac:	c9 01       	movw	r24, r18
     6ae:	88 0f       	add	r24, r24
     6b0:	99 1f       	adc	r25, r25
     6b2:	82 0f       	add	r24, r18
     6b4:	93 1f       	adc	r25, r19
     6b6:	fc 01       	movw	r30, r24
     6b8:	eb 5f       	subi	r30, 0xFB	; 251
     6ba:	fd 4f       	sbci	r31, 0xFD	; 253
     6bc:	80 81       	ld	r24, Z
     6be:	28 2f       	mov	r18, r24
     6c0:	30 e0       	ldi	r19, 0x00	; 0
     6c2:	81 e0       	ldi	r24, 0x01	; 1
     6c4:	90 e0       	ldi	r25, 0x00	; 0
     6c6:	02 2e       	mov	r0, r18
     6c8:	02 c0       	rjmp	.+4      	; 0x6ce <Port_Init+0x600>
     6ca:	88 0f       	add	r24, r24
     6cc:	99 1f       	adc	r25, r25
     6ce:	0a 94       	dec	r0
     6d0:	e2 f7       	brpl	.-8      	; 0x6ca <Port_Init+0x5fc>
     6d2:	84 2b       	or	r24, r20
     6d4:	8c 93       	st	X, r24
     6d6:	78 c0       	rjmp	.+240    	; 0x7c8 <Port_Init+0x6fa>
					}
					else if (PinCfgs[i].Dir==Dio_INPUT)
     6d8:	89 81       	ldd	r24, Y+1	; 0x01
     6da:	28 2f       	mov	r18, r24
     6dc:	30 e0       	ldi	r19, 0x00	; 0
     6de:	c9 01       	movw	r24, r18
     6e0:	88 0f       	add	r24, r24
     6e2:	99 1f       	adc	r25, r25
     6e4:	82 0f       	add	r24, r18
     6e6:	93 1f       	adc	r25, r19
     6e8:	fc 01       	movw	r30, r24
     6ea:	ea 5f       	subi	r30, 0xFA	; 250
     6ec:	fd 4f       	sbci	r31, 0xFD	; 253
     6ee:	80 81       	ld	r24, Z
     6f0:	81 30       	cpi	r24, 0x01	; 1
     6f2:	01 f5       	brne	.+64     	; 0x734 <Port_Init+0x666>
					{
						CLR_BIT(DDRE,PinCfgs[i].Pin);
     6f4:	a2 e2       	ldi	r26, 0x22	; 34
     6f6:	b0 e0       	ldi	r27, 0x00	; 0
     6f8:	e2 e2       	ldi	r30, 0x22	; 34
     6fa:	f0 e0       	ldi	r31, 0x00	; 0
     6fc:	80 81       	ld	r24, Z
     6fe:	48 2f       	mov	r20, r24
     700:	89 81       	ldd	r24, Y+1	; 0x01
     702:	28 2f       	mov	r18, r24
     704:	30 e0       	ldi	r19, 0x00	; 0
     706:	c9 01       	movw	r24, r18
     708:	88 0f       	add	r24, r24
     70a:	99 1f       	adc	r25, r25
     70c:	82 0f       	add	r24, r18
     70e:	93 1f       	adc	r25, r19
     710:	fc 01       	movw	r30, r24
     712:	eb 5f       	subi	r30, 0xFB	; 251
     714:	fd 4f       	sbci	r31, 0xFD	; 253
     716:	80 81       	ld	r24, Z
     718:	28 2f       	mov	r18, r24
     71a:	30 e0       	ldi	r19, 0x00	; 0
     71c:	81 e0       	ldi	r24, 0x01	; 1
     71e:	90 e0       	ldi	r25, 0x00	; 0
     720:	02 2e       	mov	r0, r18
     722:	02 c0       	rjmp	.+4      	; 0x728 <Port_Init+0x65a>
     724:	88 0f       	add	r24, r24
     726:	99 1f       	adc	r25, r25
     728:	0a 94       	dec	r0
     72a:	e2 f7       	brpl	.-8      	; 0x724 <Port_Init+0x656>
     72c:	80 95       	com	r24
     72e:	84 23       	and	r24, r20
     730:	8c 93       	st	X, r24
     732:	4a c0       	rjmp	.+148    	; 0x7c8 <Port_Init+0x6fa>
					}
					else if (PinCfgs[i].Dir==Dio_INPULL)
     734:	89 81       	ldd	r24, Y+1	; 0x01
     736:	28 2f       	mov	r18, r24
     738:	30 e0       	ldi	r19, 0x00	; 0
     73a:	c9 01       	movw	r24, r18
     73c:	88 0f       	add	r24, r24
     73e:	99 1f       	adc	r25, r25
     740:	82 0f       	add	r24, r18
     742:	93 1f       	adc	r25, r19
     744:	fc 01       	movw	r30, r24
     746:	ea 5f       	subi	r30, 0xFA	; 250
     748:	fd 4f       	sbci	r31, 0xFD	; 253
     74a:	80 81       	ld	r24, Z
     74c:	82 30       	cpi	r24, 0x02	; 2
     74e:	e1 f5       	brne	.+120    	; 0x7c8 <Port_Init+0x6fa>
					{
						CLR_BIT(DDRE,PinCfgs[i].Pin);
     750:	a2 e2       	ldi	r26, 0x22	; 34
     752:	b0 e0       	ldi	r27, 0x00	; 0
     754:	e2 e2       	ldi	r30, 0x22	; 34
     756:	f0 e0       	ldi	r31, 0x00	; 0
     758:	80 81       	ld	r24, Z
     75a:	48 2f       	mov	r20, r24
     75c:	89 81       	ldd	r24, Y+1	; 0x01
     75e:	28 2f       	mov	r18, r24
     760:	30 e0       	ldi	r19, 0x00	; 0
     762:	c9 01       	movw	r24, r18
     764:	88 0f       	add	r24, r24
     766:	99 1f       	adc	r25, r25
     768:	82 0f       	add	r24, r18
     76a:	93 1f       	adc	r25, r19
     76c:	fc 01       	movw	r30, r24
     76e:	eb 5f       	subi	r30, 0xFB	; 251
     770:	fd 4f       	sbci	r31, 0xFD	; 253
     772:	80 81       	ld	r24, Z
     774:	28 2f       	mov	r18, r24
     776:	30 e0       	ldi	r19, 0x00	; 0
     778:	81 e0       	ldi	r24, 0x01	; 1
     77a:	90 e0       	ldi	r25, 0x00	; 0
     77c:	02 c0       	rjmp	.+4      	; 0x782 <Port_Init+0x6b4>
     77e:	88 0f       	add	r24, r24
     780:	99 1f       	adc	r25, r25
     782:	2a 95       	dec	r18
     784:	e2 f7       	brpl	.-8      	; 0x77e <Port_Init+0x6b0>
     786:	80 95       	com	r24
     788:	84 23       	and	r24, r20
     78a:	8c 93       	st	X, r24
						SET_BIT(PORTE,PinCfgs[i].Pin);
     78c:	a3 e2       	ldi	r26, 0x23	; 35
     78e:	b0 e0       	ldi	r27, 0x00	; 0
     790:	e3 e2       	ldi	r30, 0x23	; 35
     792:	f0 e0       	ldi	r31, 0x00	; 0
     794:	80 81       	ld	r24, Z
     796:	48 2f       	mov	r20, r24
     798:	89 81       	ldd	r24, Y+1	; 0x01
     79a:	28 2f       	mov	r18, r24
     79c:	30 e0       	ldi	r19, 0x00	; 0
     79e:	c9 01       	movw	r24, r18
     7a0:	88 0f       	add	r24, r24
     7a2:	99 1f       	adc	r25, r25
     7a4:	82 0f       	add	r24, r18
     7a6:	93 1f       	adc	r25, r19
     7a8:	fc 01       	movw	r30, r24
     7aa:	eb 5f       	subi	r30, 0xFB	; 251
     7ac:	fd 4f       	sbci	r31, 0xFD	; 253
     7ae:	80 81       	ld	r24, Z
     7b0:	28 2f       	mov	r18, r24
     7b2:	30 e0       	ldi	r19, 0x00	; 0
     7b4:	81 e0       	ldi	r24, 0x01	; 1
     7b6:	90 e0       	ldi	r25, 0x00	; 0
     7b8:	02 2e       	mov	r0, r18
     7ba:	02 c0       	rjmp	.+4      	; 0x7c0 <Port_Init+0x6f2>
     7bc:	88 0f       	add	r24, r24
     7be:	99 1f       	adc	r25, r25
     7c0:	0a 94       	dec	r0
     7c2:	e2 f7       	brpl	.-8      	; 0x7bc <Port_Init+0x6ee>
     7c4:	84 2b       	or	r24, r20
     7c6:	8c 93       	st	X, r24
#include "../../Services/PORT/Port_Cfg.h"
extern Pin_CfgType PinCfgs[];					   
void Port_Init (void)
{
	u8 i=0;
	for (i=0;i<64;i++)
     7c8:	89 81       	ldd	r24, Y+1	; 0x01
     7ca:	8f 5f       	subi	r24, 0xFF	; 255
     7cc:	89 83       	std	Y+1, r24	; 0x01
     7ce:	89 81       	ldd	r24, Y+1	; 0x01
     7d0:	80 34       	cpi	r24, 0x40	; 64
     7d2:	08 f4       	brcc	.+2      	; 0x7d6 <Port_Init+0x708>
     7d4:	85 cc       	rjmp	.-1782   	; 0xe0 <Port_Init+0x12>
						SET_BIT(PORTE,PinCfgs[i].Pin);
					}
					break;
		}
	}
}
     7d6:	0f 90       	pop	r0
     7d8:	0f 90       	pop	r0
     7da:	0f 90       	pop	r0
     7dc:	cf 91       	pop	r28
     7de:	df 91       	pop	r29
     7e0:	08 95       	ret

000007e2 <OS_TaskCreate>:
#include "../OS/OS.h"
static OS_struct taskArray [MAX_NUM_OF_TASKS];
static u8 taskCounter = 0;

OS_feedback OS_TaskCreate(fncPtr local_function, u16 periodicity, OS_state default_state,u8 local_delay)
{
     7e2:	df 93       	push	r29
     7e4:	cf 93       	push	r28
     7e6:	cd b7       	in	r28, 0x3d	; 61
     7e8:	de b7       	in	r29, 0x3e	; 62
     7ea:	27 97       	sbiw	r28, 0x07	; 7
     7ec:	0f b6       	in	r0, 0x3f	; 63
     7ee:	f8 94       	cli
     7f0:	de bf       	out	0x3e, r29	; 62
     7f2:	0f be       	out	0x3f, r0	; 63
     7f4:	cd bf       	out	0x3d, r28	; 61
     7f6:	9b 83       	std	Y+3, r25	; 0x03
     7f8:	8a 83       	std	Y+2, r24	; 0x02
     7fa:	7d 83       	std	Y+5, r23	; 0x05
     7fc:	6c 83       	std	Y+4, r22	; 0x04
     7fe:	4e 83       	std	Y+6, r20	; 0x06
     800:	2f 83       	std	Y+7, r18	; 0x07
	OS_feedback status=OK_VALID;
     802:	19 82       	std	Y+1, r1	; 0x01
   if (local_function==NULLPTR)
     804:	8a 81       	ldd	r24, Y+2	; 0x02
     806:	9b 81       	ldd	r25, Y+3	; 0x03
     808:	00 97       	sbiw	r24, 0x00	; 0
     80a:	19 f4       	brne	.+6      	; 0x812 <OS_TaskCreate+0x30>
   {
	   status=NOK_NULL_PTR;
     80c:	83 e0       	ldi	r24, 0x03	; 3
     80e:	89 83       	std	Y+1, r24	; 0x01
     810:	67 c0       	rjmp	.+206    	; 0x8e0 <OS_TaskCreate+0xfe>
   }
   else if (periodicity>HYPER_PERIOD)
     812:	8c 81       	ldd	r24, Y+4	; 0x04
     814:	9d 81       	ldd	r25, Y+5	; 0x05
     816:	89 3c       	cpi	r24, 0xC9	; 201
     818:	91 05       	cpc	r25, r1
     81a:	18 f0       	brcs	.+6      	; 0x822 <OS_TaskCreate+0x40>
   {
	  status=NOK_HYPER_PERIOD_VIOLATION;
     81c:	81 e0       	ldi	r24, 0x01	; 1
     81e:	89 83       	std	Y+1, r24	; 0x01
     820:	5f c0       	rjmp	.+190    	; 0x8e0 <OS_TaskCreate+0xfe>
   }
   else if (taskCounter>=MAX_NUM_OF_TASKS)
     822:	80 91 7c 02 	lds	r24, 0x027C
     826:	84 30       	cpi	r24, 0x04	; 4
     828:	18 f0       	brcs	.+6      	; 0x830 <OS_TaskCreate+0x4e>
   {
	   status=NOK_TASK_COUNT_VIOLATION;
     82a:	82 e0       	ldi	r24, 0x02	; 2
     82c:	89 83       	std	Y+1, r24	; 0x01
     82e:	58 c0       	rjmp	.+176    	; 0x8e0 <OS_TaskCreate+0xfe>
   }
   else
   {
	   	taskArray[taskCounter].function=local_function;
     830:	80 91 7c 02 	lds	r24, 0x027C
     834:	28 2f       	mov	r18, r24
     836:	30 e0       	ldi	r19, 0x00	; 0
     838:	c9 01       	movw	r24, r18
     83a:	88 0f       	add	r24, r24
     83c:	99 1f       	adc	r25, r25
     83e:	82 0f       	add	r24, r18
     840:	93 1f       	adc	r25, r19
     842:	88 0f       	add	r24, r24
     844:	99 1f       	adc	r25, r25
     846:	fc 01       	movw	r30, r24
     848:	e3 58       	subi	r30, 0x83	; 131
     84a:	fd 4f       	sbci	r31, 0xFD	; 253
     84c:	8a 81       	ldd	r24, Y+2	; 0x02
     84e:	9b 81       	ldd	r25, Y+3	; 0x03
     850:	91 83       	std	Z+1, r25	; 0x01
     852:	80 83       	st	Z, r24
	   	taskArray[taskCounter].task_Periodicity=periodicity;
     854:	80 91 7c 02 	lds	r24, 0x027C
     858:	28 2f       	mov	r18, r24
     85a:	30 e0       	ldi	r19, 0x00	; 0
     85c:	4c 81       	ldd	r20, Y+4	; 0x04
     85e:	c9 01       	movw	r24, r18
     860:	88 0f       	add	r24, r24
     862:	99 1f       	adc	r25, r25
     864:	82 0f       	add	r24, r18
     866:	93 1f       	adc	r25, r19
     868:	88 0f       	add	r24, r24
     86a:	99 1f       	adc	r25, r25
     86c:	fc 01       	movw	r30, r24
     86e:	e0 58       	subi	r30, 0x80	; 128
     870:	fd 4f       	sbci	r31, 0xFD	; 253
     872:	40 83       	st	Z, r20
	   	taskArray[taskCounter].task_state=default_state;
     874:	80 91 7c 02 	lds	r24, 0x027C
     878:	28 2f       	mov	r18, r24
     87a:	30 e0       	ldi	r19, 0x00	; 0
     87c:	c9 01       	movw	r24, r18
     87e:	88 0f       	add	r24, r24
     880:	99 1f       	adc	r25, r25
     882:	82 0f       	add	r24, r18
     884:	93 1f       	adc	r25, r19
     886:	01 96       	adiw	r24, 0x01	; 1
     888:	88 0f       	add	r24, r24
     88a:	99 1f       	adc	r25, r25
     88c:	fc 01       	movw	r30, r24
     88e:	e3 58       	subi	r30, 0x83	; 131
     890:	fd 4f       	sbci	r31, 0xFD	; 253
     892:	8e 81       	ldd	r24, Y+6	; 0x06
     894:	80 83       	st	Z, r24
		taskArray[taskCounter].Task_tick_counter=TICK_TIME;
     896:	80 91 7c 02 	lds	r24, 0x027C
     89a:	28 2f       	mov	r18, r24
     89c:	30 e0       	ldi	r19, 0x00	; 0
     89e:	c9 01       	movw	r24, r18
     8a0:	88 0f       	add	r24, r24
     8a2:	99 1f       	adc	r25, r25
     8a4:	82 0f       	add	r24, r18
     8a6:	93 1f       	adc	r25, r19
     8a8:	88 0f       	add	r24, r24
     8aa:	99 1f       	adc	r25, r25
     8ac:	fc 01       	movw	r30, r24
     8ae:	ef 57       	subi	r30, 0x7F	; 127
     8b0:	fd 4f       	sbci	r31, 0xFD	; 253
     8b2:	85 e0       	ldi	r24, 0x05	; 5
     8b4:	80 83       	st	Z, r24
		taskArray[taskCounter].delay=local_delay;
     8b6:	80 91 7c 02 	lds	r24, 0x027C
     8ba:	28 2f       	mov	r18, r24
     8bc:	30 e0       	ldi	r19, 0x00	; 0
     8be:	c9 01       	movw	r24, r18
     8c0:	88 0f       	add	r24, r24
     8c2:	99 1f       	adc	r25, r25
     8c4:	82 0f       	add	r24, r18
     8c6:	93 1f       	adc	r25, r19
     8c8:	88 0f       	add	r24, r24
     8ca:	99 1f       	adc	r25, r25
     8cc:	fc 01       	movw	r30, r24
     8ce:	ee 57       	subi	r30, 0x7E	; 126
     8d0:	fd 4f       	sbci	r31, 0xFD	; 253
     8d2:	8f 81       	ldd	r24, Y+7	; 0x07
     8d4:	80 83       	st	Z, r24
	   	taskCounter++;
     8d6:	80 91 7c 02 	lds	r24, 0x027C
     8da:	8f 5f       	subi	r24, 0xFF	; 255
     8dc:	80 93 7c 02 	sts	0x027C, r24
   }
	return status;
     8e0:	89 81       	ldd	r24, Y+1	; 0x01
}
     8e2:	27 96       	adiw	r28, 0x07	; 7
     8e4:	0f b6       	in	r0, 0x3f	; 63
     8e6:	f8 94       	cli
     8e8:	de bf       	out	0x3e, r29	; 62
     8ea:	0f be       	out	0x3f, r0	; 63
     8ec:	cd bf       	out	0x3d, r28	; 61
     8ee:	cf 91       	pop	r28
     8f0:	df 91       	pop	r29
     8f2:	08 95       	ret

000008f4 <OS_Task_Handler>:

/* LInked to ISR --- Time --- Task Ststes by ms*/
void OS_Task_Handler(void)
{
     8f4:	df 93       	push	r29
     8f6:	cf 93       	push	r28
     8f8:	0f 92       	push	r0
     8fa:	cd b7       	in	r28, 0x3d	; 61
     8fc:	de b7       	in	r29, 0x3e	; 62
  u8 Task_id;
  for (Task_id=0;Task_id<taskCounter;Task_id++)
     8fe:	19 82       	std	Y+1, r1	; 0x01
     900:	80 c0       	rjmp	.+256    	; 0xa02 <OS_Task_Handler+0x10e>
  {
	    if (taskArray[Task_id].task_state!=SUSPENDED)
     902:	89 81       	ldd	r24, Y+1	; 0x01
     904:	28 2f       	mov	r18, r24
     906:	30 e0       	ldi	r19, 0x00	; 0
     908:	c9 01       	movw	r24, r18
     90a:	88 0f       	add	r24, r24
     90c:	99 1f       	adc	r25, r25
     90e:	82 0f       	add	r24, r18
     910:	93 1f       	adc	r25, r19
     912:	01 96       	adiw	r24, 0x01	; 1
     914:	88 0f       	add	r24, r24
     916:	99 1f       	adc	r25, r25
     918:	fc 01       	movw	r30, r24
     91a:	e3 58       	subi	r30, 0x83	; 131
     91c:	fd 4f       	sbci	r31, 0xFD	; 253
     91e:	80 81       	ld	r24, Z
     920:	88 23       	and	r24, r24
     922:	09 f4       	brne	.+2      	; 0x926 <OS_Task_Handler+0x32>
     924:	6b c0       	rjmp	.+214    	; 0x9fc <OS_Task_Handler+0x108>
	    {
			//using in first system first delay only
		    if (taskArray[Task_id].Task_tick_counter>=taskArray[Task_id].task_Periodicity)
     926:	89 81       	ldd	r24, Y+1	; 0x01
     928:	28 2f       	mov	r18, r24
     92a:	30 e0       	ldi	r19, 0x00	; 0
     92c:	c9 01       	movw	r24, r18
     92e:	88 0f       	add	r24, r24
     930:	99 1f       	adc	r25, r25
     932:	82 0f       	add	r24, r18
     934:	93 1f       	adc	r25, r19
     936:	88 0f       	add	r24, r24
     938:	99 1f       	adc	r25, r25
     93a:	fc 01       	movw	r30, r24
     93c:	ef 57       	subi	r30, 0x7F	; 127
     93e:	fd 4f       	sbci	r31, 0xFD	; 253
     940:	40 81       	ld	r20, Z
     942:	89 81       	ldd	r24, Y+1	; 0x01
     944:	28 2f       	mov	r18, r24
     946:	30 e0       	ldi	r19, 0x00	; 0
     948:	c9 01       	movw	r24, r18
     94a:	88 0f       	add	r24, r24
     94c:	99 1f       	adc	r25, r25
     94e:	82 0f       	add	r24, r18
     950:	93 1f       	adc	r25, r19
     952:	88 0f       	add	r24, r24
     954:	99 1f       	adc	r25, r25
     956:	fc 01       	movw	r30, r24
     958:	e0 58       	subi	r30, 0x80	; 128
     95a:	fd 4f       	sbci	r31, 0xFD	; 253
     95c:	80 81       	ld	r24, Z
     95e:	48 17       	cp	r20, r24
     960:	78 f1       	brcs	.+94     	; 0x9c0 <OS_Task_Handler+0xcc>
		    {
			    taskArray[Task_id].task_state=READY;
     962:	89 81       	ldd	r24, Y+1	; 0x01
     964:	28 2f       	mov	r18, r24
     966:	30 e0       	ldi	r19, 0x00	; 0
     968:	c9 01       	movw	r24, r18
     96a:	88 0f       	add	r24, r24
     96c:	99 1f       	adc	r25, r25
     96e:	82 0f       	add	r24, r18
     970:	93 1f       	adc	r25, r19
     972:	01 96       	adiw	r24, 0x01	; 1
     974:	88 0f       	add	r24, r24
     976:	99 1f       	adc	r25, r25
     978:	fc 01       	movw	r30, r24
     97a:	e3 58       	subi	r30, 0x83	; 131
     97c:	fd 4f       	sbci	r31, 0xFD	; 253
     97e:	82 e0       	ldi	r24, 0x02	; 2
     980:	80 83       	st	Z, r24
			    taskArray[Task_id].Task_tick_counter=TICK_TIME+taskArray[Task_id].delay; //to setup time user need after first periodicity
     982:	89 81       	ldd	r24, Y+1	; 0x01
     984:	48 2f       	mov	r20, r24
     986:	50 e0       	ldi	r21, 0x00	; 0
     988:	89 81       	ldd	r24, Y+1	; 0x01
     98a:	28 2f       	mov	r18, r24
     98c:	30 e0       	ldi	r19, 0x00	; 0
     98e:	c9 01       	movw	r24, r18
     990:	88 0f       	add	r24, r24
     992:	99 1f       	adc	r25, r25
     994:	82 0f       	add	r24, r18
     996:	93 1f       	adc	r25, r19
     998:	88 0f       	add	r24, r24
     99a:	99 1f       	adc	r25, r25
     99c:	fc 01       	movw	r30, r24
     99e:	ee 57       	subi	r30, 0x7E	; 126
     9a0:	fd 4f       	sbci	r31, 0xFD	; 253
     9a2:	80 81       	ld	r24, Z
     9a4:	28 2f       	mov	r18, r24
     9a6:	2b 5f       	subi	r18, 0xFB	; 251
     9a8:	ca 01       	movw	r24, r20
     9aa:	88 0f       	add	r24, r24
     9ac:	99 1f       	adc	r25, r25
     9ae:	84 0f       	add	r24, r20
     9b0:	95 1f       	adc	r25, r21
     9b2:	88 0f       	add	r24, r24
     9b4:	99 1f       	adc	r25, r25
     9b6:	fc 01       	movw	r30, r24
     9b8:	ef 57       	subi	r30, 0x7F	; 127
     9ba:	fd 4f       	sbci	r31, 0xFD	; 253
     9bc:	20 83       	st	Z, r18
     9be:	1e c0       	rjmp	.+60     	; 0x9fc <OS_Task_Handler+0x108>
		    }
		    else
		    {
			    taskArray[Task_id].Task_tick_counter+=TICK_TIME;
     9c0:	89 81       	ldd	r24, Y+1	; 0x01
     9c2:	48 2f       	mov	r20, r24
     9c4:	50 e0       	ldi	r21, 0x00	; 0
     9c6:	89 81       	ldd	r24, Y+1	; 0x01
     9c8:	28 2f       	mov	r18, r24
     9ca:	30 e0       	ldi	r19, 0x00	; 0
     9cc:	c9 01       	movw	r24, r18
     9ce:	88 0f       	add	r24, r24
     9d0:	99 1f       	adc	r25, r25
     9d2:	82 0f       	add	r24, r18
     9d4:	93 1f       	adc	r25, r19
     9d6:	88 0f       	add	r24, r24
     9d8:	99 1f       	adc	r25, r25
     9da:	fc 01       	movw	r30, r24
     9dc:	ef 57       	subi	r30, 0x7F	; 127
     9de:	fd 4f       	sbci	r31, 0xFD	; 253
     9e0:	80 81       	ld	r24, Z
     9e2:	28 2f       	mov	r18, r24
     9e4:	2b 5f       	subi	r18, 0xFB	; 251
     9e6:	ca 01       	movw	r24, r20
     9e8:	88 0f       	add	r24, r24
     9ea:	99 1f       	adc	r25, r25
     9ec:	84 0f       	add	r24, r20
     9ee:	95 1f       	adc	r25, r21
     9f0:	88 0f       	add	r24, r24
     9f2:	99 1f       	adc	r25, r25
     9f4:	fc 01       	movw	r30, r24
     9f6:	ef 57       	subi	r30, 0x7F	; 127
     9f8:	fd 4f       	sbci	r31, 0xFD	; 253
     9fa:	20 83       	st	Z, r18

/* LInked to ISR --- Time --- Task Ststes by ms*/
void OS_Task_Handler(void)
{
  u8 Task_id;
  for (Task_id=0;Task_id<taskCounter;Task_id++)
     9fc:	89 81       	ldd	r24, Y+1	; 0x01
     9fe:	8f 5f       	subi	r24, 0xFF	; 255
     a00:	89 83       	std	Y+1, r24	; 0x01
     a02:	90 91 7c 02 	lds	r25, 0x027C
     a06:	89 81       	ldd	r24, Y+1	; 0x01
     a08:	89 17       	cp	r24, r25
     a0a:	08 f4       	brcc	.+2      	; 0xa0e <OS_Task_Handler+0x11a>
     a0c:	7a cf       	rjmp	.-268    	; 0x902 <OS_Task_Handler+0xe>
		    {
			    taskArray[Task_id].Task_tick_counter+=TICK_TIME;
		    }
	    }  
  }
}
     a0e:	0f 90       	pop	r0
     a10:	cf 91       	pop	r28
     a12:	df 91       	pop	r29
     a14:	08 95       	ret

00000a16 <OS_TaskExecution>:


void OS_TaskExecution(void)
{
     a16:	df 93       	push	r29
     a18:	cf 93       	push	r28
     a1a:	0f 92       	push	r0
     a1c:	cd b7       	in	r28, 0x3d	; 61
     a1e:	de b7       	in	r29, 0x3e	; 62
	u8 Task_id;
	for(Task_id = 0; Task_id<taskCounter; Task_id++)
     a20:	19 82       	std	Y+1, r1	; 0x01
     a22:	35 c0       	rjmp	.+106    	; 0xa8e <OS_TaskExecution+0x78>
	{

		if(taskArray[Task_id].task_state == READY)
     a24:	89 81       	ldd	r24, Y+1	; 0x01
     a26:	28 2f       	mov	r18, r24
     a28:	30 e0       	ldi	r19, 0x00	; 0
     a2a:	c9 01       	movw	r24, r18
     a2c:	88 0f       	add	r24, r24
     a2e:	99 1f       	adc	r25, r25
     a30:	82 0f       	add	r24, r18
     a32:	93 1f       	adc	r25, r19
     a34:	01 96       	adiw	r24, 0x01	; 1
     a36:	88 0f       	add	r24, r24
     a38:	99 1f       	adc	r25, r25
     a3a:	fc 01       	movw	r30, r24
     a3c:	e3 58       	subi	r30, 0x83	; 131
     a3e:	fd 4f       	sbci	r31, 0xFD	; 253
     a40:	80 81       	ld	r24, Z
     a42:	82 30       	cpi	r24, 0x02	; 2
     a44:	09 f5       	brne	.+66     	; 0xa88 <OS_TaskExecution+0x72>
		{
			
			taskArray[Task_id].function();
     a46:	89 81       	ldd	r24, Y+1	; 0x01
     a48:	28 2f       	mov	r18, r24
     a4a:	30 e0       	ldi	r19, 0x00	; 0
     a4c:	c9 01       	movw	r24, r18
     a4e:	88 0f       	add	r24, r24
     a50:	99 1f       	adc	r25, r25
     a52:	82 0f       	add	r24, r18
     a54:	93 1f       	adc	r25, r19
     a56:	88 0f       	add	r24, r24
     a58:	99 1f       	adc	r25, r25
     a5a:	fc 01       	movw	r30, r24
     a5c:	e3 58       	subi	r30, 0x83	; 131
     a5e:	fd 4f       	sbci	r31, 0xFD	; 253
     a60:	01 90       	ld	r0, Z+
     a62:	f0 81       	ld	r31, Z
     a64:	e0 2d       	mov	r30, r0
     a66:	09 95       	icall
			taskArray[Task_id].task_state = BLOCKED;
     a68:	89 81       	ldd	r24, Y+1	; 0x01
     a6a:	28 2f       	mov	r18, r24
     a6c:	30 e0       	ldi	r19, 0x00	; 0
     a6e:	c9 01       	movw	r24, r18
     a70:	88 0f       	add	r24, r24
     a72:	99 1f       	adc	r25, r25
     a74:	82 0f       	add	r24, r18
     a76:	93 1f       	adc	r25, r19
     a78:	01 96       	adiw	r24, 0x01	; 1
     a7a:	88 0f       	add	r24, r24
     a7c:	99 1f       	adc	r25, r25
     a7e:	fc 01       	movw	r30, r24
     a80:	e3 58       	subi	r30, 0x83	; 131
     a82:	fd 4f       	sbci	r31, 0xFD	; 253
     a84:	81 e0       	ldi	r24, 0x01	; 1
     a86:	80 83       	st	Z, r24


void OS_TaskExecution(void)
{
	u8 Task_id;
	for(Task_id = 0; Task_id<taskCounter; Task_id++)
     a88:	89 81       	ldd	r24, Y+1	; 0x01
     a8a:	8f 5f       	subi	r24, 0xFF	; 255
     a8c:	89 83       	std	Y+1, r24	; 0x01
     a8e:	90 91 7c 02 	lds	r25, 0x027C
     a92:	89 81       	ldd	r24, Y+1	; 0x01
     a94:	89 17       	cp	r24, r25
     a96:	30 f2       	brcs	.-116    	; 0xa24 <OS_TaskExecution+0xe>
			taskArray[Task_id].function();
			taskArray[Task_id].task_state = BLOCKED;
		}
	}

}
     a98:	0f 90       	pop	r0
     a9a:	cf 91       	pop	r28
     a9c:	df 91       	pop	r29
     a9e:	08 95       	ret

00000aa0 <Task_UART_Get_20mS>:
#include "../OS/Tasks.h"
#include "../APP/control/MoveControl.h"
#include "../MCAL/UART/UART_interface.h"
void Task_UART_Get_20mS (void)
{
     aa0:	df 93       	push	r29
     aa2:	cf 93       	push	r28
     aa4:	cd b7       	in	r28, 0x3d	; 61
     aa6:	de b7       	in	r29, 0x3e	; 62

	UART_Get();
     aa8:	0e 94 c6 12 	call	0x258c	; 0x258c <UART_Get>
	
}
     aac:	cf 91       	pop	r28
     aae:	df 91       	pop	r29
     ab0:	08 95       	ret

00000ab2 <Task_MOTOR_GetSpeed_50mS>:
void Task_MOTOR_GetSpeed_50mS(void)
{
     ab2:	df 93       	push	r29
     ab4:	cf 93       	push	r28
     ab6:	cd b7       	in	r28, 0x3d	; 61
     ab8:	de b7       	in	r29, 0x3e	; 62

	CarSpeed();
     aba:	0e 94 68 13 	call	0x26d0	; 0x26d0 <CarSpeed>
}
     abe:	cf 91       	pop	r28
     ac0:	df 91       	pop	r29
     ac2:	08 95       	ret

00000ac4 <Task_MOTOR_GetDirection_40mS>:
void Task_MOTOR_GetDirection_40mS(void)
{
     ac4:	df 93       	push	r29
     ac6:	cf 93       	push	r28
     ac8:	cd b7       	in	r28, 0x3d	; 61
     aca:	de b7       	in	r29, 0x3e	; 62

	CarDirection();
     acc:	0e 94 17 13 	call	0x262e	; 0x262e <CarDirection>
}
     ad0:	cf 91       	pop	r28
     ad2:	df 91       	pop	r29
     ad4:	08 95       	ret

00000ad6 <Task_MOTOR_COM_5mS>:

void Task_MOTOR_COM_5mS(void)
{
     ad6:	df 93       	push	r29
     ad8:	cf 93       	push	r28
     ada:	cd b7       	in	r28, 0x3d	; 61
     adc:	de b7       	in	r29, 0x3e	; 62

	COM_handle();
     ade:	0e 94 4f 14 	call	0x289e	; 0x289e <COM_handle>
}
     ae2:	cf 91       	pop	r28
     ae4:	df 91       	pop	r29
     ae6:	08 95       	ret

00000ae8 <UART_Init>:

static void(*UART_RX_Fptr)(void)=NULLPTR;
static void(*UART_TX_Fptr)(void)=NULLPTR;

void UART_Init (void)
{
     ae8:	df 93       	push	r29
     aea:	cf 93       	push	r28
     aec:	cd b7       	in	r28, 0x3d	; 61
     aee:	de b7       	in	r29, 0x3e	; 62
	
	UBRRL = (u8) 103;
     af0:	e9 e2       	ldi	r30, 0x29	; 41
     af2:	f0 e0       	ldi	r31, 0x00	; 0
     af4:	87 e6       	ldi	r24, 0x67	; 103
     af6:	80 83       	st	Z, r24
	/* Configuration of UCSRnA Register  */
	UCSRnB = ( (RXEN<<4) | (TXEN<<3) | (UCSZ2<<2) );
     af8:	ea e2       	ldi	r30, 0x2A	; 42
     afa:	f0 e0       	ldi	r31, 0x00	; 0
     afc:	88 e1       	ldi	r24, 0x18	; 24
     afe:	80 83       	st	Z, r24
	/* Configure UCRnC Register to make 8-bit data & 1 stop bit & no parity  Asynchronous Mode*/
	UCSRnC = ((UMSEL << 6) | (UPM1 << 5) | (UPM0 << 4)| (USBS << 3) | (UCSZ1 << 2) | (UCSZ0 << 1));
     b00:	e5 e9       	ldi	r30, 0x95	; 149
     b02:	f0 e0       	ldi	r31, 0x00	; 0
     b04:	86 e0       	ldi	r24, 0x06	; 6
     b06:	80 83       	st	Z, r24
}
     b08:	cf 91       	pop	r28
     b0a:	df 91       	pop	r29
     b0c:	08 95       	ret

00000b0e <UART_TransmitData>:


void UART_TransmitData (u8 UART_DataToBeSent)
{
     b0e:	df 93       	push	r29
     b10:	cf 93       	push	r28
     b12:	0f 92       	push	r0
     b14:	cd b7       	in	r28, 0x3d	; 61
     b16:	de b7       	in	r29, 0x3e	; 62
     b18:	89 83       	std	Y+1, r24	; 0x01
	while(GET_BIT(UCSRnA,5)==0);
     b1a:	eb e2       	ldi	r30, 0x2B	; 43
     b1c:	f0 e0       	ldi	r31, 0x00	; 0
     b1e:	80 81       	ld	r24, Z
     b20:	82 95       	swap	r24
     b22:	86 95       	lsr	r24
     b24:	87 70       	andi	r24, 0x07	; 7
     b26:	88 2f       	mov	r24, r24
     b28:	90 e0       	ldi	r25, 0x00	; 0
     b2a:	81 70       	andi	r24, 0x01	; 1
     b2c:	90 70       	andi	r25, 0x00	; 0
     b2e:	00 97       	sbiw	r24, 0x00	; 0
     b30:	a1 f3       	breq	.-24     	; 0xb1a <UART_TransmitData+0xc>
	/* So put data in the UDR Register */
	UDR=(u8)UART_DataToBeSent;
     b32:	ec e2       	ldi	r30, 0x2C	; 44
     b34:	f0 e0       	ldi	r31, 0x00	; 0
     b36:	89 81       	ldd	r24, Y+1	; 0x01
     b38:	80 83       	st	Z, r24
}
     b3a:	0f 90       	pop	r0
     b3c:	cf 91       	pop	r28
     b3e:	df 91       	pop	r29
     b40:	08 95       	ret

00000b42 <UART_RecieveData>:

u8 UART_RecieveData(void)
{
     b42:	df 93       	push	r29
     b44:	cf 93       	push	r28
     b46:	cd b7       	in	r28, 0x3d	; 61
     b48:	de b7       	in	r29, 0x3e	; 62
	while ( ! (UCSRnA & (1<<7)) );
     b4a:	eb e2       	ldi	r30, 0x2B	; 43
     b4c:	f0 e0       	ldi	r31, 0x00	; 0
     b4e:	80 81       	ld	r24, Z
     b50:	88 23       	and	r24, r24
     b52:	dc f7       	brge	.-10     	; 0xb4a <UART_RecieveData+0x8>
	return UDR;
     b54:	ec e2       	ldi	r30, 0x2C	; 44
     b56:	f0 e0       	ldi	r31, 0x00	; 0
     b58:	80 81       	ld	r24, Z
}
     b5a:	cf 91       	pop	r28
     b5c:	df 91       	pop	r29
     b5e:	08 95       	ret

00000b60 <UART_Send_String>:

void UART_Send_String(char *ptr)
{
     b60:	df 93       	push	r29
     b62:	cf 93       	push	r28
     b64:	00 d0       	rcall	.+0      	; 0xb66 <UART_Send_String+0x6>
     b66:	0f 92       	push	r0
     b68:	cd b7       	in	r28, 0x3d	; 61
     b6a:	de b7       	in	r29, 0x3e	; 62
     b6c:	9b 83       	std	Y+3, r25	; 0x03
     b6e:	8a 83       	std	Y+2, r24	; 0x02
	u8 Iteretor=0;
     b70:	19 82       	std	Y+1, r1	; 0x01
     b72:	0e c0       	rjmp	.+28     	; 0xb90 <UART_Send_String+0x30>
	while(ptr[Iteretor]!='\0')
	{
		UART_TransmitData(ptr[Iteretor]);
     b74:	89 81       	ldd	r24, Y+1	; 0x01
     b76:	28 2f       	mov	r18, r24
     b78:	30 e0       	ldi	r19, 0x00	; 0
     b7a:	8a 81       	ldd	r24, Y+2	; 0x02
     b7c:	9b 81       	ldd	r25, Y+3	; 0x03
     b7e:	fc 01       	movw	r30, r24
     b80:	e2 0f       	add	r30, r18
     b82:	f3 1f       	adc	r31, r19
     b84:	80 81       	ld	r24, Z
     b86:	0e 94 87 05 	call	0xb0e	; 0xb0e <UART_TransmitData>
		Iteretor++;
     b8a:	89 81       	ldd	r24, Y+1	; 0x01
     b8c:	8f 5f       	subi	r24, 0xFF	; 255
     b8e:	89 83       	std	Y+1, r24	; 0x01
}

void UART_Send_String(char *ptr)
{
	u8 Iteretor=0;
	while(ptr[Iteretor]!='\0')
     b90:	89 81       	ldd	r24, Y+1	; 0x01
     b92:	28 2f       	mov	r18, r24
     b94:	30 e0       	ldi	r19, 0x00	; 0
     b96:	8a 81       	ldd	r24, Y+2	; 0x02
     b98:	9b 81       	ldd	r25, Y+3	; 0x03
     b9a:	fc 01       	movw	r30, r24
     b9c:	e2 0f       	add	r30, r18
     b9e:	f3 1f       	adc	r31, r19
     ba0:	80 81       	ld	r24, Z
     ba2:	88 23       	and	r24, r24
     ba4:	39 f7       	brne	.-50     	; 0xb74 <UART_Send_String+0x14>
	{
		UART_TransmitData(ptr[Iteretor]);
		Iteretor++;
	}
}
     ba6:	0f 90       	pop	r0
     ba8:	0f 90       	pop	r0
     baa:	0f 90       	pop	r0
     bac:	cf 91       	pop	r28
     bae:	df 91       	pop	r29
     bb0:	08 95       	ret

00000bb2 <UART_ReceiveNum>:


u8 UART_ReceiveNum(void)
{
     bb2:	df 93       	push	r29
     bb4:	cf 93       	push	r28
     bb6:	0f 92       	push	r0
     bb8:	cd b7       	in	r28, 0x3d	; 61
     bba:	de b7       	in	r29, 0x3e	; 62
	u8 NUM1;
	NUM1 = UART_ReceiveNoBlock();
     bbc:	0e 94 53 06 	call	0xca6	; 0xca6 <UART_ReceiveNoBlock>
     bc0:	89 83       	std	Y+1, r24	; 0x01
	NUM1=NUM1-'0';
     bc2:	89 81       	ldd	r24, Y+1	; 0x01
     bc4:	80 53       	subi	r24, 0x30	; 48
     bc6:	89 83       	std	Y+1, r24	; 0x01
	return NUM1;
     bc8:	89 81       	ldd	r24, Y+1	; 0x01
}
     bca:	0f 90       	pop	r0
     bcc:	cf 91       	pop	r28
     bce:	df 91       	pop	r29
     bd0:	08 95       	ret

00000bd2 <UART_RX_InterruptEnable>:
/***********************************UART INTERRUPT**********************/
void UART_RX_InterruptEnable(void)
{
     bd2:	df 93       	push	r29
     bd4:	cf 93       	push	r28
     bd6:	cd b7       	in	r28, 0x3d	; 61
     bd8:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(UCSRB,RXCIE);
     bda:	aa e2       	ldi	r26, 0x2A	; 42
     bdc:	b0 e0       	ldi	r27, 0x00	; 0
     bde:	ea e2       	ldi	r30, 0x2A	; 42
     be0:	f0 e0       	ldi	r31, 0x00	; 0
     be2:	80 81       	ld	r24, Z
     be4:	80 68       	ori	r24, 0x80	; 128
     be6:	8c 93       	st	X, r24
}
     be8:	cf 91       	pop	r28
     bea:	df 91       	pop	r29
     bec:	08 95       	ret

00000bee <UART_RX_InterruptDisable>:

void UART_RX_InterruptDisable(void)
{
     bee:	df 93       	push	r29
     bf0:	cf 93       	push	r28
     bf2:	cd b7       	in	r28, 0x3d	; 61
     bf4:	de b7       	in	r29, 0x3e	; 62
	CLR_BIT(UCSRB,RXCIE);
     bf6:	aa e2       	ldi	r26, 0x2A	; 42
     bf8:	b0 e0       	ldi	r27, 0x00	; 0
     bfa:	ea e2       	ldi	r30, 0x2A	; 42
     bfc:	f0 e0       	ldi	r31, 0x00	; 0
     bfe:	80 81       	ld	r24, Z
     c00:	8f 77       	andi	r24, 0x7F	; 127
     c02:	8c 93       	st	X, r24
}
     c04:	cf 91       	pop	r28
     c06:	df 91       	pop	r29
     c08:	08 95       	ret

00000c0a <UART_TX_InterruptEnable>:

void UART_TX_InterruptEnable(void)
{
     c0a:	df 93       	push	r29
     c0c:	cf 93       	push	r28
     c0e:	cd b7       	in	r28, 0x3d	; 61
     c10:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(UCSRB,TXCIE);
     c12:	aa e2       	ldi	r26, 0x2A	; 42
     c14:	b0 e0       	ldi	r27, 0x00	; 0
     c16:	ea e2       	ldi	r30, 0x2A	; 42
     c18:	f0 e0       	ldi	r31, 0x00	; 0
     c1a:	80 81       	ld	r24, Z
     c1c:	80 64       	ori	r24, 0x40	; 64
     c1e:	8c 93       	st	X, r24
}
     c20:	cf 91       	pop	r28
     c22:	df 91       	pop	r29
     c24:	08 95       	ret

00000c26 <UART_TX_InterruptDisable>:

void UART_TX_InterruptDisable(void)
{
     c26:	df 93       	push	r29
     c28:	cf 93       	push	r28
     c2a:	cd b7       	in	r28, 0x3d	; 61
     c2c:	de b7       	in	r29, 0x3e	; 62
	CLR_BIT(UCSRB,TXCIE);
     c2e:	aa e2       	ldi	r26, 0x2A	; 42
     c30:	b0 e0       	ldi	r27, 0x00	; 0
     c32:	ea e2       	ldi	r30, 0x2A	; 42
     c34:	f0 e0       	ldi	r31, 0x00	; 0
     c36:	80 81       	ld	r24, Z
     c38:	8f 7b       	andi	r24, 0xBF	; 191
     c3a:	8c 93       	st	X, r24
}
     c3c:	cf 91       	pop	r28
     c3e:	df 91       	pop	r29
     c40:	08 95       	ret

00000c42 <UART_RX_SetCallBack>:

void UART_RX_SetCallBack(void (*LocalFptr)(void))
{
     c42:	df 93       	push	r29
     c44:	cf 93       	push	r28
     c46:	00 d0       	rcall	.+0      	; 0xc48 <UART_RX_SetCallBack+0x6>
     c48:	cd b7       	in	r28, 0x3d	; 61
     c4a:	de b7       	in	r29, 0x3e	; 62
     c4c:	9a 83       	std	Y+2, r25	; 0x02
     c4e:	89 83       	std	Y+1, r24	; 0x01
	UART_RX_Fptr = LocalFptr;
     c50:	89 81       	ldd	r24, Y+1	; 0x01
     c52:	9a 81       	ldd	r25, Y+2	; 0x02
     c54:	90 93 96 02 	sts	0x0296, r25
     c58:	80 93 95 02 	sts	0x0295, r24
}
     c5c:	0f 90       	pop	r0
     c5e:	0f 90       	pop	r0
     c60:	cf 91       	pop	r28
     c62:	df 91       	pop	r29
     c64:	08 95       	ret

00000c66 <UART_TX_SetCallBack>:

void UART_TX_SetCallBack(void (*LocalFptr)(void))
{
     c66:	df 93       	push	r29
     c68:	cf 93       	push	r28
     c6a:	00 d0       	rcall	.+0      	; 0xc6c <UART_TX_SetCallBack+0x6>
     c6c:	cd b7       	in	r28, 0x3d	; 61
     c6e:	de b7       	in	r29, 0x3e	; 62
     c70:	9a 83       	std	Y+2, r25	; 0x02
     c72:	89 83       	std	Y+1, r24	; 0x01
	UART_TX_Fptr = LocalFptr;
     c74:	89 81       	ldd	r24, Y+1	; 0x01
     c76:	9a 81       	ldd	r25, Y+2	; 0x02
     c78:	90 93 98 02 	sts	0x0298, r25
     c7c:	80 93 97 02 	sts	0x0297, r24
}
     c80:	0f 90       	pop	r0
     c82:	0f 90       	pop	r0
     c84:	cf 91       	pop	r28
     c86:	df 91       	pop	r29
     c88:	08 95       	ret

00000c8a <UART_SendNoBlock>:

void UART_SendNoBlock (u8 data)
{
     c8a:	df 93       	push	r29
     c8c:	cf 93       	push	r28
     c8e:	0f 92       	push	r0
     c90:	cd b7       	in	r28, 0x3d	; 61
     c92:	de b7       	in	r29, 0x3e	; 62
     c94:	89 83       	std	Y+1, r24	; 0x01
	UDR = data ;
     c96:	ec e2       	ldi	r30, 0x2C	; 44
     c98:	f0 e0       	ldi	r31, 0x00	; 0
     c9a:	89 81       	ldd	r24, Y+1	; 0x01
     c9c:	80 83       	st	Z, r24
}
     c9e:	0f 90       	pop	r0
     ca0:	cf 91       	pop	r28
     ca2:	df 91       	pop	r29
     ca4:	08 95       	ret

00000ca6 <UART_ReceiveNoBlock>:
u8 UART_ReceiveNoBlock (void)
{
     ca6:	df 93       	push	r29
     ca8:	cf 93       	push	r28
     caa:	cd b7       	in	r28, 0x3d	; 61
     cac:	de b7       	in	r29, 0x3e	; 62
	return UDR ;
     cae:	ec e2       	ldi	r30, 0x2C	; 44
     cb0:	f0 e0       	ldi	r31, 0x00	; 0
     cb2:	80 81       	ld	r24, Z
}
     cb4:	cf 91       	pop	r28
     cb6:	df 91       	pop	r29
     cb8:	08 95       	ret

00000cba <__vector_18>:

void __vector_18 (void) __attribute__((signal));
void __vector_18 (void)
{
     cba:	1f 92       	push	r1
     cbc:	0f 92       	push	r0
     cbe:	0f b6       	in	r0, 0x3f	; 63
     cc0:	0f 92       	push	r0
     cc2:	00 90 5b 00 	lds	r0, 0x005B
     cc6:	0f 92       	push	r0
     cc8:	11 24       	eor	r1, r1
     cca:	2f 93       	push	r18
     ccc:	3f 93       	push	r19
     cce:	4f 93       	push	r20
     cd0:	5f 93       	push	r21
     cd2:	6f 93       	push	r22
     cd4:	7f 93       	push	r23
     cd6:	8f 93       	push	r24
     cd8:	9f 93       	push	r25
     cda:	af 93       	push	r26
     cdc:	bf 93       	push	r27
     cde:	ef 93       	push	r30
     ce0:	ff 93       	push	r31
     ce2:	df 93       	push	r29
     ce4:	cf 93       	push	r28
     ce6:	cd b7       	in	r28, 0x3d	; 61
     ce8:	de b7       	in	r29, 0x3e	; 62
	if (UART_RX_Fptr!=NULLPTR)
     cea:	80 91 95 02 	lds	r24, 0x0295
     cee:	90 91 96 02 	lds	r25, 0x0296
     cf2:	00 97       	sbiw	r24, 0x00	; 0
     cf4:	29 f0       	breq	.+10     	; 0xd00 <__vector_18+0x46>
	{
		UART_RX_Fptr();
     cf6:	e0 91 95 02 	lds	r30, 0x0295
     cfa:	f0 91 96 02 	lds	r31, 0x0296
     cfe:	09 95       	icall
	}
}
     d00:	cf 91       	pop	r28
     d02:	df 91       	pop	r29
     d04:	ff 91       	pop	r31
     d06:	ef 91       	pop	r30
     d08:	bf 91       	pop	r27
     d0a:	af 91       	pop	r26
     d0c:	9f 91       	pop	r25
     d0e:	8f 91       	pop	r24
     d10:	7f 91       	pop	r23
     d12:	6f 91       	pop	r22
     d14:	5f 91       	pop	r21
     d16:	4f 91       	pop	r20
     d18:	3f 91       	pop	r19
     d1a:	2f 91       	pop	r18
     d1c:	0f 90       	pop	r0
     d1e:	00 92 5b 00 	sts	0x005B, r0
     d22:	0f 90       	pop	r0
     d24:	0f be       	out	0x3f, r0	; 63
     d26:	0f 90       	pop	r0
     d28:	1f 90       	pop	r1
     d2a:	18 95       	reti

00000d2c <__vector_20>:

void __vector_20 (void) __attribute__((signal));
void __vector_20 (void)
{
     d2c:	1f 92       	push	r1
     d2e:	0f 92       	push	r0
     d30:	0f b6       	in	r0, 0x3f	; 63
     d32:	0f 92       	push	r0
     d34:	00 90 5b 00 	lds	r0, 0x005B
     d38:	0f 92       	push	r0
     d3a:	11 24       	eor	r1, r1
     d3c:	2f 93       	push	r18
     d3e:	3f 93       	push	r19
     d40:	4f 93       	push	r20
     d42:	5f 93       	push	r21
     d44:	6f 93       	push	r22
     d46:	7f 93       	push	r23
     d48:	8f 93       	push	r24
     d4a:	9f 93       	push	r25
     d4c:	af 93       	push	r26
     d4e:	bf 93       	push	r27
     d50:	ef 93       	push	r30
     d52:	ff 93       	push	r31
     d54:	df 93       	push	r29
     d56:	cf 93       	push	r28
     d58:	cd b7       	in	r28, 0x3d	; 61
     d5a:	de b7       	in	r29, 0x3e	; 62
	if (UART_TX_Fptr!=NULLPTR)
     d5c:	80 91 97 02 	lds	r24, 0x0297
     d60:	90 91 98 02 	lds	r25, 0x0298
     d64:	00 97       	sbiw	r24, 0x00	; 0
     d66:	29 f0       	breq	.+10     	; 0xd72 <__vector_20+0x46>
	{
		UART_TX_Fptr();
     d68:	e0 91 97 02 	lds	r30, 0x0297
     d6c:	f0 91 98 02 	lds	r31, 0x0298
     d70:	09 95       	icall
	}
}
     d72:	cf 91       	pop	r28
     d74:	df 91       	pop	r29
     d76:	ff 91       	pop	r31
     d78:	ef 91       	pop	r30
     d7a:	bf 91       	pop	r27
     d7c:	af 91       	pop	r26
     d7e:	9f 91       	pop	r25
     d80:	8f 91       	pop	r24
     d82:	7f 91       	pop	r23
     d84:	6f 91       	pop	r22
     d86:	5f 91       	pop	r21
     d88:	4f 91       	pop	r20
     d8a:	3f 91       	pop	r19
     d8c:	2f 91       	pop	r18
     d8e:	0f 90       	pop	r0
     d90:	00 92 5b 00 	sts	0x005B, r0
     d94:	0f 90       	pop	r0
     d96:	0f be       	out	0x3f, r0	; 63
     d98:	0f 90       	pop	r0
     d9a:	1f 90       	pop	r1
     d9c:	18 95       	reti

00000d9e <TMR0_Init>:
static void (*private_pCallBackOVF)(void)=NULLPTR;
static void (*private_pCallBackCTC)(void)=NULLPTR;
volatile static u16 private_ctcCounter;

void TMR0_Init (void)
{
     d9e:	df 93       	push	r29
     da0:	cf 93       	push	r28
     da2:	cd b7       	in	r28, 0x3d	; 61
     da4:	de b7       	in	r29, 0x3e	; 62
	 SET_BIT(TCCR0,COM00);
	 #endif
	 /******** PHASE_CORRECT MODE ********/
	 #elif TMR0_MODE == TMR0_PHASE_CORRECT_MODE
	 /*	SelectMode=TMR0_FAST_PWM_MODE */
	 SET_BIT(TCCR0,WGM00);
     da6:	a3 e5       	ldi	r26, 0x53	; 83
     da8:	b0 e0       	ldi	r27, 0x00	; 0
     daa:	e3 e5       	ldi	r30, 0x53	; 83
     dac:	f0 e0       	ldi	r31, 0x00	; 0
     dae:	80 81       	ld	r24, Z
     db0:	80 64       	ori	r24, 0x40	; 64
     db2:	8c 93       	st	X, r24
	 CLR_BIT(TCCR0,WGM01);
     db4:	a3 e5       	ldi	r26, 0x53	; 83
     db6:	b0 e0       	ldi	r27, 0x00	; 0
     db8:	e3 e5       	ldi	r30, 0x53	; 83
     dba:	f0 e0       	ldi	r31, 0x00	; 0
     dbc:	80 81       	ld	r24, Z
     dbe:	87 7f       	andi	r24, 0xF7	; 247
     dc0:	8c 93       	st	X, r24
	 
	 /*	Select Mode OF PHASE_CORRECT  */
	 #if TMR0_PWM_MOD == TMR0_PWM_NONINVERTING
	 CLR_BIT(TCCR0,COM00);
     dc2:	a3 e5       	ldi	r26, 0x53	; 83
     dc4:	b0 e0       	ldi	r27, 0x00	; 0
     dc6:	e3 e5       	ldi	r30, 0x53	; 83
     dc8:	f0 e0       	ldi	r31, 0x00	; 0
     dca:	80 81       	ld	r24, Z
     dcc:	8f 7e       	andi	r24, 0xEF	; 239
     dce:	8c 93       	st	X, r24
	 SET_BIT(TCCR0,COM01);
     dd0:	a3 e5       	ldi	r26, 0x53	; 83
     dd2:	b0 e0       	ldi	r27, 0x00	; 0
     dd4:	e3 e5       	ldi	r30, 0x53	; 83
     dd6:	f0 e0       	ldi	r31, 0x00	; 0
     dd8:	80 81       	ld	r24, Z
     dda:	80 62       	ori	r24, 0x20	; 32
     ddc:	8c 93       	st	X, r24
	 SET_BIT(TCCR0,COM01);
	 SET_BIT(TCCR0,COM00);
	 #endif
		
	#endif
}
     dde:	cf 91       	pop	r28
     de0:	df 91       	pop	r29
     de2:	08 95       	ret

00000de4 <TMR0_SetComparematchValue>:
/*   Output Compare Register */
void TMR0_SetComparematchValue (u8 copy_u8compareValue) //set value to compare 
{
     de4:	df 93       	push	r29
     de6:	cf 93       	push	r28
     de8:	0f 92       	push	r0
     dea:	cd b7       	in	r28, 0x3d	; 61
     dec:	de b7       	in	r29, 0x3e	; 62
     dee:	89 83       	std	Y+1, r24	; 0x01
	OCR0=copy_u8compareValue;
     df0:	e1 e5       	ldi	r30, 0x51	; 81
     df2:	f0 e0       	ldi	r31, 0x00	; 0
     df4:	89 81       	ldd	r24, Y+1	; 0x01
     df6:	80 83       	st	Z, r24
}
     df8:	0f 90       	pop	r0
     dfa:	cf 91       	pop	r28
     dfc:	df 91       	pop	r29
     dfe:	08 95       	ret

00000e00 <TMR0_setDelay_ms_usingCTC>:
void TMR0_setDelay_ms_usingCTC (u16 copy_u16Delay_ms)
{
     e00:	df 93       	push	r29
     e02:	cf 93       	push	r28
     e04:	00 d0       	rcall	.+0      	; 0xe06 <TMR0_setDelay_ms_usingCTC+0x6>
     e06:	cd b7       	in	r28, 0x3d	; 61
     e08:	de b7       	in	r29, 0x3e	; 62
     e0a:	9a 83       	std	Y+2, r25	; 0x02
     e0c:	89 83       	std	Y+1, r24	; 0x01
	// under condition tick time .5ms
	OCR0=249;
	private_ctcCounter= copy_u16Delay_ms*8 ; // TimeDelay configurable delay from developer  /8=1000/125
	#elif TMR0_PRESCALER == TMR0_PRESCALER_64
	// under condition tick time 4ms
	OCR0=249;
     e0e:	e1 e5       	ldi	r30, 0x51	; 81
     e10:	f0 e0       	ldi	r31, 0x00	; 0
     e12:	89 ef       	ldi	r24, 0xF9	; 249
     e14:	80 83       	st	Z, r24
	private_ctcCounter=copy_u16Delay_ms; // TimeDelay configurable delay from developer
     e16:	89 81       	ldd	r24, Y+1	; 0x01
     e18:	9a 81       	ldd	r25, Y+2	; 0x02
     e1a:	90 93 a6 02 	sts	0x02A6, r25
     e1e:	80 93 a5 02 	sts	0x02A5, r24
	
	#elif TMR0_PRESCALER == TMR0_PRESCALER_1024
	
	#endif
	
}
     e22:	0f 90       	pop	r0
     e24:	0f 90       	pop	r0
     e26:	cf 91       	pop	r28
     e28:	df 91       	pop	r29
     e2a:	08 95       	ret

00000e2c <TMR0_Start>:
void TMR0_Start (void)
{
     e2c:	df 93       	push	r29
     e2e:	cf 93       	push	r28
     e30:	cd b7       	in	r28, 0x3d	; 61
     e32:	de b7       	in	r29, 0x3e	; 62
	CLR_BIT(TCCR0,CS00);
	SET_BIT(TCCR0,CS01);
	CLR_BIT(TCCR0,CS02);
	#elif TMR0_PRESCALER == TMR0_PRESCALER_64
	/*	SelectPreScaller=64 */
	SET_BIT(TCCR0,CS00);
     e34:	a3 e5       	ldi	r26, 0x53	; 83
     e36:	b0 e0       	ldi	r27, 0x00	; 0
     e38:	e3 e5       	ldi	r30, 0x53	; 83
     e3a:	f0 e0       	ldi	r31, 0x00	; 0
     e3c:	80 81       	ld	r24, Z
     e3e:	81 60       	ori	r24, 0x01	; 1
     e40:	8c 93       	st	X, r24
	SET_BIT(TCCR0,CS01);
     e42:	a3 e5       	ldi	r26, 0x53	; 83
     e44:	b0 e0       	ldi	r27, 0x00	; 0
     e46:	e3 e5       	ldi	r30, 0x53	; 83
     e48:	f0 e0       	ldi	r31, 0x00	; 0
     e4a:	80 81       	ld	r24, Z
     e4c:	82 60       	ori	r24, 0x02	; 2
     e4e:	8c 93       	st	X, r24
	CLR_BIT(TCCR0,CS02);
     e50:	a3 e5       	ldi	r26, 0x53	; 83
     e52:	b0 e0       	ldi	r27, 0x00	; 0
     e54:	e3 e5       	ldi	r30, 0x53	; 83
     e56:	f0 e0       	ldi	r31, 0x00	; 0
     e58:	80 81       	ld	r24, Z
     e5a:	8b 7f       	andi	r24, 0xFB	; 251
     e5c:	8c 93       	st	X, r24
	/*	SelectPreScaller=1024 */
	SET_BIT(TCCR0,CS00);
	CLR_BIT(TCCR0,CS01);
	SET_BIT(TCCR0,CS02);
	#endif
}
     e5e:	cf 91       	pop	r28
     e60:	df 91       	pop	r29
     e62:	08 95       	ret

00000e64 <TMR0_SetDutyCycle>:
void TMR0_SetDutyCycle (u8 copy_u8DutyCycle)
{
     e64:	df 93       	push	r29
     e66:	cf 93       	push	r28
     e68:	0f 92       	push	r0
     e6a:	cd b7       	in	r28, 0x3d	; 61
     e6c:	de b7       	in	r29, 0x3e	; 62
     e6e:	89 83       	std	Y+1, r24	; 0x01
		copy_u8DutyCycle=100-copy_u8DutyCycle;
		OCR0=(((u16) copy_u8DutyCycle *256)/100)-1;
		#endif
	}
	#elif TMR0_MODE == TMR0_PHASE_CORRECT_MODE
	if(copy_u8DutyCycle<=100)
     e70:	89 81       	ldd	r24, Y+1	; 0x01
     e72:	85 36       	cpi	r24, 0x65	; 101
     e74:	d0 f4       	brcc	.+52     	; 0xeaa <TMR0_SetDutyCycle+0x46>
	{
		#if TMR0_PWM_MOD == TMR0_PWM_NONINVERTING
		OCR0=(((u16) copy_u8DutyCycle *255)/100);
     e76:	e1 e5       	ldi	r30, 0x51	; 81
     e78:	f0 e0       	ldi	r31, 0x00	; 0
     e7a:	89 81       	ldd	r24, Y+1	; 0x01
     e7c:	48 2f       	mov	r20, r24
     e7e:	50 e0       	ldi	r21, 0x00	; 0
     e80:	ca 01       	movw	r24, r20
     e82:	9c 01       	movw	r18, r24
     e84:	22 0f       	add	r18, r18
     e86:	33 1f       	adc	r19, r19
     e88:	c9 01       	movw	r24, r18
     e8a:	96 95       	lsr	r25
     e8c:	98 2f       	mov	r25, r24
     e8e:	88 27       	eor	r24, r24
     e90:	97 95       	ror	r25
     e92:	87 95       	ror	r24
     e94:	82 1b       	sub	r24, r18
     e96:	93 0b       	sbc	r25, r19
     e98:	84 0f       	add	r24, r20
     e9a:	95 1f       	adc	r25, r21
     e9c:	24 e6       	ldi	r18, 0x64	; 100
     e9e:	30 e0       	ldi	r19, 0x00	; 0
     ea0:	b9 01       	movw	r22, r18
     ea2:	0e 94 9d 15 	call	0x2b3a	; 0x2b3a <__udivmodhi4>
     ea6:	cb 01       	movw	r24, r22
     ea8:	80 83       	st	Z, r24
		copy_u8DutyCycle=100-copy_u8DutyCycle;
		OCR0=(((u16) copy_u8DutyCycle *255)/100);
		#endif
	}
	#endif
}
     eaa:	0f 90       	pop	r0
     eac:	cf 91       	pop	r28
     eae:	df 91       	pop	r29
     eb0:	08 95       	ret

00000eb2 <TMR0_Stop>:
void TMR0_Stop (void)
{
     eb2:	df 93       	push	r29
     eb4:	cf 93       	push	r28
     eb6:	cd b7       	in	r28, 0x3d	; 61
     eb8:	de b7       	in	r29, 0x3e	; 62
		/*	stop timer */
		CLR_BIT(TCCR0,CS00);
     eba:	a3 e5       	ldi	r26, 0x53	; 83
     ebc:	b0 e0       	ldi	r27, 0x00	; 0
     ebe:	e3 e5       	ldi	r30, 0x53	; 83
     ec0:	f0 e0       	ldi	r31, 0x00	; 0
     ec2:	80 81       	ld	r24, Z
     ec4:	8e 7f       	andi	r24, 0xFE	; 254
     ec6:	8c 93       	st	X, r24
		CLR_BIT(TCCR0,CS01);
     ec8:	a3 e5       	ldi	r26, 0x53	; 83
     eca:	b0 e0       	ldi	r27, 0x00	; 0
     ecc:	e3 e5       	ldi	r30, 0x53	; 83
     ece:	f0 e0       	ldi	r31, 0x00	; 0
     ed0:	80 81       	ld	r24, Z
     ed2:	8d 7f       	andi	r24, 0xFD	; 253
     ed4:	8c 93       	st	X, r24
		CLR_BIT(TCCR0,CS02);
     ed6:	a3 e5       	ldi	r26, 0x53	; 83
     ed8:	b0 e0       	ldi	r27, 0x00	; 0
     eda:	e3 e5       	ldi	r30, 0x53	; 83
     edc:	f0 e0       	ldi	r31, 0x00	; 0
     ede:	80 81       	ld	r24, Z
     ee0:	8b 7f       	andi	r24, 0xFB	; 251
     ee2:	8c 93       	st	X, r24
}
     ee4:	cf 91       	pop	r28
     ee6:	df 91       	pop	r29
     ee8:	08 95       	ret

00000eea <TMR0_SetCallBackOVF>:
/* CallBack OVF */
void TMR0_SetCallBackOVF (void(*PtrToFun)(void))
{
     eea:	df 93       	push	r29
     eec:	cf 93       	push	r28
     eee:	00 d0       	rcall	.+0      	; 0xef0 <TMR0_SetCallBackOVF+0x6>
     ef0:	cd b7       	in	r28, 0x3d	; 61
     ef2:	de b7       	in	r29, 0x3e	; 62
     ef4:	9a 83       	std	Y+2, r25	; 0x02
     ef6:	89 83       	std	Y+1, r24	; 0x01
	if (PtrToFun!=NULLPTR) //validation to check if pointer == null or not 
     ef8:	89 81       	ldd	r24, Y+1	; 0x01
     efa:	9a 81       	ldd	r25, Y+2	; 0x02
     efc:	00 97       	sbiw	r24, 0x00	; 0
     efe:	31 f0       	breq	.+12     	; 0xf0c <TMR0_SetCallBackOVF+0x22>
	{
		private_pCallBackOVF=PtrToFun;
     f00:	89 81       	ldd	r24, Y+1	; 0x01
     f02:	9a 81       	ldd	r25, Y+2	; 0x02
     f04:	90 93 9a 02 	sts	0x029A, r25
     f08:	80 93 99 02 	sts	0x0299, r24
	}

}
     f0c:	0f 90       	pop	r0
     f0e:	0f 90       	pop	r0
     f10:	cf 91       	pop	r28
     f12:	df 91       	pop	r29
     f14:	08 95       	ret

00000f16 <TMR0_SetCallBackCTC>:
/* CallBack CTC */
void TMR0_SetCallBackCTC (void(*PtrToFun)(void))
{
     f16:	df 93       	push	r29
     f18:	cf 93       	push	r28
     f1a:	00 d0       	rcall	.+0      	; 0xf1c <TMR0_SetCallBackCTC+0x6>
     f1c:	cd b7       	in	r28, 0x3d	; 61
     f1e:	de b7       	in	r29, 0x3e	; 62
     f20:	9a 83       	std	Y+2, r25	; 0x02
     f22:	89 83       	std	Y+1, r24	; 0x01
	if (PtrToFun!=NULLPTR)
     f24:	89 81       	ldd	r24, Y+1	; 0x01
     f26:	9a 81       	ldd	r25, Y+2	; 0x02
     f28:	00 97       	sbiw	r24, 0x00	; 0
     f2a:	31 f0       	breq	.+12     	; 0xf38 <TMR0_SetCallBackCTC+0x22>
	{
			private_pCallBackCTC=PtrToFun;
     f2c:	89 81       	ldd	r24, Y+1	; 0x01
     f2e:	9a 81       	ldd	r25, Y+2	; 0x02
     f30:	90 93 9c 02 	sts	0x029C, r25
     f34:	80 93 9b 02 	sts	0x029B, r24
	}

}
     f38:	0f 90       	pop	r0
     f3a:	0f 90       	pop	r0
     f3c:	cf 91       	pop	r28
     f3e:	df 91       	pop	r29
     f40:	08 95       	ret

00000f42 <TIMER2_Init>:
/******************* TIMER2 ********************/

void TIMER2_Init (Timer2Mode_type local_mode,Timer2Scaler_type scaler)
{
     f42:	df 93       	push	r29
     f44:	cf 93       	push	r28
     f46:	00 d0       	rcall	.+0      	; 0xf48 <TIMER2_Init+0x6>
     f48:	00 d0       	rcall	.+0      	; 0xf4a <TIMER2_Init+0x8>
     f4a:	cd b7       	in	r28, 0x3d	; 61
     f4c:	de b7       	in	r29, 0x3e	; 62
     f4e:	89 83       	std	Y+1, r24	; 0x01
     f50:	6a 83       	std	Y+2, r22	; 0x02
	//Select TIMER0 Mode
	switch(local_mode)
     f52:	89 81       	ldd	r24, Y+1	; 0x01
     f54:	28 2f       	mov	r18, r24
     f56:	30 e0       	ldi	r19, 0x00	; 0
     f58:	3c 83       	std	Y+4, r19	; 0x04
     f5a:	2b 83       	std	Y+3, r18	; 0x03
     f5c:	8b 81       	ldd	r24, Y+3	; 0x03
     f5e:	9c 81       	ldd	r25, Y+4	; 0x04
     f60:	81 30       	cpi	r24, 0x01	; 1
     f62:	91 05       	cpc	r25, r1
     f64:	21 f1       	breq	.+72     	; 0xfae <TIMER2_Init+0x6c>
     f66:	2b 81       	ldd	r18, Y+3	; 0x03
     f68:	3c 81       	ldd	r19, Y+4	; 0x04
     f6a:	22 30       	cpi	r18, 0x02	; 2
     f6c:	31 05       	cpc	r19, r1
     f6e:	2c f4       	brge	.+10     	; 0xf7a <TIMER2_Init+0x38>
     f70:	8b 81       	ldd	r24, Y+3	; 0x03
     f72:	9c 81       	ldd	r25, Y+4	; 0x04
     f74:	00 97       	sbiw	r24, 0x00	; 0
     f76:	61 f0       	breq	.+24     	; 0xf90 <TIMER2_Init+0x4e>
     f78:	46 c0       	rjmp	.+140    	; 0x1006 <TIMER2_Init+0xc4>
     f7a:	2b 81       	ldd	r18, Y+3	; 0x03
     f7c:	3c 81       	ldd	r19, Y+4	; 0x04
     f7e:	22 30       	cpi	r18, 0x02	; 2
     f80:	31 05       	cpc	r19, r1
     f82:	21 f1       	breq	.+72     	; 0xfcc <TIMER2_Init+0x8a>
     f84:	8b 81       	ldd	r24, Y+3	; 0x03
     f86:	9c 81       	ldd	r25, Y+4	; 0x04
     f88:	83 30       	cpi	r24, 0x03	; 3
     f8a:	91 05       	cpc	r25, r1
     f8c:	71 f1       	breq	.+92     	; 0xfea <TIMER2_Init+0xa8>
     f8e:	3b c0       	rjmp	.+118    	; 0x1006 <TIMER2_Init+0xc4>
	{
		case TIMER2_NORMAL_MODE:
		CLR_BIT(TCCR2,WGM20);
     f90:	a5 e4       	ldi	r26, 0x45	; 69
     f92:	b0 e0       	ldi	r27, 0x00	; 0
     f94:	e5 e4       	ldi	r30, 0x45	; 69
     f96:	f0 e0       	ldi	r31, 0x00	; 0
     f98:	80 81       	ld	r24, Z
     f9a:	8f 7b       	andi	r24, 0xBF	; 191
     f9c:	8c 93       	st	X, r24
		CLR_BIT(TCCR2,WGM21);
     f9e:	a5 e4       	ldi	r26, 0x45	; 69
     fa0:	b0 e0       	ldi	r27, 0x00	; 0
     fa2:	e5 e4       	ldi	r30, 0x45	; 69
     fa4:	f0 e0       	ldi	r31, 0x00	; 0
     fa6:	80 81       	ld	r24, Z
     fa8:	87 7f       	andi	r24, 0xF7	; 247
     faa:	8c 93       	st	X, r24
     fac:	2c c0       	rjmp	.+88     	; 0x1006 <TIMER2_Init+0xc4>
		break;
		case TIMER2_PHASECORRECT_MODE:
		SET_BIT(TCCR2,WGM20);
     fae:	a5 e4       	ldi	r26, 0x45	; 69
     fb0:	b0 e0       	ldi	r27, 0x00	; 0
     fb2:	e5 e4       	ldi	r30, 0x45	; 69
     fb4:	f0 e0       	ldi	r31, 0x00	; 0
     fb6:	80 81       	ld	r24, Z
     fb8:	80 64       	ori	r24, 0x40	; 64
     fba:	8c 93       	st	X, r24
		CLR_BIT(TCCR2,WGM21);
     fbc:	a5 e4       	ldi	r26, 0x45	; 69
     fbe:	b0 e0       	ldi	r27, 0x00	; 0
     fc0:	e5 e4       	ldi	r30, 0x45	; 69
     fc2:	f0 e0       	ldi	r31, 0x00	; 0
     fc4:	80 81       	ld	r24, Z
     fc6:	87 7f       	andi	r24, 0xF7	; 247
     fc8:	8c 93       	st	X, r24
     fca:	1d c0       	rjmp	.+58     	; 0x1006 <TIMER2_Init+0xc4>
		break;
		case TIMER2_CTC_MODE:
		CLR_BIT(TCCR2,WGM20);
     fcc:	a5 e4       	ldi	r26, 0x45	; 69
     fce:	b0 e0       	ldi	r27, 0x00	; 0
     fd0:	e5 e4       	ldi	r30, 0x45	; 69
     fd2:	f0 e0       	ldi	r31, 0x00	; 0
     fd4:	80 81       	ld	r24, Z
     fd6:	8f 7b       	andi	r24, 0xBF	; 191
     fd8:	8c 93       	st	X, r24
		SET_BIT(TCCR2,WGM21);
     fda:	a5 e4       	ldi	r26, 0x45	; 69
     fdc:	b0 e0       	ldi	r27, 0x00	; 0
     fde:	e5 e4       	ldi	r30, 0x45	; 69
     fe0:	f0 e0       	ldi	r31, 0x00	; 0
     fe2:	80 81       	ld	r24, Z
     fe4:	88 60       	ori	r24, 0x08	; 8
     fe6:	8c 93       	st	X, r24
     fe8:	0e c0       	rjmp	.+28     	; 0x1006 <TIMER2_Init+0xc4>
		break;
		case TIMER2_FASTPWM_MODE:
		SET_BIT(TCCR2,WGM20);
     fea:	a5 e4       	ldi	r26, 0x45	; 69
     fec:	b0 e0       	ldi	r27, 0x00	; 0
     fee:	e5 e4       	ldi	r30, 0x45	; 69
     ff0:	f0 e0       	ldi	r31, 0x00	; 0
     ff2:	80 81       	ld	r24, Z
     ff4:	80 64       	ori	r24, 0x40	; 64
     ff6:	8c 93       	st	X, r24
		SET_BIT(TCCR2,WGM21);
     ff8:	a5 e4       	ldi	r26, 0x45	; 69
     ffa:	b0 e0       	ldi	r27, 0x00	; 0
     ffc:	e5 e4       	ldi	r30, 0x45	; 69
     ffe:	f0 e0       	ldi	r31, 0x00	; 0
    1000:	80 81       	ld	r24, Z
    1002:	88 60       	ori	r24, 0x08	; 8
    1004:	8c 93       	st	X, r24
		break;
	}
	TCCR2&=0xF8;//0b11111000
    1006:	a5 e4       	ldi	r26, 0x45	; 69
    1008:	b0 e0       	ldi	r27, 0x00	; 0
    100a:	e5 e4       	ldi	r30, 0x45	; 69
    100c:	f0 e0       	ldi	r31, 0x00	; 0
    100e:	80 81       	ld	r24, Z
    1010:	88 7f       	andi	r24, 0xF8	; 248
    1012:	8c 93       	st	X, r24
	scaler&=0x07;//Filter
    1014:	8a 81       	ldd	r24, Y+2	; 0x02
    1016:	87 70       	andi	r24, 0x07	; 7
    1018:	8a 83       	std	Y+2, r24	; 0x02
	TCCR2|=scaler;
    101a:	a5 e4       	ldi	r26, 0x45	; 69
    101c:	b0 e0       	ldi	r27, 0x00	; 0
    101e:	e5 e4       	ldi	r30, 0x45	; 69
    1020:	f0 e0       	ldi	r31, 0x00	; 0
    1022:	90 81       	ld	r25, Z
    1024:	8a 81       	ldd	r24, Y+2	; 0x02
    1026:	89 2b       	or	r24, r25
    1028:	8c 93       	st	X, r24
}
    102a:	0f 90       	pop	r0
    102c:	0f 90       	pop	r0
    102e:	0f 90       	pop	r0
    1030:	0f 90       	pop	r0
    1032:	cf 91       	pop	r28
    1034:	df 91       	pop	r29
    1036:	08 95       	ret

00001038 <TIMER2_OC2Mode>:

void TIMER2_OC2Mode (OC2Mode_type local_mode)
{
    1038:	df 93       	push	r29
    103a:	cf 93       	push	r28
    103c:	00 d0       	rcall	.+0      	; 0x103e <TIMER2_OC2Mode+0x6>
    103e:	0f 92       	push	r0
    1040:	cd b7       	in	r28, 0x3d	; 61
    1042:	de b7       	in	r29, 0x3e	; 62
    1044:	89 83       	std	Y+1, r24	; 0x01
	switch(local_mode)
    1046:	89 81       	ldd	r24, Y+1	; 0x01
    1048:	28 2f       	mov	r18, r24
    104a:	30 e0       	ldi	r19, 0x00	; 0
    104c:	3b 83       	std	Y+3, r19	; 0x03
    104e:	2a 83       	std	Y+2, r18	; 0x02
    1050:	8a 81       	ldd	r24, Y+2	; 0x02
    1052:	9b 81       	ldd	r25, Y+3	; 0x03
    1054:	81 30       	cpi	r24, 0x01	; 1
    1056:	91 05       	cpc	r25, r1
    1058:	21 f1       	breq	.+72     	; 0x10a2 <TIMER2_OC2Mode+0x6a>
    105a:	2a 81       	ldd	r18, Y+2	; 0x02
    105c:	3b 81       	ldd	r19, Y+3	; 0x03
    105e:	22 30       	cpi	r18, 0x02	; 2
    1060:	31 05       	cpc	r19, r1
    1062:	2c f4       	brge	.+10     	; 0x106e <TIMER2_OC2Mode+0x36>
    1064:	8a 81       	ldd	r24, Y+2	; 0x02
    1066:	9b 81       	ldd	r25, Y+3	; 0x03
    1068:	00 97       	sbiw	r24, 0x00	; 0
    106a:	61 f0       	breq	.+24     	; 0x1084 <TIMER2_OC2Mode+0x4c>
    106c:	46 c0       	rjmp	.+140    	; 0x10fa <TIMER2_OC2Mode+0xc2>
    106e:	2a 81       	ldd	r18, Y+2	; 0x02
    1070:	3b 81       	ldd	r19, Y+3	; 0x03
    1072:	22 30       	cpi	r18, 0x02	; 2
    1074:	31 05       	cpc	r19, r1
    1076:	21 f1       	breq	.+72     	; 0x10c0 <TIMER2_OC2Mode+0x88>
    1078:	8a 81       	ldd	r24, Y+2	; 0x02
    107a:	9b 81       	ldd	r25, Y+3	; 0x03
    107c:	83 30       	cpi	r24, 0x03	; 3
    107e:	91 05       	cpc	r25, r1
    1080:	71 f1       	breq	.+92     	; 0x10de <TIMER2_OC2Mode+0xa6>
    1082:	3b c0       	rjmp	.+118    	; 0x10fa <TIMER2_OC2Mode+0xc2>
	{
		case OC2_DISCONNECTED:
		CLR_BIT(TCCR2,COM20);
    1084:	a5 e4       	ldi	r26, 0x45	; 69
    1086:	b0 e0       	ldi	r27, 0x00	; 0
    1088:	e5 e4       	ldi	r30, 0x45	; 69
    108a:	f0 e0       	ldi	r31, 0x00	; 0
    108c:	80 81       	ld	r24, Z
    108e:	8f 7e       	andi	r24, 0xEF	; 239
    1090:	8c 93       	st	X, r24
		CLR_BIT(TCCR2,COM21);
    1092:	a5 e4       	ldi	r26, 0x45	; 69
    1094:	b0 e0       	ldi	r27, 0x00	; 0
    1096:	e5 e4       	ldi	r30, 0x45	; 69
    1098:	f0 e0       	ldi	r31, 0x00	; 0
    109a:	80 81       	ld	r24, Z
    109c:	8f 7d       	andi	r24, 0xDF	; 223
    109e:	8c 93       	st	X, r24
    10a0:	2c c0       	rjmp	.+88     	; 0x10fa <TIMER2_OC2Mode+0xc2>
		break;
		case OC2_TOGGLE:
		SET_BIT(TCCR2,COM20);
    10a2:	a5 e4       	ldi	r26, 0x45	; 69
    10a4:	b0 e0       	ldi	r27, 0x00	; 0
    10a6:	e5 e4       	ldi	r30, 0x45	; 69
    10a8:	f0 e0       	ldi	r31, 0x00	; 0
    10aa:	80 81       	ld	r24, Z
    10ac:	80 61       	ori	r24, 0x10	; 16
    10ae:	8c 93       	st	X, r24
		CLR_BIT(TCCR2,COM21);
    10b0:	a5 e4       	ldi	r26, 0x45	; 69
    10b2:	b0 e0       	ldi	r27, 0x00	; 0
    10b4:	e5 e4       	ldi	r30, 0x45	; 69
    10b6:	f0 e0       	ldi	r31, 0x00	; 0
    10b8:	80 81       	ld	r24, Z
    10ba:	8f 7d       	andi	r24, 0xDF	; 223
    10bc:	8c 93       	st	X, r24
    10be:	1d c0       	rjmp	.+58     	; 0x10fa <TIMER2_OC2Mode+0xc2>
		break;
		case OC2_NON_INVERTING:
		CLR_BIT(TCCR2,COM20);
    10c0:	a5 e4       	ldi	r26, 0x45	; 69
    10c2:	b0 e0       	ldi	r27, 0x00	; 0
    10c4:	e5 e4       	ldi	r30, 0x45	; 69
    10c6:	f0 e0       	ldi	r31, 0x00	; 0
    10c8:	80 81       	ld	r24, Z
    10ca:	8f 7e       	andi	r24, 0xEF	; 239
    10cc:	8c 93       	st	X, r24
		SET_BIT(TCCR2,COM21);
    10ce:	a5 e4       	ldi	r26, 0x45	; 69
    10d0:	b0 e0       	ldi	r27, 0x00	; 0
    10d2:	e5 e4       	ldi	r30, 0x45	; 69
    10d4:	f0 e0       	ldi	r31, 0x00	; 0
    10d6:	80 81       	ld	r24, Z
    10d8:	80 62       	ori	r24, 0x20	; 32
    10da:	8c 93       	st	X, r24
    10dc:	0e c0       	rjmp	.+28     	; 0x10fa <TIMER2_OC2Mode+0xc2>
		break;
		case OC2_INVERTING:
		SET_BIT(TCCR2,COM20);
    10de:	a5 e4       	ldi	r26, 0x45	; 69
    10e0:	b0 e0       	ldi	r27, 0x00	; 0
    10e2:	e5 e4       	ldi	r30, 0x45	; 69
    10e4:	f0 e0       	ldi	r31, 0x00	; 0
    10e6:	80 81       	ld	r24, Z
    10e8:	80 61       	ori	r24, 0x10	; 16
    10ea:	8c 93       	st	X, r24
		SET_BIT(TCCR2,COM21);
    10ec:	a5 e4       	ldi	r26, 0x45	; 69
    10ee:	b0 e0       	ldi	r27, 0x00	; 0
    10f0:	e5 e4       	ldi	r30, 0x45	; 69
    10f2:	f0 e0       	ldi	r31, 0x00	; 0
    10f4:	80 81       	ld	r24, Z
    10f6:	80 62       	ori	r24, 0x20	; 32
    10f8:	8c 93       	st	X, r24
		break;
	}
}
    10fa:	0f 90       	pop	r0
    10fc:	0f 90       	pop	r0
    10fe:	0f 90       	pop	r0
    1100:	cf 91       	pop	r28
    1102:	df 91       	pop	r29
    1104:	08 95       	ret

00001106 <TMR2_SetDutyCycle>:
void TMR2_SetDutyCycle (u8 copy_u8DutyCycle)
{
    1106:	df 93       	push	r29
    1108:	cf 93       	push	r28
    110a:	0f 92       	push	r0
    110c:	cd b7       	in	r28, 0x3d	; 61
    110e:	de b7       	in	r29, 0x3e	; 62
    1110:	89 83       	std	Y+1, r24	; 0x01

	if(copy_u8DutyCycle<=100)
    1112:	89 81       	ldd	r24, Y+1	; 0x01
    1114:	85 36       	cpi	r24, 0x65	; 101
    1116:	d0 f4       	brcc	.+52     	; 0x114c <TMR2_SetDutyCycle+0x46>
	{
		OCR2=(((u16) copy_u8DutyCycle *255)/100);
    1118:	e3 e4       	ldi	r30, 0x43	; 67
    111a:	f0 e0       	ldi	r31, 0x00	; 0
    111c:	89 81       	ldd	r24, Y+1	; 0x01
    111e:	48 2f       	mov	r20, r24
    1120:	50 e0       	ldi	r21, 0x00	; 0
    1122:	ca 01       	movw	r24, r20
    1124:	9c 01       	movw	r18, r24
    1126:	22 0f       	add	r18, r18
    1128:	33 1f       	adc	r19, r19
    112a:	c9 01       	movw	r24, r18
    112c:	96 95       	lsr	r25
    112e:	98 2f       	mov	r25, r24
    1130:	88 27       	eor	r24, r24
    1132:	97 95       	ror	r25
    1134:	87 95       	ror	r24
    1136:	82 1b       	sub	r24, r18
    1138:	93 0b       	sbc	r25, r19
    113a:	84 0f       	add	r24, r20
    113c:	95 1f       	adc	r25, r21
    113e:	24 e6       	ldi	r18, 0x64	; 100
    1140:	30 e0       	ldi	r19, 0x00	; 0
    1142:	b9 01       	movw	r22, r18
    1144:	0e 94 9d 15 	call	0x2b3a	; 0x2b3a <__udivmodhi4>
    1148:	cb 01       	movw	r24, r22
    114a:	80 83       	st	Z, r24
	}
}
    114c:	0f 90       	pop	r0
    114e:	cf 91       	pop	r28
    1150:	df 91       	pop	r29
    1152:	08 95       	ret

00001154 <TIMER1_Init>:
static void (*Timer1_OVF_Fptr)(void)=NULLPTR;
static void (*Timer1_OCA_Fptr)(void)=NULLPTR;
static void (*Timer1_OCB_Fptr)(void)=NULLPTR;
static void (*Timer1_ICU_Fptr)(void)=NULLPTR;
void TIMER1_Init (Timer1Mode_type local_mode,Timer1Scaler_type scaler)
{
    1154:	df 93       	push	r29
    1156:	cf 93       	push	r28
    1158:	00 d0       	rcall	.+0      	; 0x115a <TIMER1_Init+0x6>
    115a:	00 d0       	rcall	.+0      	; 0x115c <TIMER1_Init+0x8>
    115c:	cd b7       	in	r28, 0x3d	; 61
    115e:	de b7       	in	r29, 0x3e	; 62
    1160:	89 83       	std	Y+1, r24	; 0x01
    1162:	6a 83       	std	Y+2, r22	; 0x02
	//Select TIMER1 Mode
	switch(local_mode)
    1164:	89 81       	ldd	r24, Y+1	; 0x01
    1166:	28 2f       	mov	r18, r24
    1168:	30 e0       	ldi	r19, 0x00	; 0
    116a:	3c 83       	std	Y+4, r19	; 0x04
    116c:	2b 83       	std	Y+3, r18	; 0x03
    116e:	8b 81       	ldd	r24, Y+3	; 0x03
    1170:	9c 81       	ldd	r25, Y+4	; 0x04
    1172:	82 30       	cpi	r24, 0x02	; 2
    1174:	91 05       	cpc	r25, r1
    1176:	09 f4       	brne	.+2      	; 0x117a <TIMER1_Init+0x26>
    1178:	40 c0       	rjmp	.+128    	; 0x11fa <TIMER1_Init+0xa6>
    117a:	2b 81       	ldd	r18, Y+3	; 0x03
    117c:	3c 81       	ldd	r19, Y+4	; 0x04
    117e:	23 30       	cpi	r18, 0x03	; 3
    1180:	31 05       	cpc	r19, r1
    1182:	5c f4       	brge	.+22     	; 0x119a <TIMER1_Init+0x46>
    1184:	8b 81       	ldd	r24, Y+3	; 0x03
    1186:	9c 81       	ldd	r25, Y+4	; 0x04
    1188:	00 97       	sbiw	r24, 0x00	; 0
    118a:	d1 f0       	breq	.+52     	; 0x11c0 <TIMER1_Init+0x6c>
    118c:	2b 81       	ldd	r18, Y+3	; 0x03
    118e:	3c 81       	ldd	r19, Y+4	; 0x04
    1190:	21 30       	cpi	r18, 0x01	; 1
    1192:	31 05       	cpc	r19, r1
    1194:	09 f4       	brne	.+2      	; 0x1198 <TIMER1_Init+0x44>
    1196:	a5 c0       	rjmp	.+330    	; 0x12e2 <TIMER1_Init+0x18e>
    1198:	c0 c0       	rjmp	.+384    	; 0x131a <TIMER1_Init+0x1c6>
    119a:	8b 81       	ldd	r24, Y+3	; 0x03
    119c:	9c 81       	ldd	r25, Y+4	; 0x04
    119e:	84 30       	cpi	r24, 0x04	; 4
    11a0:	91 05       	cpc	r25, r1
    11a2:	09 f4       	brne	.+2      	; 0x11a6 <TIMER1_Init+0x52>
    11a4:	64 c0       	rjmp	.+200    	; 0x126e <TIMER1_Init+0x11a>
    11a6:	2b 81       	ldd	r18, Y+3	; 0x03
    11a8:	3c 81       	ldd	r19, Y+4	; 0x04
    11aa:	24 30       	cpi	r18, 0x04	; 4
    11ac:	31 05       	cpc	r19, r1
    11ae:	0c f4       	brge	.+2      	; 0x11b2 <TIMER1_Init+0x5e>
    11b0:	41 c0       	rjmp	.+130    	; 0x1234 <TIMER1_Init+0xe0>
    11b2:	8b 81       	ldd	r24, Y+3	; 0x03
    11b4:	9c 81       	ldd	r25, Y+4	; 0x04
    11b6:	85 30       	cpi	r24, 0x05	; 5
    11b8:	91 05       	cpc	r25, r1
    11ba:	09 f4       	brne	.+2      	; 0x11be <TIMER1_Init+0x6a>
    11bc:	75 c0       	rjmp	.+234    	; 0x12a8 <TIMER1_Init+0x154>
    11be:	ad c0       	rjmp	.+346    	; 0x131a <TIMER1_Init+0x1c6>
	{
		case TIMER1_NORMAL_MODE:
		CLR_BIT(TCCR1A,WGM10);
    11c0:	af e4       	ldi	r26, 0x4F	; 79
    11c2:	b0 e0       	ldi	r27, 0x00	; 0
    11c4:	ef e4       	ldi	r30, 0x4F	; 79
    11c6:	f0 e0       	ldi	r31, 0x00	; 0
    11c8:	80 81       	ld	r24, Z
    11ca:	8e 7f       	andi	r24, 0xFE	; 254
    11cc:	8c 93       	st	X, r24
		CLR_BIT(TCCR1A,WGM11);
    11ce:	af e4       	ldi	r26, 0x4F	; 79
    11d0:	b0 e0       	ldi	r27, 0x00	; 0
    11d2:	ef e4       	ldi	r30, 0x4F	; 79
    11d4:	f0 e0       	ldi	r31, 0x00	; 0
    11d6:	80 81       	ld	r24, Z
    11d8:	8d 7f       	andi	r24, 0xFD	; 253
    11da:	8c 93       	st	X, r24
		CLR_BIT(TCCR1B,WGM12);
    11dc:	ae e4       	ldi	r26, 0x4E	; 78
    11de:	b0 e0       	ldi	r27, 0x00	; 0
    11e0:	ee e4       	ldi	r30, 0x4E	; 78
    11e2:	f0 e0       	ldi	r31, 0x00	; 0
    11e4:	80 81       	ld	r24, Z
    11e6:	87 7f       	andi	r24, 0xF7	; 247
    11e8:	8c 93       	st	X, r24
		CLR_BIT(TCCR1B,WGM13);
    11ea:	ae e4       	ldi	r26, 0x4E	; 78
    11ec:	b0 e0       	ldi	r27, 0x00	; 0
    11ee:	ee e4       	ldi	r30, 0x4E	; 78
    11f0:	f0 e0       	ldi	r31, 0x00	; 0
    11f2:	80 81       	ld	r24, Z
    11f4:	8f 7e       	andi	r24, 0xEF	; 239
    11f6:	8c 93       	st	X, r24
    11f8:	90 c0       	rjmp	.+288    	; 0x131a <TIMER1_Init+0x1c6>
		break;
		case TIMER1_CTC_ICR_TOP_MODE:
		CLR_BIT(TCCR1A,WGM10);
    11fa:	af e4       	ldi	r26, 0x4F	; 79
    11fc:	b0 e0       	ldi	r27, 0x00	; 0
    11fe:	ef e4       	ldi	r30, 0x4F	; 79
    1200:	f0 e0       	ldi	r31, 0x00	; 0
    1202:	80 81       	ld	r24, Z
    1204:	8e 7f       	andi	r24, 0xFE	; 254
    1206:	8c 93       	st	X, r24
		CLR_BIT(TCCR1A,WGM11);
    1208:	af e4       	ldi	r26, 0x4F	; 79
    120a:	b0 e0       	ldi	r27, 0x00	; 0
    120c:	ef e4       	ldi	r30, 0x4F	; 79
    120e:	f0 e0       	ldi	r31, 0x00	; 0
    1210:	80 81       	ld	r24, Z
    1212:	8d 7f       	andi	r24, 0xFD	; 253
    1214:	8c 93       	st	X, r24
		SET_BIT(TCCR1B,WGM12);
    1216:	ae e4       	ldi	r26, 0x4E	; 78
    1218:	b0 e0       	ldi	r27, 0x00	; 0
    121a:	ee e4       	ldi	r30, 0x4E	; 78
    121c:	f0 e0       	ldi	r31, 0x00	; 0
    121e:	80 81       	ld	r24, Z
    1220:	88 60       	ori	r24, 0x08	; 8
    1222:	8c 93       	st	X, r24
		SET_BIT(TCCR1B,WGM13);
    1224:	ae e4       	ldi	r26, 0x4E	; 78
    1226:	b0 e0       	ldi	r27, 0x00	; 0
    1228:	ee e4       	ldi	r30, 0x4E	; 78
    122a:	f0 e0       	ldi	r31, 0x00	; 0
    122c:	80 81       	ld	r24, Z
    122e:	80 61       	ori	r24, 0x10	; 16
    1230:	8c 93       	st	X, r24
    1232:	73 c0       	rjmp	.+230    	; 0x131a <TIMER1_Init+0x1c6>
		break;
		case TIMER1_CTC_OCRA_TOP_MODE:
		CLR_BIT(TCCR1A,WGM10);
    1234:	af e4       	ldi	r26, 0x4F	; 79
    1236:	b0 e0       	ldi	r27, 0x00	; 0
    1238:	ef e4       	ldi	r30, 0x4F	; 79
    123a:	f0 e0       	ldi	r31, 0x00	; 0
    123c:	80 81       	ld	r24, Z
    123e:	8e 7f       	andi	r24, 0xFE	; 254
    1240:	8c 93       	st	X, r24
		CLR_BIT(TCCR1A,WGM11);
    1242:	af e4       	ldi	r26, 0x4F	; 79
    1244:	b0 e0       	ldi	r27, 0x00	; 0
    1246:	ef e4       	ldi	r30, 0x4F	; 79
    1248:	f0 e0       	ldi	r31, 0x00	; 0
    124a:	80 81       	ld	r24, Z
    124c:	8d 7f       	andi	r24, 0xFD	; 253
    124e:	8c 93       	st	X, r24
		SET_BIT(TCCR1B,WGM12);
    1250:	ae e4       	ldi	r26, 0x4E	; 78
    1252:	b0 e0       	ldi	r27, 0x00	; 0
    1254:	ee e4       	ldi	r30, 0x4E	; 78
    1256:	f0 e0       	ldi	r31, 0x00	; 0
    1258:	80 81       	ld	r24, Z
    125a:	88 60       	ori	r24, 0x08	; 8
    125c:	8c 93       	st	X, r24
		CLR_BIT(TCCR1B,WGM13);
    125e:	ae e4       	ldi	r26, 0x4E	; 78
    1260:	b0 e0       	ldi	r27, 0x00	; 0
    1262:	ee e4       	ldi	r30, 0x4E	; 78
    1264:	f0 e0       	ldi	r31, 0x00	; 0
    1266:	80 81       	ld	r24, Z
    1268:	8f 7e       	andi	r24, 0xEF	; 239
    126a:	8c 93       	st	X, r24
    126c:	56 c0       	rjmp	.+172    	; 0x131a <TIMER1_Init+0x1c6>
		break;
		case TIMER1_FASTPWM_ICR_TOP_MODE:
		CLR_BIT(TCCR1A,WGM10);
    126e:	af e4       	ldi	r26, 0x4F	; 79
    1270:	b0 e0       	ldi	r27, 0x00	; 0
    1272:	ef e4       	ldi	r30, 0x4F	; 79
    1274:	f0 e0       	ldi	r31, 0x00	; 0
    1276:	80 81       	ld	r24, Z
    1278:	8e 7f       	andi	r24, 0xFE	; 254
    127a:	8c 93       	st	X, r24
		SET_BIT(TCCR1A,WGM11);
    127c:	af e4       	ldi	r26, 0x4F	; 79
    127e:	b0 e0       	ldi	r27, 0x00	; 0
    1280:	ef e4       	ldi	r30, 0x4F	; 79
    1282:	f0 e0       	ldi	r31, 0x00	; 0
    1284:	80 81       	ld	r24, Z
    1286:	82 60       	ori	r24, 0x02	; 2
    1288:	8c 93       	st	X, r24
		SET_BIT(TCCR1B,WGM12);
    128a:	ae e4       	ldi	r26, 0x4E	; 78
    128c:	b0 e0       	ldi	r27, 0x00	; 0
    128e:	ee e4       	ldi	r30, 0x4E	; 78
    1290:	f0 e0       	ldi	r31, 0x00	; 0
    1292:	80 81       	ld	r24, Z
    1294:	88 60       	ori	r24, 0x08	; 8
    1296:	8c 93       	st	X, r24
		SET_BIT(TCCR1B,WGM13);
    1298:	ae e4       	ldi	r26, 0x4E	; 78
    129a:	b0 e0       	ldi	r27, 0x00	; 0
    129c:	ee e4       	ldi	r30, 0x4E	; 78
    129e:	f0 e0       	ldi	r31, 0x00	; 0
    12a0:	80 81       	ld	r24, Z
    12a2:	80 61       	ori	r24, 0x10	; 16
    12a4:	8c 93       	st	X, r24
    12a6:	39 c0       	rjmp	.+114    	; 0x131a <TIMER1_Init+0x1c6>
		break;
		case TIMER1_FASTPWM_OCRA_TOP_MODE:
		SET_BIT(TCCR1A,WGM10);
    12a8:	af e4       	ldi	r26, 0x4F	; 79
    12aa:	b0 e0       	ldi	r27, 0x00	; 0
    12ac:	ef e4       	ldi	r30, 0x4F	; 79
    12ae:	f0 e0       	ldi	r31, 0x00	; 0
    12b0:	80 81       	ld	r24, Z
    12b2:	81 60       	ori	r24, 0x01	; 1
    12b4:	8c 93       	st	X, r24
		SET_BIT(TCCR1A,WGM11);
    12b6:	af e4       	ldi	r26, 0x4F	; 79
    12b8:	b0 e0       	ldi	r27, 0x00	; 0
    12ba:	ef e4       	ldi	r30, 0x4F	; 79
    12bc:	f0 e0       	ldi	r31, 0x00	; 0
    12be:	80 81       	ld	r24, Z
    12c0:	82 60       	ori	r24, 0x02	; 2
    12c2:	8c 93       	st	X, r24
		SET_BIT(TCCR1B,WGM12);
    12c4:	ae e4       	ldi	r26, 0x4E	; 78
    12c6:	b0 e0       	ldi	r27, 0x00	; 0
    12c8:	ee e4       	ldi	r30, 0x4E	; 78
    12ca:	f0 e0       	ldi	r31, 0x00	; 0
    12cc:	80 81       	ld	r24, Z
    12ce:	88 60       	ori	r24, 0x08	; 8
    12d0:	8c 93       	st	X, r24
		SET_BIT(TCCR1B,WGM13);
    12d2:	ae e4       	ldi	r26, 0x4E	; 78
    12d4:	b0 e0       	ldi	r27, 0x00	; 0
    12d6:	ee e4       	ldi	r30, 0x4E	; 78
    12d8:	f0 e0       	ldi	r31, 0x00	; 0
    12da:	80 81       	ld	r24, Z
    12dc:	80 61       	ori	r24, 0x10	; 16
    12de:	8c 93       	st	X, r24
    12e0:	1c c0       	rjmp	.+56     	; 0x131a <TIMER1_Init+0x1c6>
		break;
		case TIMER1_NORMAL_8bit_MODE:
		
		SET_BIT(TCCR1A,WGM10);
    12e2:	af e4       	ldi	r26, 0x4F	; 79
    12e4:	b0 e0       	ldi	r27, 0x00	; 0
    12e6:	ef e4       	ldi	r30, 0x4F	; 79
    12e8:	f0 e0       	ldi	r31, 0x00	; 0
    12ea:	80 81       	ld	r24, Z
    12ec:	81 60       	ori	r24, 0x01	; 1
    12ee:	8c 93       	st	X, r24
		CLR_BIT(TCCR1A,WGM11);
    12f0:	af e4       	ldi	r26, 0x4F	; 79
    12f2:	b0 e0       	ldi	r27, 0x00	; 0
    12f4:	ef e4       	ldi	r30, 0x4F	; 79
    12f6:	f0 e0       	ldi	r31, 0x00	; 0
    12f8:	80 81       	ld	r24, Z
    12fa:	8d 7f       	andi	r24, 0xFD	; 253
    12fc:	8c 93       	st	X, r24
		CLR_BIT(TCCR1B,WGM12);
    12fe:	ae e4       	ldi	r26, 0x4E	; 78
    1300:	b0 e0       	ldi	r27, 0x00	; 0
    1302:	ee e4       	ldi	r30, 0x4E	; 78
    1304:	f0 e0       	ldi	r31, 0x00	; 0
    1306:	80 81       	ld	r24, Z
    1308:	87 7f       	andi	r24, 0xF7	; 247
    130a:	8c 93       	st	X, r24
		CLR_BIT(TCCR1B,WGM13);
    130c:	ae e4       	ldi	r26, 0x4E	; 78
    130e:	b0 e0       	ldi	r27, 0x00	; 0
    1310:	ee e4       	ldi	r30, 0x4E	; 78
    1312:	f0 e0       	ldi	r31, 0x00	; 0
    1314:	80 81       	ld	r24, Z
    1316:	8f 7e       	andi	r24, 0xEF	; 239
    1318:	8c 93       	st	X, r24
		break;
	}
	TCCR1B&=0xF8;//0b11111000
    131a:	ae e4       	ldi	r26, 0x4E	; 78
    131c:	b0 e0       	ldi	r27, 0x00	; 0
    131e:	ee e4       	ldi	r30, 0x4E	; 78
    1320:	f0 e0       	ldi	r31, 0x00	; 0
    1322:	80 81       	ld	r24, Z
    1324:	88 7f       	andi	r24, 0xF8	; 248
    1326:	8c 93       	st	X, r24
	scaler&=0x07;//Filter
    1328:	8a 81       	ldd	r24, Y+2	; 0x02
    132a:	87 70       	andi	r24, 0x07	; 7
    132c:	8a 83       	std	Y+2, r24	; 0x02
	TCCR1B|=scaler;
    132e:	ae e4       	ldi	r26, 0x4E	; 78
    1330:	b0 e0       	ldi	r27, 0x00	; 0
    1332:	ee e4       	ldi	r30, 0x4E	; 78
    1334:	f0 e0       	ldi	r31, 0x00	; 0
    1336:	90 81       	ld	r25, Z
    1338:	8a 81       	ldd	r24, Y+2	; 0x02
    133a:	89 2b       	or	r24, r25
    133c:	8c 93       	st	X, r24
}
    133e:	0f 90       	pop	r0
    1340:	0f 90       	pop	r0
    1342:	0f 90       	pop	r0
    1344:	0f 90       	pop	r0
    1346:	cf 91       	pop	r28
    1348:	df 91       	pop	r29
    134a:	08 95       	ret

0000134c <TIMER1_OC1AMode>:
void TIMER1_OC1AMode (OC1A_Mode_type local_mode)
{
    134c:	df 93       	push	r29
    134e:	cf 93       	push	r28
    1350:	00 d0       	rcall	.+0      	; 0x1352 <TIMER1_OC1AMode+0x6>
    1352:	0f 92       	push	r0
    1354:	cd b7       	in	r28, 0x3d	; 61
    1356:	de b7       	in	r29, 0x3e	; 62
    1358:	89 83       	std	Y+1, r24	; 0x01
	switch(local_mode)
    135a:	89 81       	ldd	r24, Y+1	; 0x01
    135c:	28 2f       	mov	r18, r24
    135e:	30 e0       	ldi	r19, 0x00	; 0
    1360:	3b 83       	std	Y+3, r19	; 0x03
    1362:	2a 83       	std	Y+2, r18	; 0x02
    1364:	8a 81       	ldd	r24, Y+2	; 0x02
    1366:	9b 81       	ldd	r25, Y+3	; 0x03
    1368:	81 30       	cpi	r24, 0x01	; 1
    136a:	91 05       	cpc	r25, r1
    136c:	21 f1       	breq	.+72     	; 0x13b6 <TIMER1_OC1AMode+0x6a>
    136e:	2a 81       	ldd	r18, Y+2	; 0x02
    1370:	3b 81       	ldd	r19, Y+3	; 0x03
    1372:	22 30       	cpi	r18, 0x02	; 2
    1374:	31 05       	cpc	r19, r1
    1376:	2c f4       	brge	.+10     	; 0x1382 <TIMER1_OC1AMode+0x36>
    1378:	8a 81       	ldd	r24, Y+2	; 0x02
    137a:	9b 81       	ldd	r25, Y+3	; 0x03
    137c:	00 97       	sbiw	r24, 0x00	; 0
    137e:	61 f0       	breq	.+24     	; 0x1398 <TIMER1_OC1AMode+0x4c>
    1380:	4c c0       	rjmp	.+152    	; 0x141a <TIMER1_OC1AMode+0xce>
    1382:	2a 81       	ldd	r18, Y+2	; 0x02
    1384:	3b 81       	ldd	r19, Y+3	; 0x03
    1386:	22 30       	cpi	r18, 0x02	; 2
    1388:	31 05       	cpc	r19, r1
    138a:	51 f1       	breq	.+84     	; 0x13e0 <TIMER1_OC1AMode+0x94>
    138c:	8a 81       	ldd	r24, Y+2	; 0x02
    138e:	9b 81       	ldd	r25, Y+3	; 0x03
    1390:	83 30       	cpi	r24, 0x03	; 3
    1392:	91 05       	cpc	r25, r1
    1394:	a1 f1       	breq	.+104    	; 0x13fe <TIMER1_OC1AMode+0xb2>
    1396:	41 c0       	rjmp	.+130    	; 0x141a <TIMER1_OC1AMode+0xce>
	{
		case OCRA_DISCONNECTED:
		CLR_BIT(TCCR1A,COM1A0);
    1398:	af e4       	ldi	r26, 0x4F	; 79
    139a:	b0 e0       	ldi	r27, 0x00	; 0
    139c:	ef e4       	ldi	r30, 0x4F	; 79
    139e:	f0 e0       	ldi	r31, 0x00	; 0
    13a0:	80 81       	ld	r24, Z
    13a2:	8f 7b       	andi	r24, 0xBF	; 191
    13a4:	8c 93       	st	X, r24
		CLR_BIT(TCCR1A,COM1A1);
    13a6:	af e4       	ldi	r26, 0x4F	; 79
    13a8:	b0 e0       	ldi	r27, 0x00	; 0
    13aa:	ef e4       	ldi	r30, 0x4F	; 79
    13ac:	f0 e0       	ldi	r31, 0x00	; 0
    13ae:	80 81       	ld	r24, Z
    13b0:	8f 77       	andi	r24, 0x7F	; 127
    13b2:	8c 93       	st	X, r24
    13b4:	32 c0       	rjmp	.+100    	; 0x141a <TIMER1_OC1AMode+0xce>
		break;
		case OCRA_TOGGLE:
		SET_BIT(TCCR1A,COM1A0);
    13b6:	af e4       	ldi	r26, 0x4F	; 79
    13b8:	b0 e0       	ldi	r27, 0x00	; 0
    13ba:	ef e4       	ldi	r30, 0x4F	; 79
    13bc:	f0 e0       	ldi	r31, 0x00	; 0
    13be:	80 81       	ld	r24, Z
    13c0:	80 64       	ori	r24, 0x40	; 64
    13c2:	8c 93       	st	X, r24
		CLR_BIT(TCCR1A,COM1A1);
    13c4:	af e4       	ldi	r26, 0x4F	; 79
    13c6:	b0 e0       	ldi	r27, 0x00	; 0
    13c8:	ef e4       	ldi	r30, 0x4F	; 79
    13ca:	f0 e0       	ldi	r31, 0x00	; 0
    13cc:	80 81       	ld	r24, Z
    13ce:	8f 77       	andi	r24, 0x7F	; 127
    13d0:	8c 93       	st	X, r24
		OCR1A=250;
    13d2:	ea e4       	ldi	r30, 0x4A	; 74
    13d4:	f0 e0       	ldi	r31, 0x00	; 0
    13d6:	8a ef       	ldi	r24, 0xFA	; 250
    13d8:	90 e0       	ldi	r25, 0x00	; 0
    13da:	91 83       	std	Z+1, r25	; 0x01
    13dc:	80 83       	st	Z, r24
    13de:	1d c0       	rjmp	.+58     	; 0x141a <TIMER1_OC1AMode+0xce>
		break;
		case OCRA_NON_INVERTING:
		CLR_BIT(TCCR1A,COM1A0);
    13e0:	af e4       	ldi	r26, 0x4F	; 79
    13e2:	b0 e0       	ldi	r27, 0x00	; 0
    13e4:	ef e4       	ldi	r30, 0x4F	; 79
    13e6:	f0 e0       	ldi	r31, 0x00	; 0
    13e8:	80 81       	ld	r24, Z
    13ea:	8f 7b       	andi	r24, 0xBF	; 191
    13ec:	8c 93       	st	X, r24
		SET_BIT(TCCR1A,COM1A1);
    13ee:	af e4       	ldi	r26, 0x4F	; 79
    13f0:	b0 e0       	ldi	r27, 0x00	; 0
    13f2:	ef e4       	ldi	r30, 0x4F	; 79
    13f4:	f0 e0       	ldi	r31, 0x00	; 0
    13f6:	80 81       	ld	r24, Z
    13f8:	80 68       	ori	r24, 0x80	; 128
    13fa:	8c 93       	st	X, r24
    13fc:	0e c0       	rjmp	.+28     	; 0x141a <TIMER1_OC1AMode+0xce>
		break;
		case OCRA_INVERTING:
		SET_BIT(TCCR1A,COM1A0);
    13fe:	af e4       	ldi	r26, 0x4F	; 79
    1400:	b0 e0       	ldi	r27, 0x00	; 0
    1402:	ef e4       	ldi	r30, 0x4F	; 79
    1404:	f0 e0       	ldi	r31, 0x00	; 0
    1406:	80 81       	ld	r24, Z
    1408:	80 64       	ori	r24, 0x40	; 64
    140a:	8c 93       	st	X, r24
		SET_BIT(TCCR1A,COM1A1);
    140c:	af e4       	ldi	r26, 0x4F	; 79
    140e:	b0 e0       	ldi	r27, 0x00	; 0
    1410:	ef e4       	ldi	r30, 0x4F	; 79
    1412:	f0 e0       	ldi	r31, 0x00	; 0
    1414:	80 81       	ld	r24, Z
    1416:	80 68       	ori	r24, 0x80	; 128
    1418:	8c 93       	st	X, r24
		break;
	}
}
    141a:	0f 90       	pop	r0
    141c:	0f 90       	pop	r0
    141e:	0f 90       	pop	r0
    1420:	cf 91       	pop	r28
    1422:	df 91       	pop	r29
    1424:	08 95       	ret

00001426 <TIMER1_OC1BMode>:
void TIMER1_OC1BMode (OC1B_Mode_type local_mode)
{
    1426:	df 93       	push	r29
    1428:	cf 93       	push	r28
    142a:	00 d0       	rcall	.+0      	; 0x142c <TIMER1_OC1BMode+0x6>
    142c:	0f 92       	push	r0
    142e:	cd b7       	in	r28, 0x3d	; 61
    1430:	de b7       	in	r29, 0x3e	; 62
    1432:	89 83       	std	Y+1, r24	; 0x01
	switch(local_mode)
    1434:	89 81       	ldd	r24, Y+1	; 0x01
    1436:	28 2f       	mov	r18, r24
    1438:	30 e0       	ldi	r19, 0x00	; 0
    143a:	3b 83       	std	Y+3, r19	; 0x03
    143c:	2a 83       	std	Y+2, r18	; 0x02
    143e:	8a 81       	ldd	r24, Y+2	; 0x02
    1440:	9b 81       	ldd	r25, Y+3	; 0x03
    1442:	81 30       	cpi	r24, 0x01	; 1
    1444:	91 05       	cpc	r25, r1
    1446:	21 f1       	breq	.+72     	; 0x1490 <TIMER1_OC1BMode+0x6a>
    1448:	2a 81       	ldd	r18, Y+2	; 0x02
    144a:	3b 81       	ldd	r19, Y+3	; 0x03
    144c:	22 30       	cpi	r18, 0x02	; 2
    144e:	31 05       	cpc	r19, r1
    1450:	2c f4       	brge	.+10     	; 0x145c <TIMER1_OC1BMode+0x36>
    1452:	8a 81       	ldd	r24, Y+2	; 0x02
    1454:	9b 81       	ldd	r25, Y+3	; 0x03
    1456:	00 97       	sbiw	r24, 0x00	; 0
    1458:	61 f0       	breq	.+24     	; 0x1472 <TIMER1_OC1BMode+0x4c>
    145a:	46 c0       	rjmp	.+140    	; 0x14e8 <TIMER1_OC1BMode+0xc2>
    145c:	2a 81       	ldd	r18, Y+2	; 0x02
    145e:	3b 81       	ldd	r19, Y+3	; 0x03
    1460:	22 30       	cpi	r18, 0x02	; 2
    1462:	31 05       	cpc	r19, r1
    1464:	21 f1       	breq	.+72     	; 0x14ae <TIMER1_OC1BMode+0x88>
    1466:	8a 81       	ldd	r24, Y+2	; 0x02
    1468:	9b 81       	ldd	r25, Y+3	; 0x03
    146a:	83 30       	cpi	r24, 0x03	; 3
    146c:	91 05       	cpc	r25, r1
    146e:	71 f1       	breq	.+92     	; 0x14cc <TIMER1_OC1BMode+0xa6>
    1470:	3b c0       	rjmp	.+118    	; 0x14e8 <TIMER1_OC1BMode+0xc2>
	{
		case OCRB_DISCONNECTED:
		CLR_BIT(TCCR1A,COM1B0);
    1472:	af e4       	ldi	r26, 0x4F	; 79
    1474:	b0 e0       	ldi	r27, 0x00	; 0
    1476:	ef e4       	ldi	r30, 0x4F	; 79
    1478:	f0 e0       	ldi	r31, 0x00	; 0
    147a:	80 81       	ld	r24, Z
    147c:	8f 7e       	andi	r24, 0xEF	; 239
    147e:	8c 93       	st	X, r24
		CLR_BIT(TCCR1A,COM1B1);
    1480:	af e4       	ldi	r26, 0x4F	; 79
    1482:	b0 e0       	ldi	r27, 0x00	; 0
    1484:	ef e4       	ldi	r30, 0x4F	; 79
    1486:	f0 e0       	ldi	r31, 0x00	; 0
    1488:	80 81       	ld	r24, Z
    148a:	8f 7d       	andi	r24, 0xDF	; 223
    148c:	8c 93       	st	X, r24
    148e:	2c c0       	rjmp	.+88     	; 0x14e8 <TIMER1_OC1BMode+0xc2>
		break;
		case OCRB_TOGGLE:
		SET_BIT(TCCR1A,COM1B0);
    1490:	af e4       	ldi	r26, 0x4F	; 79
    1492:	b0 e0       	ldi	r27, 0x00	; 0
    1494:	ef e4       	ldi	r30, 0x4F	; 79
    1496:	f0 e0       	ldi	r31, 0x00	; 0
    1498:	80 81       	ld	r24, Z
    149a:	80 61       	ori	r24, 0x10	; 16
    149c:	8c 93       	st	X, r24
		CLR_BIT(TCCR1A,COM1B1);
    149e:	af e4       	ldi	r26, 0x4F	; 79
    14a0:	b0 e0       	ldi	r27, 0x00	; 0
    14a2:	ef e4       	ldi	r30, 0x4F	; 79
    14a4:	f0 e0       	ldi	r31, 0x00	; 0
    14a6:	80 81       	ld	r24, Z
    14a8:	8f 7d       	andi	r24, 0xDF	; 223
    14aa:	8c 93       	st	X, r24
    14ac:	1d c0       	rjmp	.+58     	; 0x14e8 <TIMER1_OC1BMode+0xc2>
		break;
		case OCRB_NON_INVERTING:
		CLR_BIT(TCCR1A,COM1B0);
    14ae:	af e4       	ldi	r26, 0x4F	; 79
    14b0:	b0 e0       	ldi	r27, 0x00	; 0
    14b2:	ef e4       	ldi	r30, 0x4F	; 79
    14b4:	f0 e0       	ldi	r31, 0x00	; 0
    14b6:	80 81       	ld	r24, Z
    14b8:	8f 7e       	andi	r24, 0xEF	; 239
    14ba:	8c 93       	st	X, r24
		SET_BIT(TCCR1A,COM1B1);
    14bc:	af e4       	ldi	r26, 0x4F	; 79
    14be:	b0 e0       	ldi	r27, 0x00	; 0
    14c0:	ef e4       	ldi	r30, 0x4F	; 79
    14c2:	f0 e0       	ldi	r31, 0x00	; 0
    14c4:	80 81       	ld	r24, Z
    14c6:	80 62       	ori	r24, 0x20	; 32
    14c8:	8c 93       	st	X, r24
    14ca:	0e c0       	rjmp	.+28     	; 0x14e8 <TIMER1_OC1BMode+0xc2>
		break;
		case OCRB_INVERTING:
		SET_BIT(TCCR1A,COM1B0);
    14cc:	af e4       	ldi	r26, 0x4F	; 79
    14ce:	b0 e0       	ldi	r27, 0x00	; 0
    14d0:	ef e4       	ldi	r30, 0x4F	; 79
    14d2:	f0 e0       	ldi	r31, 0x00	; 0
    14d4:	80 81       	ld	r24, Z
    14d6:	80 61       	ori	r24, 0x10	; 16
    14d8:	8c 93       	st	X, r24
		SET_BIT(TCCR1A,COM1B1);
    14da:	af e4       	ldi	r26, 0x4F	; 79
    14dc:	b0 e0       	ldi	r27, 0x00	; 0
    14de:	ef e4       	ldi	r30, 0x4F	; 79
    14e0:	f0 e0       	ldi	r31, 0x00	; 0
    14e2:	80 81       	ld	r24, Z
    14e4:	80 62       	ori	r24, 0x20	; 32
    14e6:	8c 93       	st	X, r24
		break;
	}
}
    14e8:	0f 90       	pop	r0
    14ea:	0f 90       	pop	r0
    14ec:	0f 90       	pop	r0
    14ee:	cf 91       	pop	r28
    14f0:	df 91       	pop	r29
    14f2:	08 95       	ret

000014f4 <TIMER1_ICU_Edge>:
void TIMER1_ICU_Edge(ICU_Edge_type local_edge)
{
    14f4:	df 93       	push	r29
    14f6:	cf 93       	push	r28
    14f8:	00 d0       	rcall	.+0      	; 0x14fa <TIMER1_ICU_Edge+0x6>
    14fa:	0f 92       	push	r0
    14fc:	cd b7       	in	r28, 0x3d	; 61
    14fe:	de b7       	in	r29, 0x3e	; 62
    1500:	89 83       	std	Y+1, r24	; 0x01
	switch(local_edge)
    1502:	89 81       	ldd	r24, Y+1	; 0x01
    1504:	28 2f       	mov	r18, r24
    1506:	30 e0       	ldi	r19, 0x00	; 0
    1508:	3b 83       	std	Y+3, r19	; 0x03
    150a:	2a 83       	std	Y+2, r18	; 0x02
    150c:	8a 81       	ldd	r24, Y+2	; 0x02
    150e:	9b 81       	ldd	r25, Y+3	; 0x03
    1510:	00 97       	sbiw	r24, 0x00	; 0
    1512:	31 f0       	breq	.+12     	; 0x1520 <TIMER1_ICU_Edge+0x2c>
    1514:	2a 81       	ldd	r18, Y+2	; 0x02
    1516:	3b 81       	ldd	r19, Y+3	; 0x03
    1518:	21 30       	cpi	r18, 0x01	; 1
    151a:	31 05       	cpc	r19, r1
    151c:	49 f0       	breq	.+18     	; 0x1530 <TIMER1_ICU_Edge+0x3c>
    151e:	0f c0       	rjmp	.+30     	; 0x153e <TIMER1_ICU_Edge+0x4a>
	{
		case RISING:
		SET_BIT	(TCCR1B,ICES1);
    1520:	ae e4       	ldi	r26, 0x4E	; 78
    1522:	b0 e0       	ldi	r27, 0x00	; 0
    1524:	ee e4       	ldi	r30, 0x4E	; 78
    1526:	f0 e0       	ldi	r31, 0x00	; 0
    1528:	80 81       	ld	r24, Z
    152a:	80 64       	ori	r24, 0x40	; 64
    152c:	8c 93       	st	X, r24
    152e:	07 c0       	rjmp	.+14     	; 0x153e <TIMER1_ICU_Edge+0x4a>
		break;
		case FALLING:
		CLR_BIT(TCCR1B,ICES1);
    1530:	ae e4       	ldi	r26, 0x4E	; 78
    1532:	b0 e0       	ldi	r27, 0x00	; 0
    1534:	ee e4       	ldi	r30, 0x4E	; 78
    1536:	f0 e0       	ldi	r31, 0x00	; 0
    1538:	80 81       	ld	r24, Z
    153a:	8f 7b       	andi	r24, 0xBF	; 191
    153c:	8c 93       	st	X, r24
		break;
	}
}
    153e:	0f 90       	pop	r0
    1540:	0f 90       	pop	r0
    1542:	0f 90       	pop	r0
    1544:	cf 91       	pop	r28
    1546:	df 91       	pop	r29
    1548:	08 95       	ret

0000154a <TIMER1_OVF_Enable>:

void TIMER1_OVF_Enable (void)
{
    154a:	df 93       	push	r29
    154c:	cf 93       	push	r28
    154e:	cd b7       	in	r28, 0x3d	; 61
    1550:	de b7       	in	r29, 0x3e	; 62
	SET_BIT	(TIMSK,TOIE1);
    1552:	a7 e5       	ldi	r26, 0x57	; 87
    1554:	b0 e0       	ldi	r27, 0x00	; 0
    1556:	e7 e5       	ldi	r30, 0x57	; 87
    1558:	f0 e0       	ldi	r31, 0x00	; 0
    155a:	80 81       	ld	r24, Z
    155c:	84 60       	ori	r24, 0x04	; 4
    155e:	8c 93       	st	X, r24
}
    1560:	cf 91       	pop	r28
    1562:	df 91       	pop	r29
    1564:	08 95       	ret

00001566 <TIMER1_OVF_Disable>:
void TIMER1_OVF_Disable (void)
{
    1566:	df 93       	push	r29
    1568:	cf 93       	push	r28
    156a:	cd b7       	in	r28, 0x3d	; 61
    156c:	de b7       	in	r29, 0x3e	; 62
	CLR_BIT(TIMSK,TOIE1);
    156e:	a7 e5       	ldi	r26, 0x57	; 87
    1570:	b0 e0       	ldi	r27, 0x00	; 0
    1572:	e7 e5       	ldi	r30, 0x57	; 87
    1574:	f0 e0       	ldi	r31, 0x00	; 0
    1576:	80 81       	ld	r24, Z
    1578:	8b 7f       	andi	r24, 0xFB	; 251
    157a:	8c 93       	st	X, r24
}
    157c:	cf 91       	pop	r28
    157e:	df 91       	pop	r29
    1580:	08 95       	ret

00001582 <TIMER1_OC1A_Enable>:

void TIMER1_OC1A_Enable (void)
{
    1582:	df 93       	push	r29
    1584:	cf 93       	push	r28
    1586:	cd b7       	in	r28, 0x3d	; 61
    1588:	de b7       	in	r29, 0x3e	; 62
	SET_BIT	(TIMSK,OCIE1A);
    158a:	a7 e5       	ldi	r26, 0x57	; 87
    158c:	b0 e0       	ldi	r27, 0x00	; 0
    158e:	e7 e5       	ldi	r30, 0x57	; 87
    1590:	f0 e0       	ldi	r31, 0x00	; 0
    1592:	80 81       	ld	r24, Z
    1594:	80 61       	ori	r24, 0x10	; 16
    1596:	8c 93       	st	X, r24
}
    1598:	cf 91       	pop	r28
    159a:	df 91       	pop	r29
    159c:	08 95       	ret

0000159e <TIMER1_OC1A_Disable>:
void TIMER1_OC1A_Disable (void)
{
    159e:	df 93       	push	r29
    15a0:	cf 93       	push	r28
    15a2:	cd b7       	in	r28, 0x3d	; 61
    15a4:	de b7       	in	r29, 0x3e	; 62
	CLR_BIT(TIMSK,OCIE1A);
    15a6:	a7 e5       	ldi	r26, 0x57	; 87
    15a8:	b0 e0       	ldi	r27, 0x00	; 0
    15aa:	e7 e5       	ldi	r30, 0x57	; 87
    15ac:	f0 e0       	ldi	r31, 0x00	; 0
    15ae:	80 81       	ld	r24, Z
    15b0:	8f 7e       	andi	r24, 0xEF	; 239
    15b2:	8c 93       	st	X, r24
}
    15b4:	cf 91       	pop	r28
    15b6:	df 91       	pop	r29
    15b8:	08 95       	ret

000015ba <TIMER1_OC1B_Enable>:
void TIMER1_OC1B_Enable (void)
{
    15ba:	df 93       	push	r29
    15bc:	cf 93       	push	r28
    15be:	cd b7       	in	r28, 0x3d	; 61
    15c0:	de b7       	in	r29, 0x3e	; 62
	SET_BIT	(TIMSK,OCIE1B);
    15c2:	a7 e5       	ldi	r26, 0x57	; 87
    15c4:	b0 e0       	ldi	r27, 0x00	; 0
    15c6:	e7 e5       	ldi	r30, 0x57	; 87
    15c8:	f0 e0       	ldi	r31, 0x00	; 0
    15ca:	80 81       	ld	r24, Z
    15cc:	88 60       	ori	r24, 0x08	; 8
    15ce:	8c 93       	st	X, r24
}
    15d0:	cf 91       	pop	r28
    15d2:	df 91       	pop	r29
    15d4:	08 95       	ret

000015d6 <TIMER1_OC1B_Disable>:
void TIMER1_OC1B_Disable (void)
{
    15d6:	df 93       	push	r29
    15d8:	cf 93       	push	r28
    15da:	cd b7       	in	r28, 0x3d	; 61
    15dc:	de b7       	in	r29, 0x3e	; 62
	CLR_BIT(TIMSK,OCIE1B);
    15de:	a7 e5       	ldi	r26, 0x57	; 87
    15e0:	b0 e0       	ldi	r27, 0x00	; 0
    15e2:	e7 e5       	ldi	r30, 0x57	; 87
    15e4:	f0 e0       	ldi	r31, 0x00	; 0
    15e6:	80 81       	ld	r24, Z
    15e8:	87 7f       	andi	r24, 0xF7	; 247
    15ea:	8c 93       	st	X, r24
}
    15ec:	cf 91       	pop	r28
    15ee:	df 91       	pop	r29
    15f0:	08 95       	ret

000015f2 <TIMER1_ICU_Enable>:

void TIMER1_ICU_Enable (void)
{
    15f2:	df 93       	push	r29
    15f4:	cf 93       	push	r28
    15f6:	cd b7       	in	r28, 0x3d	; 61
    15f8:	de b7       	in	r29, 0x3e	; 62
	SET_BIT	(TIMSK,TICIE1);
    15fa:	a7 e5       	ldi	r26, 0x57	; 87
    15fc:	b0 e0       	ldi	r27, 0x00	; 0
    15fe:	e7 e5       	ldi	r30, 0x57	; 87
    1600:	f0 e0       	ldi	r31, 0x00	; 0
    1602:	80 81       	ld	r24, Z
    1604:	80 62       	ori	r24, 0x20	; 32
    1606:	8c 93       	st	X, r24
}
    1608:	cf 91       	pop	r28
    160a:	df 91       	pop	r29
    160c:	08 95       	ret

0000160e <TIMER1_ICU_Disable>:
void TIMER1_ICU_Disable (void)
{
    160e:	df 93       	push	r29
    1610:	cf 93       	push	r28
    1612:	cd b7       	in	r28, 0x3d	; 61
    1614:	de b7       	in	r29, 0x3e	; 62
	CLR_BIT(TIMSK,TICIE1);
    1616:	a7 e5       	ldi	r26, 0x57	; 87
    1618:	b0 e0       	ldi	r27, 0x00	; 0
    161a:	e7 e5       	ldi	r30, 0x57	; 87
    161c:	f0 e0       	ldi	r31, 0x00	; 0
    161e:	80 81       	ld	r24, Z
    1620:	8f 7d       	andi	r24, 0xDF	; 223
    1622:	8c 93       	st	X, r24
}
    1624:	cf 91       	pop	r28
    1626:	df 91       	pop	r29
    1628:	08 95       	ret

0000162a <TIMER1_OVF_SetCallBack>:

void TIMER1_OVF_SetCallBack (void(*local_fptr)(void))
{
    162a:	df 93       	push	r29
    162c:	cf 93       	push	r28
    162e:	00 d0       	rcall	.+0      	; 0x1630 <TIMER1_OVF_SetCallBack+0x6>
    1630:	cd b7       	in	r28, 0x3d	; 61
    1632:	de b7       	in	r29, 0x3e	; 62
    1634:	9a 83       	std	Y+2, r25	; 0x02
    1636:	89 83       	std	Y+1, r24	; 0x01
	local_fptr=Timer1_OVF_Fptr;
    1638:	80 91 9d 02 	lds	r24, 0x029D
    163c:	90 91 9e 02 	lds	r25, 0x029E
    1640:	9a 83       	std	Y+2, r25	; 0x02
    1642:	89 83       	std	Y+1, r24	; 0x01
}
    1644:	0f 90       	pop	r0
    1646:	0f 90       	pop	r0
    1648:	cf 91       	pop	r28
    164a:	df 91       	pop	r29
    164c:	08 95       	ret

0000164e <TIMER1_OC1A_SetCallBack>:
void TIMER1_OC1A_SetCallBack (void(*local_fptr)(void))
{
    164e:	df 93       	push	r29
    1650:	cf 93       	push	r28
    1652:	00 d0       	rcall	.+0      	; 0x1654 <TIMER1_OC1A_SetCallBack+0x6>
    1654:	cd b7       	in	r28, 0x3d	; 61
    1656:	de b7       	in	r29, 0x3e	; 62
    1658:	9a 83       	std	Y+2, r25	; 0x02
    165a:	89 83       	std	Y+1, r24	; 0x01
	Timer1_OCA_Fptr=local_fptr;
    165c:	89 81       	ldd	r24, Y+1	; 0x01
    165e:	9a 81       	ldd	r25, Y+2	; 0x02
    1660:	90 93 a0 02 	sts	0x02A0, r25
    1664:	80 93 9f 02 	sts	0x029F, r24
}
    1668:	0f 90       	pop	r0
    166a:	0f 90       	pop	r0
    166c:	cf 91       	pop	r28
    166e:	df 91       	pop	r29
    1670:	08 95       	ret

00001672 <TIMER1_OC1B_SetCallBack>:
void TIMER1_OC1B_SetCallBack (void(*local_fptr)(void))
{
    1672:	df 93       	push	r29
    1674:	cf 93       	push	r28
    1676:	00 d0       	rcall	.+0      	; 0x1678 <TIMER1_OC1B_SetCallBack+0x6>
    1678:	cd b7       	in	r28, 0x3d	; 61
    167a:	de b7       	in	r29, 0x3e	; 62
    167c:	9a 83       	std	Y+2, r25	; 0x02
    167e:	89 83       	std	Y+1, r24	; 0x01
	local_fptr=Timer1_OCB_Fptr;
    1680:	80 91 a1 02 	lds	r24, 0x02A1
    1684:	90 91 a2 02 	lds	r25, 0x02A2
    1688:	9a 83       	std	Y+2, r25	; 0x02
    168a:	89 83       	std	Y+1, r24	; 0x01
}
    168c:	0f 90       	pop	r0
    168e:	0f 90       	pop	r0
    1690:	cf 91       	pop	r28
    1692:	df 91       	pop	r29
    1694:	08 95       	ret

00001696 <TIMER1_ICU_SetCallBack>:
void TIMER1_ICU_SetCallBack (void(*local_fptr)(void))
{
    1696:	df 93       	push	r29
    1698:	cf 93       	push	r28
    169a:	00 d0       	rcall	.+0      	; 0x169c <TIMER1_ICU_SetCallBack+0x6>
    169c:	cd b7       	in	r28, 0x3d	; 61
    169e:	de b7       	in	r29, 0x3e	; 62
    16a0:	9a 83       	std	Y+2, r25	; 0x02
    16a2:	89 83       	std	Y+1, r24	; 0x01
	local_fptr=Timer1_ICU_Fptr;
    16a4:	80 91 a3 02 	lds	r24, 0x02A3
    16a8:	90 91 a4 02 	lds	r25, 0x02A4
    16ac:	9a 83       	std	Y+2, r25	; 0x02
    16ae:	89 83       	std	Y+1, r24	; 0x01
}
    16b0:	0f 90       	pop	r0
    16b2:	0f 90       	pop	r0
    16b4:	cf 91       	pop	r28
    16b6:	df 91       	pop	r29
    16b8:	08 95       	ret

000016ba <__vector_14>:
ISR(TIMER1_OVF_vect)
{
    16ba:	1f 92       	push	r1
    16bc:	0f 92       	push	r0
    16be:	0f b6       	in	r0, 0x3f	; 63
    16c0:	0f 92       	push	r0
    16c2:	00 90 5b 00 	lds	r0, 0x005B
    16c6:	0f 92       	push	r0
    16c8:	11 24       	eor	r1, r1
    16ca:	2f 93       	push	r18
    16cc:	3f 93       	push	r19
    16ce:	4f 93       	push	r20
    16d0:	5f 93       	push	r21
    16d2:	6f 93       	push	r22
    16d4:	7f 93       	push	r23
    16d6:	8f 93       	push	r24
    16d8:	9f 93       	push	r25
    16da:	af 93       	push	r26
    16dc:	bf 93       	push	r27
    16de:	ef 93       	push	r30
    16e0:	ff 93       	push	r31
    16e2:	df 93       	push	r29
    16e4:	cf 93       	push	r28
    16e6:	cd b7       	in	r28, 0x3d	; 61
    16e8:	de b7       	in	r29, 0x3e	; 62
	
	if (Timer1_OVF_Fptr!=NULLPTR)
    16ea:	80 91 9d 02 	lds	r24, 0x029D
    16ee:	90 91 9e 02 	lds	r25, 0x029E
    16f2:	00 97       	sbiw	r24, 0x00	; 0
    16f4:	29 f0       	breq	.+10     	; 0x1700 <__vector_14+0x46>
	{
		
		Timer1_OVF_Fptr();
    16f6:	e0 91 9d 02 	lds	r30, 0x029D
    16fa:	f0 91 9e 02 	lds	r31, 0x029E
    16fe:	09 95       	icall
	}
}
    1700:	cf 91       	pop	r28
    1702:	df 91       	pop	r29
    1704:	ff 91       	pop	r31
    1706:	ef 91       	pop	r30
    1708:	bf 91       	pop	r27
    170a:	af 91       	pop	r26
    170c:	9f 91       	pop	r25
    170e:	8f 91       	pop	r24
    1710:	7f 91       	pop	r23
    1712:	6f 91       	pop	r22
    1714:	5f 91       	pop	r21
    1716:	4f 91       	pop	r20
    1718:	3f 91       	pop	r19
    171a:	2f 91       	pop	r18
    171c:	0f 90       	pop	r0
    171e:	00 92 5b 00 	sts	0x005B, r0
    1722:	0f 90       	pop	r0
    1724:	0f be       	out	0x3f, r0	; 63
    1726:	0f 90       	pop	r0
    1728:	1f 90       	pop	r1
    172a:	18 95       	reti

0000172c <__vector_13>:
ISR(TIMER1_OCB_vect)
{
    172c:	1f 92       	push	r1
    172e:	0f 92       	push	r0
    1730:	0f b6       	in	r0, 0x3f	; 63
    1732:	0f 92       	push	r0
    1734:	00 90 5b 00 	lds	r0, 0x005B
    1738:	0f 92       	push	r0
    173a:	11 24       	eor	r1, r1
    173c:	2f 93       	push	r18
    173e:	3f 93       	push	r19
    1740:	4f 93       	push	r20
    1742:	5f 93       	push	r21
    1744:	6f 93       	push	r22
    1746:	7f 93       	push	r23
    1748:	8f 93       	push	r24
    174a:	9f 93       	push	r25
    174c:	af 93       	push	r26
    174e:	bf 93       	push	r27
    1750:	ef 93       	push	r30
    1752:	ff 93       	push	r31
    1754:	df 93       	push	r29
    1756:	cf 93       	push	r28
    1758:	cd b7       	in	r28, 0x3d	; 61
    175a:	de b7       	in	r29, 0x3e	; 62
	if (Timer1_OCB_Fptr!=NULLPTR)
    175c:	80 91 a1 02 	lds	r24, 0x02A1
    1760:	90 91 a2 02 	lds	r25, 0x02A2
    1764:	00 97       	sbiw	r24, 0x00	; 0
    1766:	29 f0       	breq	.+10     	; 0x1772 <__vector_13+0x46>
	{
		Timer1_OCB_Fptr();
    1768:	e0 91 a1 02 	lds	r30, 0x02A1
    176c:	f0 91 a2 02 	lds	r31, 0x02A2
    1770:	09 95       	icall
	}
}
    1772:	cf 91       	pop	r28
    1774:	df 91       	pop	r29
    1776:	ff 91       	pop	r31
    1778:	ef 91       	pop	r30
    177a:	bf 91       	pop	r27
    177c:	af 91       	pop	r26
    177e:	9f 91       	pop	r25
    1780:	8f 91       	pop	r24
    1782:	7f 91       	pop	r23
    1784:	6f 91       	pop	r22
    1786:	5f 91       	pop	r21
    1788:	4f 91       	pop	r20
    178a:	3f 91       	pop	r19
    178c:	2f 91       	pop	r18
    178e:	0f 90       	pop	r0
    1790:	00 92 5b 00 	sts	0x005B, r0
    1794:	0f 90       	pop	r0
    1796:	0f be       	out	0x3f, r0	; 63
    1798:	0f 90       	pop	r0
    179a:	1f 90       	pop	r1
    179c:	18 95       	reti

0000179e <__vector_12>:
ISR(TIMER1_OCA_vect)
{
    179e:	1f 92       	push	r1
    17a0:	0f 92       	push	r0
    17a2:	0f b6       	in	r0, 0x3f	; 63
    17a4:	0f 92       	push	r0
    17a6:	00 90 5b 00 	lds	r0, 0x005B
    17aa:	0f 92       	push	r0
    17ac:	11 24       	eor	r1, r1
    17ae:	2f 93       	push	r18
    17b0:	3f 93       	push	r19
    17b2:	4f 93       	push	r20
    17b4:	5f 93       	push	r21
    17b6:	6f 93       	push	r22
    17b8:	7f 93       	push	r23
    17ba:	8f 93       	push	r24
    17bc:	9f 93       	push	r25
    17be:	af 93       	push	r26
    17c0:	bf 93       	push	r27
    17c2:	ef 93       	push	r30
    17c4:	ff 93       	push	r31
    17c6:	df 93       	push	r29
    17c8:	cf 93       	push	r28
    17ca:	cd b7       	in	r28, 0x3d	; 61
    17cc:	de b7       	in	r29, 0x3e	; 62
	if (Timer1_OCA_Fptr!=NULLPTR)
    17ce:	80 91 9f 02 	lds	r24, 0x029F
    17d2:	90 91 a0 02 	lds	r25, 0x02A0
    17d6:	00 97       	sbiw	r24, 0x00	; 0
    17d8:	29 f0       	breq	.+10     	; 0x17e4 <__vector_12+0x46>
	{
		Timer1_OCA_Fptr();
    17da:	e0 91 9f 02 	lds	r30, 0x029F
    17de:	f0 91 a0 02 	lds	r31, 0x02A0
    17e2:	09 95       	icall
	}
}
    17e4:	cf 91       	pop	r28
    17e6:	df 91       	pop	r29
    17e8:	ff 91       	pop	r31
    17ea:	ef 91       	pop	r30
    17ec:	bf 91       	pop	r27
    17ee:	af 91       	pop	r26
    17f0:	9f 91       	pop	r25
    17f2:	8f 91       	pop	r24
    17f4:	7f 91       	pop	r23
    17f6:	6f 91       	pop	r22
    17f8:	5f 91       	pop	r21
    17fa:	4f 91       	pop	r20
    17fc:	3f 91       	pop	r19
    17fe:	2f 91       	pop	r18
    1800:	0f 90       	pop	r0
    1802:	00 92 5b 00 	sts	0x005B, r0
    1806:	0f 90       	pop	r0
    1808:	0f be       	out	0x3f, r0	; 63
    180a:	0f 90       	pop	r0
    180c:	1f 90       	pop	r1
    180e:	18 95       	reti

00001810 <TIMER1_SetStartTime>:

void TIMER1_SetStartTime (u8 TIME)
{
    1810:	df 93       	push	r29
    1812:	cf 93       	push	r28
    1814:	0f 92       	push	r0
    1816:	cd b7       	in	r28, 0x3d	; 61
    1818:	de b7       	in	r29, 0x3e	; 62
    181a:	89 83       	std	Y+1, r24	; 0x01
	TCNT1=TIME;
    181c:	ec e4       	ldi	r30, 0x4C	; 76
    181e:	f0 e0       	ldi	r31, 0x00	; 0
    1820:	89 81       	ldd	r24, Y+1	; 0x01
    1822:	88 2f       	mov	r24, r24
    1824:	90 e0       	ldi	r25, 0x00	; 0
    1826:	91 83       	std	Z+1, r25	; 0x01
    1828:	80 83       	st	Z, r24
}
    182a:	0f 90       	pop	r0
    182c:	cf 91       	pop	r28
    182e:	df 91       	pop	r29
    1830:	08 95       	ret

00001832 <SPI_MasterCan_Init>:
#include "../../MCAL/SPI/SPI_Private.h"
#include "../../MCAL/SPI/SPI_Cfg.h"
static void (*Global_Ptf)(void)=NULLPTR;
static u8 *SPI_GlOBAL_DATA=NULLPTR;
void SPI_MasterCan_Init (void)
{
    1832:	df 93       	push	r29
    1834:	cf 93       	push	r28
    1836:	cd b7       	in	r28, 0x3d	; 61
    1838:	de b7       	in	r29, 0x3e	; 62
	/*ENABLE SPI */
	SPI_REGS->SPCR.BIT.SPE=HIGH;
    183a:	ed e2       	ldi	r30, 0x2D	; 45
    183c:	f0 e0       	ldi	r31, 0x00	; 0
    183e:	80 81       	ld	r24, Z
    1840:	80 64       	ori	r24, 0x40	; 64
    1842:	80 83       	st	Z, r24
	/*CHOICE MSB FIRST */
	SPI_REGS->SPCR.BIT.DORD=LOW;
    1844:	ed e2       	ldi	r30, 0x2D	; 45
    1846:	f0 e0       	ldi	r31, 0x00	; 0
    1848:	80 81       	ld	r24, Z
    184a:	8f 7d       	andi	r24, 0xDF	; 223
    184c:	80 83       	st	Z, r24
	/*MASTER MODE*/
	SPI_REGS->SPCR.BIT.MSTR=HIGH;
    184e:	ed e2       	ldi	r30, 0x2D	; 45
    1850:	f0 e0       	ldi	r31, 0x00	; 0
    1852:	80 81       	ld	r24, Z
    1854:	80 61       	ori	r24, 0x10	; 16
    1856:	80 83       	st	Z, r24
	/* CHOICE CLOCK POLARITY AND CLOCK PHASE*/
	SPI_REGS->SPCR.BIT.CPOL=LOW;  //leading rising
    1858:	ed e2       	ldi	r30, 0x2D	; 45
    185a:	f0 e0       	ldi	r31, 0x00	; 0
    185c:	80 81       	ld	r24, Z
    185e:	87 7f       	andi	r24, 0xF7	; 247
    1860:	80 83       	st	Z, r24
	SPI_REGS->SPCR.BIT.CPHA=LOW; //sampling rising
    1862:	ed e2       	ldi	r30, 0x2D	; 45
    1864:	f0 e0       	ldi	r31, 0x00	; 0
    1866:	80 81       	ld	r24, Z
    1868:	8b 7f       	andi	r24, 0xFB	; 251
    186a:	80 83       	st	Z, r24
	/*CHCOICE CLOCK PRESCALLER FCPU/16 */
	SPI_REGS->SPCR.BIT.SPR0=HIGH;
    186c:	ed e2       	ldi	r30, 0x2D	; 45
    186e:	f0 e0       	ldi	r31, 0x00	; 0
    1870:	80 81       	ld	r24, Z
    1872:	81 60       	ori	r24, 0x01	; 1
    1874:	80 83       	st	Z, r24
	SPI_REGS->SPCR.BIT.SPR1=LOW;
    1876:	ed e2       	ldi	r30, 0x2D	; 45
    1878:	f0 e0       	ldi	r31, 0x00	; 0
    187a:	80 81       	ld	r24, Z
    187c:	8d 7f       	andi	r24, 0xFD	; 253
    187e:	80 83       	st	Z, r24
	SPI_REGS->SPSR.BIT.SPI2X=LOW;
    1880:	ed e2       	ldi	r30, 0x2D	; 45
    1882:	f0 e0       	ldi	r31, 0x00	; 0
    1884:	81 81       	ldd	r24, Z+1	; 0x01
    1886:	8e 7f       	andi	r24, 0xFE	; 254
    1888:	81 83       	std	Z+1, r24	; 0x01
	
	//select pin ss ->>>high
}
    188a:	cf 91       	pop	r28
    188c:	df 91       	pop	r29
    188e:	08 95       	ret

00001890 <SPI_SlaveCan_Init>:
void SPI_SlaveCan_Init (void)
{
    1890:	df 93       	push	r29
    1892:	cf 93       	push	r28
    1894:	cd b7       	in	r28, 0x3d	; 61
    1896:	de b7       	in	r29, 0x3e	; 62
	/*ENABLE SPI */
	SPI_REGS->SPCR.BIT.SPE=HIGH;
    1898:	ed e2       	ldi	r30, 0x2D	; 45
    189a:	f0 e0       	ldi	r31, 0x00	; 0
    189c:	80 81       	ld	r24, Z
    189e:	80 64       	ori	r24, 0x40	; 64
    18a0:	80 83       	st	Z, r24
	/*CHOICE MSB FIRST */
	SPI_REGS->SPCR.BIT.DORD=LOW;
    18a2:	ed e2       	ldi	r30, 0x2D	; 45
    18a4:	f0 e0       	ldi	r31, 0x00	; 0
    18a6:	80 81       	ld	r24, Z
    18a8:	8f 7d       	andi	r24, 0xDF	; 223
    18aa:	80 83       	st	Z, r24
	/*MASTER MODE*/
	SPI_REGS->SPCR.BIT.MSTR=HIGH;
    18ac:	ed e2       	ldi	r30, 0x2D	; 45
    18ae:	f0 e0       	ldi	r31, 0x00	; 0
    18b0:	80 81       	ld	r24, Z
    18b2:	80 61       	ori	r24, 0x10	; 16
    18b4:	80 83       	st	Z, r24
	/* CHOICE CLOCK POLARITY AND CLOCK PHASE*/
	SPI_REGS->SPCR.BIT.CPOL=LOW;  //leading rising
    18b6:	ed e2       	ldi	r30, 0x2D	; 45
    18b8:	f0 e0       	ldi	r31, 0x00	; 0
    18ba:	80 81       	ld	r24, Z
    18bc:	87 7f       	andi	r24, 0xF7	; 247
    18be:	80 83       	st	Z, r24
	SPI_REGS->SPCR.BIT.CPHA=LOW; //sampling rising
    18c0:	ed e2       	ldi	r30, 0x2D	; 45
    18c2:	f0 e0       	ldi	r31, 0x00	; 0
    18c4:	80 81       	ld	r24, Z
    18c6:	8b 7f       	andi	r24, 0xFB	; 251
    18c8:	80 83       	st	Z, r24
	/*CHCOICE CLOCK PRESCALLER FCPU/16 */
	SPI_REGS->SPCR.BIT.SPR0=HIGH;
    18ca:	ed e2       	ldi	r30, 0x2D	; 45
    18cc:	f0 e0       	ldi	r31, 0x00	; 0
    18ce:	80 81       	ld	r24, Z
    18d0:	81 60       	ori	r24, 0x01	; 1
    18d2:	80 83       	st	Z, r24
	SPI_REGS->SPCR.BIT.SPR1=LOW;
    18d4:	ed e2       	ldi	r30, 0x2D	; 45
    18d6:	f0 e0       	ldi	r31, 0x00	; 0
    18d8:	80 81       	ld	r24, Z
    18da:	8d 7f       	andi	r24, 0xFD	; 253
    18dc:	80 83       	st	Z, r24
	SPI_REGS->SPSR.BIT.SPI2X=LOW;
    18de:	ed e2       	ldi	r30, 0x2D	; 45
    18e0:	f0 e0       	ldi	r31, 0x00	; 0
    18e2:	81 81       	ldd	r24, Z+1	; 0x01
    18e4:	8e 7f       	andi	r24, 0xFE	; 254
    18e6:	81 83       	std	Z+1, r24	; 0x01
}
    18e8:	cf 91       	pop	r28
    18ea:	df 91       	pop	r29
    18ec:	08 95       	ret

000018ee <SPI_MasterTransmit>:
u8 SPI_MasterTransmit (u8 data)
{
    18ee:	df 93       	push	r29
    18f0:	cf 93       	push	r28
    18f2:	00 d0       	rcall	.+0      	; 0x18f4 <SPI_MasterTransmit+0x6>
    18f4:	cd b7       	in	r28, 0x3d	; 61
    18f6:	de b7       	in	r29, 0x3e	; 62
    18f8:	8a 83       	std	Y+2, r24	; 0x02
	u8 dataRead=0;
    18fa:	19 82       	std	Y+1, r1	; 0x01
	SPI_REGS->SPDR.R=data;
    18fc:	ed e2       	ldi	r30, 0x2D	; 45
    18fe:	f0 e0       	ldi	r31, 0x00	; 0
    1900:	8a 81       	ldd	r24, Y+2	; 0x02
    1902:	82 83       	std	Z+2, r24	; 0x02
	while(SPI_REGS->SPSR.BIT.SPIF==LOW);
    1904:	ed e2       	ldi	r30, 0x2D	; 45
    1906:	f0 e0       	ldi	r31, 0x00	; 0
    1908:	81 81       	ldd	r24, Z+1	; 0x01
    190a:	80 78       	andi	r24, 0x80	; 128
    190c:	88 23       	and	r24, r24
    190e:	d1 f3       	breq	.-12     	; 0x1904 <SPI_MasterTransmit+0x16>
	dataRead=SPI_REGS->SPDR.R;
    1910:	ed e2       	ldi	r30, 0x2D	; 45
    1912:	f0 e0       	ldi	r31, 0x00	; 0
    1914:	82 81       	ldd	r24, Z+2	; 0x02
    1916:	89 83       	std	Y+1, r24	; 0x01
	return dataRead;
    1918:	89 81       	ldd	r24, Y+1	; 0x01
}
    191a:	0f 90       	pop	r0
    191c:	0f 90       	pop	r0
    191e:	cf 91       	pop	r28
    1920:	df 91       	pop	r29
    1922:	08 95       	ret

00001924 <SPI_Init>:
/*spi */
void SPI_Init(void)
{
    1924:	df 93       	push	r29
    1926:	cf 93       	push	r28
    1928:	cd b7       	in	r28, 0x3d	; 61
    192a:	de b7       	in	r29, 0x3e	; 62
	#if SPI_MODE == SPI_MASTER
	/*MASTER MODE*/
	SPI_REGS->SPCR.BIT.MSTR=HIGH;
    192c:	ed e2       	ldi	r30, 0x2D	; 45
    192e:	f0 e0       	ldi	r31, 0x00	; 0
    1930:	80 81       	ld	r24, Z
    1932:	80 61       	ori	r24, 0x10	; 16
    1934:	80 83       	st	Z, r24
	/*CHCOICE CLOCK PRESCALLER FCPU/16 */
	SPI_REGS->SPCR.BIT.SPR0=HIGH;
    1936:	ed e2       	ldi	r30, 0x2D	; 45
    1938:	f0 e0       	ldi	r31, 0x00	; 0
    193a:	80 81       	ld	r24, Z
    193c:	81 60       	ori	r24, 0x01	; 1
    193e:	80 83       	st	Z, r24
	SPI_REGS->SPCR.BIT.SPR1=LOW;
    1940:	ed e2       	ldi	r30, 0x2D	; 45
    1942:	f0 e0       	ldi	r31, 0x00	; 0
    1944:	80 81       	ld	r24, Z
    1946:	8d 7f       	andi	r24, 0xFD	; 253
    1948:	80 83       	st	Z, r24
	SPI_REGS->SPSR.BIT.SPI2X=LOW;
    194a:	ed e2       	ldi	r30, 0x2D	; 45
    194c:	f0 e0       	ldi	r31, 0x00	; 0
    194e:	81 81       	ldd	r24, Z+1	; 0x01
    1950:	8e 7f       	andi	r24, 0xFE	; 254
    1952:	81 83       	std	Z+1, r24	; 0x01
	#elif SPI_MODE == SPI_SLAVE
	/*SALVE MODE*/
	SPI_REGS->SPCR.BIT.MSTR=LOW;
	#endif
	/* CHOICE CLOCK POLARITY AND CLOCK PHASE*/
	SPI_REGS->SPCR.BIT.CPOL=HIGH;
    1954:	ed e2       	ldi	r30, 0x2D	; 45
    1956:	f0 e0       	ldi	r31, 0x00	; 0
    1958:	80 81       	ld	r24, Z
    195a:	88 60       	ori	r24, 0x08	; 8
    195c:	80 83       	st	Z, r24
	SPI_REGS->SPCR.BIT.CPHA=HIGH;
    195e:	ed e2       	ldi	r30, 0x2D	; 45
    1960:	f0 e0       	ldi	r31, 0x00	; 0
    1962:	80 81       	ld	r24, Z
    1964:	84 60       	ori	r24, 0x04	; 4
    1966:	80 83       	st	Z, r24
	/*CHOICE LSB FIRST */
	SPI_REGS->SPCR.BIT.DORD=HIGH;
    1968:	ed e2       	ldi	r30, 0x2D	; 45
    196a:	f0 e0       	ldi	r31, 0x00	; 0
    196c:	80 81       	ld	r24, Z
    196e:	80 62       	ori	r24, 0x20	; 32
    1970:	80 83       	st	Z, r24
	/*ENABLE SPI */
	SPI_REGS->SPCR.BIT.SPE=HIGH;
    1972:	ed e2       	ldi	r30, 0x2D	; 45
    1974:	f0 e0       	ldi	r31, 0x00	; 0
    1976:	80 81       	ld	r24, Z
    1978:	80 64       	ori	r24, 0x40	; 64
    197a:	80 83       	st	Z, r24
}
    197c:	cf 91       	pop	r28
    197e:	df 91       	pop	r29
    1980:	08 95       	ret

00001982 <SPI_voidTransmateASYNC>:

void SPI_voidTransmateASYNC(void (*SPI_Ptf)(void),u8 data,u8 *rx_data)
{
    1982:	df 93       	push	r29
    1984:	cf 93       	push	r28
    1986:	00 d0       	rcall	.+0      	; 0x1988 <SPI_voidTransmateASYNC+0x6>
    1988:	00 d0       	rcall	.+0      	; 0x198a <SPI_voidTransmateASYNC+0x8>
    198a:	0f 92       	push	r0
    198c:	cd b7       	in	r28, 0x3d	; 61
    198e:	de b7       	in	r29, 0x3e	; 62
    1990:	9a 83       	std	Y+2, r25	; 0x02
    1992:	89 83       	std	Y+1, r24	; 0x01
    1994:	6b 83       	std	Y+3, r22	; 0x03
    1996:	5d 83       	std	Y+5, r21	; 0x05
    1998:	4c 83       	std	Y+4, r20	; 0x04
	SPI_REGS->SPCR.BIT.SPIE=HIGH;
    199a:	ed e2       	ldi	r30, 0x2D	; 45
    199c:	f0 e0       	ldi	r31, 0x00	; 0
    199e:	80 81       	ld	r24, Z
    19a0:	80 68       	ori	r24, 0x80	; 128
    19a2:	80 83       	st	Z, r24
	/*CHEIK NULL*/
	Global_Ptf=SPI_Ptf;
    19a4:	89 81       	ldd	r24, Y+1	; 0x01
    19a6:	9a 81       	ldd	r25, Y+2	; 0x02
    19a8:	90 93 a8 02 	sts	0x02A8, r25
    19ac:	80 93 a7 02 	sts	0x02A7, r24
	SPI_GlOBAL_DATA=rx_data;
    19b0:	8c 81       	ldd	r24, Y+4	; 0x04
    19b2:	9d 81       	ldd	r25, Y+5	; 0x05
    19b4:	90 93 aa 02 	sts	0x02AA, r25
    19b8:	80 93 a9 02 	sts	0x02A9, r24
	SPI_REGS->SPDR.R=data;
    19bc:	ed e2       	ldi	r30, 0x2D	; 45
    19be:	f0 e0       	ldi	r31, 0x00	; 0
    19c0:	8b 81       	ldd	r24, Y+3	; 0x03
    19c2:	82 83       	std	Z+2, r24	; 0x02
}
    19c4:	0f 90       	pop	r0
    19c6:	0f 90       	pop	r0
    19c8:	0f 90       	pop	r0
    19ca:	0f 90       	pop	r0
    19cc:	0f 90       	pop	r0
    19ce:	cf 91       	pop	r28
    19d0:	df 91       	pop	r29
    19d2:	08 95       	ret

000019d4 <SPI_Transieve>:

u8 SPI_Transieve(u8 Copy_u8_dat)
{
    19d4:	df 93       	push	r29
    19d6:	cf 93       	push	r28
    19d8:	0f 92       	push	r0
    19da:	cd b7       	in	r28, 0x3d	; 61
    19dc:	de b7       	in	r29, 0x3e	; 62
    19de:	89 83       	std	Y+1, r24	; 0x01
	//ss-->0
	while(SPI_REGS->SPSR.BIT.WCOL==HIGH);
    19e0:	ed e2       	ldi	r30, 0x2D	; 45
    19e2:	f0 e0       	ldi	r31, 0x00	; 0
    19e4:	81 81       	ldd	r24, Z+1	; 0x01
    19e6:	80 74       	andi	r24, 0x40	; 64
    19e8:	88 23       	and	r24, r24
    19ea:	d1 f7       	brne	.-12     	; 0x19e0 <SPI_Transieve+0xc>
	SPI_REGS->SPDR.R=Copy_u8_dat;
    19ec:	ed e2       	ldi	r30, 0x2D	; 45
    19ee:	f0 e0       	ldi	r31, 0x00	; 0
    19f0:	89 81       	ldd	r24, Y+1	; 0x01
    19f2:	82 83       	std	Z+2, r24	; 0x02
	while(SPI_REGS->SPSR.BIT.SPIF==LOW);
    19f4:	ed e2       	ldi	r30, 0x2D	; 45
    19f6:	f0 e0       	ldi	r31, 0x00	; 0
    19f8:	81 81       	ldd	r24, Z+1	; 0x01
    19fa:	80 78       	andi	r24, 0x80	; 128
    19fc:	88 23       	and	r24, r24
    19fe:	d1 f3       	breq	.-12     	; 0x19f4 <SPI_Transieve+0x20>
	return SPI_REGS->SPDR.R;
    1a00:	ed e2       	ldi	r30, 0x2D	; 45
    1a02:	f0 e0       	ldi	r31, 0x00	; 0
    1a04:	82 81       	ldd	r24, Z+2	; 0x02
	//ss-->1
	
}
    1a06:	0f 90       	pop	r0
    1a08:	cf 91       	pop	r28
    1a0a:	df 91       	pop	r29
    1a0c:	08 95       	ret

00001a0e <__vector_17>:
void __vector_17(void)    __attribute__((signal));
void __vector_17(void)
{
    1a0e:	1f 92       	push	r1
    1a10:	0f 92       	push	r0
    1a12:	0f b6       	in	r0, 0x3f	; 63
    1a14:	0f 92       	push	r0
    1a16:	00 90 5b 00 	lds	r0, 0x005B
    1a1a:	0f 92       	push	r0
    1a1c:	11 24       	eor	r1, r1
    1a1e:	2f 93       	push	r18
    1a20:	3f 93       	push	r19
    1a22:	4f 93       	push	r20
    1a24:	5f 93       	push	r21
    1a26:	6f 93       	push	r22
    1a28:	7f 93       	push	r23
    1a2a:	8f 93       	push	r24
    1a2c:	9f 93       	push	r25
    1a2e:	af 93       	push	r26
    1a30:	bf 93       	push	r27
    1a32:	ef 93       	push	r30
    1a34:	ff 93       	push	r31
    1a36:	df 93       	push	r29
    1a38:	cf 93       	push	r28
    1a3a:	cd b7       	in	r28, 0x3d	; 61
    1a3c:	de b7       	in	r29, 0x3e	; 62
	Global_Ptf();
    1a3e:	e0 91 a7 02 	lds	r30, 0x02A7
    1a42:	f0 91 a8 02 	lds	r31, 0x02A8
    1a46:	09 95       	icall
	*SPI_GlOBAL_DATA=SPI_REGS->SPDR.R;
    1a48:	a0 91 a9 02 	lds	r26, 0x02A9
    1a4c:	b0 91 aa 02 	lds	r27, 0x02AA
    1a50:	ed e2       	ldi	r30, 0x2D	; 45
    1a52:	f0 e0       	ldi	r31, 0x00	; 0
    1a54:	82 81       	ldd	r24, Z+2	; 0x02
    1a56:	8c 93       	st	X, r24
}
    1a58:	cf 91       	pop	r28
    1a5a:	df 91       	pop	r29
    1a5c:	ff 91       	pop	r31
    1a5e:	ef 91       	pop	r30
    1a60:	bf 91       	pop	r27
    1a62:	af 91       	pop	r26
    1a64:	9f 91       	pop	r25
    1a66:	8f 91       	pop	r24
    1a68:	7f 91       	pop	r23
    1a6a:	6f 91       	pop	r22
    1a6c:	5f 91       	pop	r21
    1a6e:	4f 91       	pop	r20
    1a70:	3f 91       	pop	r19
    1a72:	2f 91       	pop	r18
    1a74:	0f 90       	pop	r0
    1a76:	00 92 5b 00 	sts	0x005B, r0
    1a7a:	0f 90       	pop	r0
    1a7c:	0f be       	out	0x3f, r0	; 63
    1a7e:	0f 90       	pop	r0
    1a80:	1f 90       	pop	r1
    1a82:	18 95       	reti

00001a84 <Dio_WriteChannel>:
#include "../../MCAL/DIO/DIO.h"
#include "../../Services/PORT/Port.h"
#include "../../MCAL/DIO/Dio_Types.h"

void Dio_WriteChannel(Dio_ChannelType ChannelId,Dio_LevelType Level)
{
    1a84:	df 93       	push	r29
    1a86:	cf 93       	push	r28
    1a88:	00 d0       	rcall	.+0      	; 0x1a8a <Dio_WriteChannel+0x6>
    1a8a:	00 d0       	rcall	.+0      	; 0x1a8c <Dio_WriteChannel+0x8>
    1a8c:	0f 92       	push	r0
    1a8e:	cd b7       	in	r28, 0x3d	; 61
    1a90:	de b7       	in	r29, 0x3e	; 62
    1a92:	8a 83       	std	Y+2, r24	; 0x02
    1a94:	6b 83       	std	Y+3, r22	; 0x03
	Dio_PortType port=ChannelId/8;
    1a96:	8a 81       	ldd	r24, Y+2	; 0x02
    1a98:	86 95       	lsr	r24
    1a9a:	86 95       	lsr	r24
    1a9c:	86 95       	lsr	r24
    1a9e:	89 83       	std	Y+1, r24	; 0x01
	switch(port)
    1aa0:	89 81       	ldd	r24, Y+1	; 0x01
    1aa2:	28 2f       	mov	r18, r24
    1aa4:	30 e0       	ldi	r19, 0x00	; 0
    1aa6:	3d 83       	std	Y+5, r19	; 0x05
    1aa8:	2c 83       	std	Y+4, r18	; 0x04
    1aaa:	8c 81       	ldd	r24, Y+4	; 0x04
    1aac:	9d 81       	ldd	r25, Y+5	; 0x05
    1aae:	82 30       	cpi	r24, 0x02	; 2
    1ab0:	91 05       	cpc	r25, r1
    1ab2:	09 f4       	brne	.+2      	; 0x1ab6 <Dio_WriteChannel+0x32>
    1ab4:	81 c0       	rjmp	.+258    	; 0x1bb8 <Dio_WriteChannel+0x134>
    1ab6:	2c 81       	ldd	r18, Y+4	; 0x04
    1ab8:	3d 81       	ldd	r19, Y+5	; 0x05
    1aba:	23 30       	cpi	r18, 0x03	; 3
    1abc:	31 05       	cpc	r19, r1
    1abe:	5c f4       	brge	.+22     	; 0x1ad6 <Dio_WriteChannel+0x52>
    1ac0:	8c 81       	ldd	r24, Y+4	; 0x04
    1ac2:	9d 81       	ldd	r25, Y+5	; 0x05
    1ac4:	00 97       	sbiw	r24, 0x00	; 0
    1ac6:	a1 f0       	breq	.+40     	; 0x1af0 <Dio_WriteChannel+0x6c>
    1ac8:	2c 81       	ldd	r18, Y+4	; 0x04
    1aca:	3d 81       	ldd	r19, Y+5	; 0x05
    1acc:	21 30       	cpi	r18, 0x01	; 1
    1ace:	31 05       	cpc	r19, r1
    1ad0:	09 f4       	brne	.+2      	; 0x1ad4 <Dio_WriteChannel+0x50>
    1ad2:	40 c0       	rjmp	.+128    	; 0x1b54 <Dio_WriteChannel+0xd0>
    1ad4:	06 c1       	rjmp	.+524    	; 0x1ce2 <Dio_WriteChannel+0x25e>
    1ad6:	8c 81       	ldd	r24, Y+4	; 0x04
    1ad8:	9d 81       	ldd	r25, Y+5	; 0x05
    1ada:	83 30       	cpi	r24, 0x03	; 3
    1adc:	91 05       	cpc	r25, r1
    1ade:	09 f4       	brne	.+2      	; 0x1ae2 <Dio_WriteChannel+0x5e>
    1ae0:	9d c0       	rjmp	.+314    	; 0x1c1c <Dio_WriteChannel+0x198>
    1ae2:	2c 81       	ldd	r18, Y+4	; 0x04
    1ae4:	3d 81       	ldd	r19, Y+5	; 0x05
    1ae6:	24 30       	cpi	r18, 0x04	; 4
    1ae8:	31 05       	cpc	r19, r1
    1aea:	09 f4       	brne	.+2      	; 0x1aee <Dio_WriteChannel+0x6a>
    1aec:	c9 c0       	rjmp	.+402    	; 0x1c80 <Dio_WriteChannel+0x1fc>
    1aee:	f9 c0       	rjmp	.+498    	; 0x1ce2 <Dio_WriteChannel+0x25e>
	{
		case Dio_PORTA:
			if (Level)
    1af0:	8b 81       	ldd	r24, Y+3	; 0x03
    1af2:	88 23       	and	r24, r24
    1af4:	b9 f0       	breq	.+46     	; 0x1b24 <Dio_WriteChannel+0xa0>
			{
				SET_BIT(PORTA,ChannelId%8);
    1af6:	ab e3       	ldi	r26, 0x3B	; 59
    1af8:	b0 e0       	ldi	r27, 0x00	; 0
    1afa:	eb e3       	ldi	r30, 0x3B	; 59
    1afc:	f0 e0       	ldi	r31, 0x00	; 0
    1afe:	80 81       	ld	r24, Z
    1b00:	48 2f       	mov	r20, r24
    1b02:	8a 81       	ldd	r24, Y+2	; 0x02
    1b04:	88 2f       	mov	r24, r24
    1b06:	90 e0       	ldi	r25, 0x00	; 0
    1b08:	9c 01       	movw	r18, r24
    1b0a:	27 70       	andi	r18, 0x07	; 7
    1b0c:	30 70       	andi	r19, 0x00	; 0
    1b0e:	81 e0       	ldi	r24, 0x01	; 1
    1b10:	90 e0       	ldi	r25, 0x00	; 0
    1b12:	02 2e       	mov	r0, r18
    1b14:	02 c0       	rjmp	.+4      	; 0x1b1a <Dio_WriteChannel+0x96>
    1b16:	88 0f       	add	r24, r24
    1b18:	99 1f       	adc	r25, r25
    1b1a:	0a 94       	dec	r0
    1b1c:	e2 f7       	brpl	.-8      	; 0x1b16 <Dio_WriteChannel+0x92>
    1b1e:	84 2b       	or	r24, r20
    1b20:	8c 93       	st	X, r24
    1b22:	df c0       	rjmp	.+446    	; 0x1ce2 <Dio_WriteChannel+0x25e>
			}
			else
			{
				CLR_BIT(PORTA,ChannelId%8);
    1b24:	ab e3       	ldi	r26, 0x3B	; 59
    1b26:	b0 e0       	ldi	r27, 0x00	; 0
    1b28:	eb e3       	ldi	r30, 0x3B	; 59
    1b2a:	f0 e0       	ldi	r31, 0x00	; 0
    1b2c:	80 81       	ld	r24, Z
    1b2e:	48 2f       	mov	r20, r24
    1b30:	8a 81       	ldd	r24, Y+2	; 0x02
    1b32:	88 2f       	mov	r24, r24
    1b34:	90 e0       	ldi	r25, 0x00	; 0
    1b36:	9c 01       	movw	r18, r24
    1b38:	27 70       	andi	r18, 0x07	; 7
    1b3a:	30 70       	andi	r19, 0x00	; 0
    1b3c:	81 e0       	ldi	r24, 0x01	; 1
    1b3e:	90 e0       	ldi	r25, 0x00	; 0
    1b40:	02 2e       	mov	r0, r18
    1b42:	02 c0       	rjmp	.+4      	; 0x1b48 <Dio_WriteChannel+0xc4>
    1b44:	88 0f       	add	r24, r24
    1b46:	99 1f       	adc	r25, r25
    1b48:	0a 94       	dec	r0
    1b4a:	e2 f7       	brpl	.-8      	; 0x1b44 <Dio_WriteChannel+0xc0>
    1b4c:	80 95       	com	r24
    1b4e:	84 23       	and	r24, r20
    1b50:	8c 93       	st	X, r24
    1b52:	c7 c0       	rjmp	.+398    	; 0x1ce2 <Dio_WriteChannel+0x25e>
			}
		break;
		case Dio_PORTB :
			if (Level)
    1b54:	8b 81       	ldd	r24, Y+3	; 0x03
    1b56:	88 23       	and	r24, r24
    1b58:	b9 f0       	breq	.+46     	; 0x1b88 <Dio_WriteChannel+0x104>
			{
				SET_BIT(PORTB,ChannelId%8);
    1b5a:	a8 e3       	ldi	r26, 0x38	; 56
    1b5c:	b0 e0       	ldi	r27, 0x00	; 0
    1b5e:	e8 e3       	ldi	r30, 0x38	; 56
    1b60:	f0 e0       	ldi	r31, 0x00	; 0
    1b62:	80 81       	ld	r24, Z
    1b64:	48 2f       	mov	r20, r24
    1b66:	8a 81       	ldd	r24, Y+2	; 0x02
    1b68:	88 2f       	mov	r24, r24
    1b6a:	90 e0       	ldi	r25, 0x00	; 0
    1b6c:	9c 01       	movw	r18, r24
    1b6e:	27 70       	andi	r18, 0x07	; 7
    1b70:	30 70       	andi	r19, 0x00	; 0
    1b72:	81 e0       	ldi	r24, 0x01	; 1
    1b74:	90 e0       	ldi	r25, 0x00	; 0
    1b76:	02 2e       	mov	r0, r18
    1b78:	02 c0       	rjmp	.+4      	; 0x1b7e <Dio_WriteChannel+0xfa>
    1b7a:	88 0f       	add	r24, r24
    1b7c:	99 1f       	adc	r25, r25
    1b7e:	0a 94       	dec	r0
    1b80:	e2 f7       	brpl	.-8      	; 0x1b7a <Dio_WriteChannel+0xf6>
    1b82:	84 2b       	or	r24, r20
    1b84:	8c 93       	st	X, r24
    1b86:	ad c0       	rjmp	.+346    	; 0x1ce2 <Dio_WriteChannel+0x25e>
			}
			else
			{
				CLR_BIT(PORTB,ChannelId%8);
    1b88:	a8 e3       	ldi	r26, 0x38	; 56
    1b8a:	b0 e0       	ldi	r27, 0x00	; 0
    1b8c:	e8 e3       	ldi	r30, 0x38	; 56
    1b8e:	f0 e0       	ldi	r31, 0x00	; 0
    1b90:	80 81       	ld	r24, Z
    1b92:	48 2f       	mov	r20, r24
    1b94:	8a 81       	ldd	r24, Y+2	; 0x02
    1b96:	88 2f       	mov	r24, r24
    1b98:	90 e0       	ldi	r25, 0x00	; 0
    1b9a:	9c 01       	movw	r18, r24
    1b9c:	27 70       	andi	r18, 0x07	; 7
    1b9e:	30 70       	andi	r19, 0x00	; 0
    1ba0:	81 e0       	ldi	r24, 0x01	; 1
    1ba2:	90 e0       	ldi	r25, 0x00	; 0
    1ba4:	02 2e       	mov	r0, r18
    1ba6:	02 c0       	rjmp	.+4      	; 0x1bac <Dio_WriteChannel+0x128>
    1ba8:	88 0f       	add	r24, r24
    1baa:	99 1f       	adc	r25, r25
    1bac:	0a 94       	dec	r0
    1bae:	e2 f7       	brpl	.-8      	; 0x1ba8 <Dio_WriteChannel+0x124>
    1bb0:	80 95       	com	r24
    1bb2:	84 23       	and	r24, r20
    1bb4:	8c 93       	st	X, r24
    1bb6:	95 c0       	rjmp	.+298    	; 0x1ce2 <Dio_WriteChannel+0x25e>
			}
		break;
		case Dio_PORTC:
			if (Level)
    1bb8:	8b 81       	ldd	r24, Y+3	; 0x03
    1bba:	88 23       	and	r24, r24
    1bbc:	b9 f0       	breq	.+46     	; 0x1bec <Dio_WriteChannel+0x168>
			{
				SET_BIT(PORTC,ChannelId%8);
    1bbe:	a5 e3       	ldi	r26, 0x35	; 53
    1bc0:	b0 e0       	ldi	r27, 0x00	; 0
    1bc2:	e5 e3       	ldi	r30, 0x35	; 53
    1bc4:	f0 e0       	ldi	r31, 0x00	; 0
    1bc6:	80 81       	ld	r24, Z
    1bc8:	48 2f       	mov	r20, r24
    1bca:	8a 81       	ldd	r24, Y+2	; 0x02
    1bcc:	88 2f       	mov	r24, r24
    1bce:	90 e0       	ldi	r25, 0x00	; 0
    1bd0:	9c 01       	movw	r18, r24
    1bd2:	27 70       	andi	r18, 0x07	; 7
    1bd4:	30 70       	andi	r19, 0x00	; 0
    1bd6:	81 e0       	ldi	r24, 0x01	; 1
    1bd8:	90 e0       	ldi	r25, 0x00	; 0
    1bda:	02 2e       	mov	r0, r18
    1bdc:	02 c0       	rjmp	.+4      	; 0x1be2 <Dio_WriteChannel+0x15e>
    1bde:	88 0f       	add	r24, r24
    1be0:	99 1f       	adc	r25, r25
    1be2:	0a 94       	dec	r0
    1be4:	e2 f7       	brpl	.-8      	; 0x1bde <Dio_WriteChannel+0x15a>
    1be6:	84 2b       	or	r24, r20
    1be8:	8c 93       	st	X, r24
    1bea:	7b c0       	rjmp	.+246    	; 0x1ce2 <Dio_WriteChannel+0x25e>
			}
			else
			{
				CLR_BIT(PORTC,ChannelId%8);
    1bec:	a5 e3       	ldi	r26, 0x35	; 53
    1bee:	b0 e0       	ldi	r27, 0x00	; 0
    1bf0:	e5 e3       	ldi	r30, 0x35	; 53
    1bf2:	f0 e0       	ldi	r31, 0x00	; 0
    1bf4:	80 81       	ld	r24, Z
    1bf6:	48 2f       	mov	r20, r24
    1bf8:	8a 81       	ldd	r24, Y+2	; 0x02
    1bfa:	88 2f       	mov	r24, r24
    1bfc:	90 e0       	ldi	r25, 0x00	; 0
    1bfe:	9c 01       	movw	r18, r24
    1c00:	27 70       	andi	r18, 0x07	; 7
    1c02:	30 70       	andi	r19, 0x00	; 0
    1c04:	81 e0       	ldi	r24, 0x01	; 1
    1c06:	90 e0       	ldi	r25, 0x00	; 0
    1c08:	02 2e       	mov	r0, r18
    1c0a:	02 c0       	rjmp	.+4      	; 0x1c10 <Dio_WriteChannel+0x18c>
    1c0c:	88 0f       	add	r24, r24
    1c0e:	99 1f       	adc	r25, r25
    1c10:	0a 94       	dec	r0
    1c12:	e2 f7       	brpl	.-8      	; 0x1c0c <Dio_WriteChannel+0x188>
    1c14:	80 95       	com	r24
    1c16:	84 23       	and	r24, r20
    1c18:	8c 93       	st	X, r24
    1c1a:	63 c0       	rjmp	.+198    	; 0x1ce2 <Dio_WriteChannel+0x25e>
			}
		break;
		case Dio_PORTD:
			if (Level)
    1c1c:	8b 81       	ldd	r24, Y+3	; 0x03
    1c1e:	88 23       	and	r24, r24
    1c20:	b9 f0       	breq	.+46     	; 0x1c50 <Dio_WriteChannel+0x1cc>
			{
				SET_BIT(PORTD,ChannelId%8);
    1c22:	a2 e3       	ldi	r26, 0x32	; 50
    1c24:	b0 e0       	ldi	r27, 0x00	; 0
    1c26:	e2 e3       	ldi	r30, 0x32	; 50
    1c28:	f0 e0       	ldi	r31, 0x00	; 0
    1c2a:	80 81       	ld	r24, Z
    1c2c:	48 2f       	mov	r20, r24
    1c2e:	8a 81       	ldd	r24, Y+2	; 0x02
    1c30:	88 2f       	mov	r24, r24
    1c32:	90 e0       	ldi	r25, 0x00	; 0
    1c34:	9c 01       	movw	r18, r24
    1c36:	27 70       	andi	r18, 0x07	; 7
    1c38:	30 70       	andi	r19, 0x00	; 0
    1c3a:	81 e0       	ldi	r24, 0x01	; 1
    1c3c:	90 e0       	ldi	r25, 0x00	; 0
    1c3e:	02 2e       	mov	r0, r18
    1c40:	02 c0       	rjmp	.+4      	; 0x1c46 <Dio_WriteChannel+0x1c2>
    1c42:	88 0f       	add	r24, r24
    1c44:	99 1f       	adc	r25, r25
    1c46:	0a 94       	dec	r0
    1c48:	e2 f7       	brpl	.-8      	; 0x1c42 <Dio_WriteChannel+0x1be>
    1c4a:	84 2b       	or	r24, r20
    1c4c:	8c 93       	st	X, r24
    1c4e:	49 c0       	rjmp	.+146    	; 0x1ce2 <Dio_WriteChannel+0x25e>
			}
			else
			{
				CLR_BIT(PORTD,ChannelId%8);
    1c50:	a2 e3       	ldi	r26, 0x32	; 50
    1c52:	b0 e0       	ldi	r27, 0x00	; 0
    1c54:	e2 e3       	ldi	r30, 0x32	; 50
    1c56:	f0 e0       	ldi	r31, 0x00	; 0
    1c58:	80 81       	ld	r24, Z
    1c5a:	48 2f       	mov	r20, r24
    1c5c:	8a 81       	ldd	r24, Y+2	; 0x02
    1c5e:	88 2f       	mov	r24, r24
    1c60:	90 e0       	ldi	r25, 0x00	; 0
    1c62:	9c 01       	movw	r18, r24
    1c64:	27 70       	andi	r18, 0x07	; 7
    1c66:	30 70       	andi	r19, 0x00	; 0
    1c68:	81 e0       	ldi	r24, 0x01	; 1
    1c6a:	90 e0       	ldi	r25, 0x00	; 0
    1c6c:	02 2e       	mov	r0, r18
    1c6e:	02 c0       	rjmp	.+4      	; 0x1c74 <Dio_WriteChannel+0x1f0>
    1c70:	88 0f       	add	r24, r24
    1c72:	99 1f       	adc	r25, r25
    1c74:	0a 94       	dec	r0
    1c76:	e2 f7       	brpl	.-8      	; 0x1c70 <Dio_WriteChannel+0x1ec>
    1c78:	80 95       	com	r24
    1c7a:	84 23       	and	r24, r20
    1c7c:	8c 93       	st	X, r24
    1c7e:	31 c0       	rjmp	.+98     	; 0x1ce2 <Dio_WriteChannel+0x25e>
			}
			break;
		case Dio_PORTE:
			if (Level)
    1c80:	8b 81       	ldd	r24, Y+3	; 0x03
    1c82:	88 23       	and	r24, r24
    1c84:	b9 f0       	breq	.+46     	; 0x1cb4 <Dio_WriteChannel+0x230>
			{
				SET_BIT(PORTE,ChannelId%8);
    1c86:	a3 e2       	ldi	r26, 0x23	; 35
    1c88:	b0 e0       	ldi	r27, 0x00	; 0
    1c8a:	e3 e2       	ldi	r30, 0x23	; 35
    1c8c:	f0 e0       	ldi	r31, 0x00	; 0
    1c8e:	80 81       	ld	r24, Z
    1c90:	48 2f       	mov	r20, r24
    1c92:	8a 81       	ldd	r24, Y+2	; 0x02
    1c94:	88 2f       	mov	r24, r24
    1c96:	90 e0       	ldi	r25, 0x00	; 0
    1c98:	9c 01       	movw	r18, r24
    1c9a:	27 70       	andi	r18, 0x07	; 7
    1c9c:	30 70       	andi	r19, 0x00	; 0
    1c9e:	81 e0       	ldi	r24, 0x01	; 1
    1ca0:	90 e0       	ldi	r25, 0x00	; 0
    1ca2:	02 2e       	mov	r0, r18
    1ca4:	02 c0       	rjmp	.+4      	; 0x1caa <Dio_WriteChannel+0x226>
    1ca6:	88 0f       	add	r24, r24
    1ca8:	99 1f       	adc	r25, r25
    1caa:	0a 94       	dec	r0
    1cac:	e2 f7       	brpl	.-8      	; 0x1ca6 <Dio_WriteChannel+0x222>
    1cae:	84 2b       	or	r24, r20
    1cb0:	8c 93       	st	X, r24
    1cb2:	17 c0       	rjmp	.+46     	; 0x1ce2 <Dio_WriteChannel+0x25e>
			}
			else
			{
				CLR_BIT(PORTE,ChannelId%8);
    1cb4:	a3 e2       	ldi	r26, 0x23	; 35
    1cb6:	b0 e0       	ldi	r27, 0x00	; 0
    1cb8:	e3 e2       	ldi	r30, 0x23	; 35
    1cba:	f0 e0       	ldi	r31, 0x00	; 0
    1cbc:	80 81       	ld	r24, Z
    1cbe:	48 2f       	mov	r20, r24
    1cc0:	8a 81       	ldd	r24, Y+2	; 0x02
    1cc2:	88 2f       	mov	r24, r24
    1cc4:	90 e0       	ldi	r25, 0x00	; 0
    1cc6:	9c 01       	movw	r18, r24
    1cc8:	27 70       	andi	r18, 0x07	; 7
    1cca:	30 70       	andi	r19, 0x00	; 0
    1ccc:	81 e0       	ldi	r24, 0x01	; 1
    1cce:	90 e0       	ldi	r25, 0x00	; 0
    1cd0:	02 2e       	mov	r0, r18
    1cd2:	02 c0       	rjmp	.+4      	; 0x1cd8 <Dio_WriteChannel+0x254>
    1cd4:	88 0f       	add	r24, r24
    1cd6:	99 1f       	adc	r25, r25
    1cd8:	0a 94       	dec	r0
    1cda:	e2 f7       	brpl	.-8      	; 0x1cd4 <Dio_WriteChannel+0x250>
    1cdc:	80 95       	com	r24
    1cde:	84 23       	and	r24, r20
    1ce0:	8c 93       	st	X, r24
			}
			break;
		}
	

}
    1ce2:	0f 90       	pop	r0
    1ce4:	0f 90       	pop	r0
    1ce6:	0f 90       	pop	r0
    1ce8:	0f 90       	pop	r0
    1cea:	0f 90       	pop	r0
    1cec:	cf 91       	pop	r28
    1cee:	df 91       	pop	r29
    1cf0:	08 95       	ret

00001cf2 <Dio_FlipChannel>:
void Dio_FlipChannel(Dio_ChannelType ChannelId)
{
    1cf2:	df 93       	push	r29
    1cf4:	cf 93       	push	r28
    1cf6:	00 d0       	rcall	.+0      	; 0x1cf8 <Dio_FlipChannel+0x6>
    1cf8:	00 d0       	rcall	.+0      	; 0x1cfa <Dio_FlipChannel+0x8>
    1cfa:	0f 92       	push	r0
    1cfc:	cd b7       	in	r28, 0x3d	; 61
    1cfe:	de b7       	in	r29, 0x3e	; 62
    1d00:	8b 83       	std	Y+3, r24	; 0x03
	Dio_PortType port=ChannelId/8;
    1d02:	8b 81       	ldd	r24, Y+3	; 0x03
    1d04:	86 95       	lsr	r24
    1d06:	86 95       	lsr	r24
    1d08:	86 95       	lsr	r24
    1d0a:	8a 83       	std	Y+2, r24	; 0x02
	u8 pin=ChannelId%8;
    1d0c:	8b 81       	ldd	r24, Y+3	; 0x03
    1d0e:	87 70       	andi	r24, 0x07	; 7
    1d10:	89 83       	std	Y+1, r24	; 0x01
	switch(port)
    1d12:	8a 81       	ldd	r24, Y+2	; 0x02
    1d14:	28 2f       	mov	r18, r24
    1d16:	30 e0       	ldi	r19, 0x00	; 0
    1d18:	3d 83       	std	Y+5, r19	; 0x05
    1d1a:	2c 83       	std	Y+4, r18	; 0x04
    1d1c:	8c 81       	ldd	r24, Y+4	; 0x04
    1d1e:	9d 81       	ldd	r25, Y+5	; 0x05
    1d20:	82 30       	cpi	r24, 0x02	; 2
    1d22:	91 05       	cpc	r25, r1
    1d24:	09 f4       	brne	.+2      	; 0x1d28 <Dio_FlipChannel+0x36>
    1d26:	44 c0       	rjmp	.+136    	; 0x1db0 <Dio_FlipChannel+0xbe>
    1d28:	2c 81       	ldd	r18, Y+4	; 0x04
    1d2a:	3d 81       	ldd	r19, Y+5	; 0x05
    1d2c:	23 30       	cpi	r18, 0x03	; 3
    1d2e:	31 05       	cpc	r19, r1
    1d30:	54 f4       	brge	.+20     	; 0x1d46 <Dio_FlipChannel+0x54>
    1d32:	8c 81       	ldd	r24, Y+4	; 0x04
    1d34:	9d 81       	ldd	r25, Y+5	; 0x05
    1d36:	00 97       	sbiw	r24, 0x00	; 0
    1d38:	99 f0       	breq	.+38     	; 0x1d60 <Dio_FlipChannel+0x6e>
    1d3a:	2c 81       	ldd	r18, Y+4	; 0x04
    1d3c:	3d 81       	ldd	r19, Y+5	; 0x05
    1d3e:	21 30       	cpi	r18, 0x01	; 1
    1d40:	31 05       	cpc	r19, r1
    1d42:	11 f1       	breq	.+68     	; 0x1d88 <Dio_FlipChannel+0x96>
    1d44:	70 c0       	rjmp	.+224    	; 0x1e26 <Dio_FlipChannel+0x134>
    1d46:	8c 81       	ldd	r24, Y+4	; 0x04
    1d48:	9d 81       	ldd	r25, Y+5	; 0x05
    1d4a:	83 30       	cpi	r24, 0x03	; 3
    1d4c:	91 05       	cpc	r25, r1
    1d4e:	09 f4       	brne	.+2      	; 0x1d52 <Dio_FlipChannel+0x60>
    1d50:	43 c0       	rjmp	.+134    	; 0x1dd8 <Dio_FlipChannel+0xe6>
    1d52:	2c 81       	ldd	r18, Y+4	; 0x04
    1d54:	3d 81       	ldd	r19, Y+5	; 0x05
    1d56:	24 30       	cpi	r18, 0x04	; 4
    1d58:	31 05       	cpc	r19, r1
    1d5a:	09 f4       	brne	.+2      	; 0x1d5e <Dio_FlipChannel+0x6c>
    1d5c:	51 c0       	rjmp	.+162    	; 0x1e00 <Dio_FlipChannel+0x10e>
    1d5e:	63 c0       	rjmp	.+198    	; 0x1e26 <Dio_FlipChannel+0x134>
	{
		case Dio_PORTA:
		TOG_BIT(PORTA,pin);
    1d60:	ab e3       	ldi	r26, 0x3B	; 59
    1d62:	b0 e0       	ldi	r27, 0x00	; 0
    1d64:	eb e3       	ldi	r30, 0x3B	; 59
    1d66:	f0 e0       	ldi	r31, 0x00	; 0
    1d68:	80 81       	ld	r24, Z
    1d6a:	48 2f       	mov	r20, r24
    1d6c:	89 81       	ldd	r24, Y+1	; 0x01
    1d6e:	28 2f       	mov	r18, r24
    1d70:	30 e0       	ldi	r19, 0x00	; 0
    1d72:	81 e0       	ldi	r24, 0x01	; 1
    1d74:	90 e0       	ldi	r25, 0x00	; 0
    1d76:	02 2e       	mov	r0, r18
    1d78:	02 c0       	rjmp	.+4      	; 0x1d7e <Dio_FlipChannel+0x8c>
    1d7a:	88 0f       	add	r24, r24
    1d7c:	99 1f       	adc	r25, r25
    1d7e:	0a 94       	dec	r0
    1d80:	e2 f7       	brpl	.-8      	; 0x1d7a <Dio_FlipChannel+0x88>
    1d82:	84 27       	eor	r24, r20
    1d84:	8c 93       	st	X, r24
    1d86:	4f c0       	rjmp	.+158    	; 0x1e26 <Dio_FlipChannel+0x134>
		break;
		case Dio_PORTB :
		TOG_BIT(PORTB,pin);
    1d88:	a8 e3       	ldi	r26, 0x38	; 56
    1d8a:	b0 e0       	ldi	r27, 0x00	; 0
    1d8c:	e8 e3       	ldi	r30, 0x38	; 56
    1d8e:	f0 e0       	ldi	r31, 0x00	; 0
    1d90:	80 81       	ld	r24, Z
    1d92:	48 2f       	mov	r20, r24
    1d94:	89 81       	ldd	r24, Y+1	; 0x01
    1d96:	28 2f       	mov	r18, r24
    1d98:	30 e0       	ldi	r19, 0x00	; 0
    1d9a:	81 e0       	ldi	r24, 0x01	; 1
    1d9c:	90 e0       	ldi	r25, 0x00	; 0
    1d9e:	02 2e       	mov	r0, r18
    1da0:	02 c0       	rjmp	.+4      	; 0x1da6 <Dio_FlipChannel+0xb4>
    1da2:	88 0f       	add	r24, r24
    1da4:	99 1f       	adc	r25, r25
    1da6:	0a 94       	dec	r0
    1da8:	e2 f7       	brpl	.-8      	; 0x1da2 <Dio_FlipChannel+0xb0>
    1daa:	84 27       	eor	r24, r20
    1dac:	8c 93       	st	X, r24
    1dae:	3b c0       	rjmp	.+118    	; 0x1e26 <Dio_FlipChannel+0x134>
		break;
		case Dio_PORTC:
		TOG_BIT(PORTC,pin);
    1db0:	a5 e3       	ldi	r26, 0x35	; 53
    1db2:	b0 e0       	ldi	r27, 0x00	; 0
    1db4:	e5 e3       	ldi	r30, 0x35	; 53
    1db6:	f0 e0       	ldi	r31, 0x00	; 0
    1db8:	80 81       	ld	r24, Z
    1dba:	48 2f       	mov	r20, r24
    1dbc:	89 81       	ldd	r24, Y+1	; 0x01
    1dbe:	28 2f       	mov	r18, r24
    1dc0:	30 e0       	ldi	r19, 0x00	; 0
    1dc2:	81 e0       	ldi	r24, 0x01	; 1
    1dc4:	90 e0       	ldi	r25, 0x00	; 0
    1dc6:	02 2e       	mov	r0, r18
    1dc8:	02 c0       	rjmp	.+4      	; 0x1dce <Dio_FlipChannel+0xdc>
    1dca:	88 0f       	add	r24, r24
    1dcc:	99 1f       	adc	r25, r25
    1dce:	0a 94       	dec	r0
    1dd0:	e2 f7       	brpl	.-8      	; 0x1dca <Dio_FlipChannel+0xd8>
    1dd2:	84 27       	eor	r24, r20
    1dd4:	8c 93       	st	X, r24
    1dd6:	27 c0       	rjmp	.+78     	; 0x1e26 <Dio_FlipChannel+0x134>
		break;
		case Dio_PORTD:
		TOG_BIT(PORTD,pin);
    1dd8:	a2 e3       	ldi	r26, 0x32	; 50
    1dda:	b0 e0       	ldi	r27, 0x00	; 0
    1ddc:	e2 e3       	ldi	r30, 0x32	; 50
    1dde:	f0 e0       	ldi	r31, 0x00	; 0
    1de0:	80 81       	ld	r24, Z
    1de2:	48 2f       	mov	r20, r24
    1de4:	89 81       	ldd	r24, Y+1	; 0x01
    1de6:	28 2f       	mov	r18, r24
    1de8:	30 e0       	ldi	r19, 0x00	; 0
    1dea:	81 e0       	ldi	r24, 0x01	; 1
    1dec:	90 e0       	ldi	r25, 0x00	; 0
    1dee:	02 2e       	mov	r0, r18
    1df0:	02 c0       	rjmp	.+4      	; 0x1df6 <Dio_FlipChannel+0x104>
    1df2:	88 0f       	add	r24, r24
    1df4:	99 1f       	adc	r25, r25
    1df6:	0a 94       	dec	r0
    1df8:	e2 f7       	brpl	.-8      	; 0x1df2 <Dio_FlipChannel+0x100>
    1dfa:	84 27       	eor	r24, r20
    1dfc:	8c 93       	st	X, r24
    1dfe:	13 c0       	rjmp	.+38     	; 0x1e26 <Dio_FlipChannel+0x134>
		break;
		case Dio_PORTE:
		TOG_BIT(PORTE,pin);
    1e00:	a3 e2       	ldi	r26, 0x23	; 35
    1e02:	b0 e0       	ldi	r27, 0x00	; 0
    1e04:	e3 e2       	ldi	r30, 0x23	; 35
    1e06:	f0 e0       	ldi	r31, 0x00	; 0
    1e08:	80 81       	ld	r24, Z
    1e0a:	48 2f       	mov	r20, r24
    1e0c:	89 81       	ldd	r24, Y+1	; 0x01
    1e0e:	28 2f       	mov	r18, r24
    1e10:	30 e0       	ldi	r19, 0x00	; 0
    1e12:	81 e0       	ldi	r24, 0x01	; 1
    1e14:	90 e0       	ldi	r25, 0x00	; 0
    1e16:	02 2e       	mov	r0, r18
    1e18:	02 c0       	rjmp	.+4      	; 0x1e1e <Dio_FlipChannel+0x12c>
    1e1a:	88 0f       	add	r24, r24
    1e1c:	99 1f       	adc	r25, r25
    1e1e:	0a 94       	dec	r0
    1e20:	e2 f7       	brpl	.-8      	; 0x1e1a <Dio_FlipChannel+0x128>
    1e22:	84 27       	eor	r24, r20
    1e24:	8c 93       	st	X, r24
		break;
	}
}
    1e26:	0f 90       	pop	r0
    1e28:	0f 90       	pop	r0
    1e2a:	0f 90       	pop	r0
    1e2c:	0f 90       	pop	r0
    1e2e:	0f 90       	pop	r0
    1e30:	cf 91       	pop	r28
    1e32:	df 91       	pop	r29
    1e34:	08 95       	ret

00001e36 <Dio_ReadChannel>:

Dio_LevelType Dio_ReadChannel(Dio_ChannelType ChannelId)
{
    1e36:	df 93       	push	r29
    1e38:	cf 93       	push	r28
    1e3a:	00 d0       	rcall	.+0      	; 0x1e3c <Dio_ReadChannel+0x6>
    1e3c:	00 d0       	rcall	.+0      	; 0x1e3e <Dio_ReadChannel+0x8>
    1e3e:	00 d0       	rcall	.+0      	; 0x1e40 <Dio_ReadChannel+0xa>
    1e40:	cd b7       	in	r28, 0x3d	; 61
    1e42:	de b7       	in	r29, 0x3e	; 62
    1e44:	8c 83       	std	Y+4, r24	; 0x04
	Dio_PortType port=ChannelId/8;
    1e46:	8c 81       	ldd	r24, Y+4	; 0x04
    1e48:	86 95       	lsr	r24
    1e4a:	86 95       	lsr	r24
    1e4c:	86 95       	lsr	r24
    1e4e:	8b 83       	std	Y+3, r24	; 0x03
	u8 pin=ChannelId%8;
    1e50:	8c 81       	ldd	r24, Y+4	; 0x04
    1e52:	87 70       	andi	r24, 0x07	; 7
    1e54:	8a 83       	std	Y+2, r24	; 0x02
	Dio_LevelType Level=STD_LOW;
    1e56:	19 82       	std	Y+1, r1	; 0x01
	switch(port)
    1e58:	8b 81       	ldd	r24, Y+3	; 0x03
    1e5a:	28 2f       	mov	r18, r24
    1e5c:	30 e0       	ldi	r19, 0x00	; 0
    1e5e:	3e 83       	std	Y+6, r19	; 0x06
    1e60:	2d 83       	std	Y+5, r18	; 0x05
    1e62:	4d 81       	ldd	r20, Y+5	; 0x05
    1e64:	5e 81       	ldd	r21, Y+6	; 0x06
    1e66:	42 30       	cpi	r20, 0x02	; 2
    1e68:	51 05       	cpc	r21, r1
    1e6a:	09 f4       	brne	.+2      	; 0x1e6e <Dio_ReadChannel+0x38>
    1e6c:	41 c0       	rjmp	.+130    	; 0x1ef0 <Dio_ReadChannel+0xba>
    1e6e:	8d 81       	ldd	r24, Y+5	; 0x05
    1e70:	9e 81       	ldd	r25, Y+6	; 0x06
    1e72:	83 30       	cpi	r24, 0x03	; 3
    1e74:	91 05       	cpc	r25, r1
    1e76:	5c f4       	brge	.+22     	; 0x1e8e <Dio_ReadChannel+0x58>
    1e78:	2d 81       	ldd	r18, Y+5	; 0x05
    1e7a:	3e 81       	ldd	r19, Y+6	; 0x06
    1e7c:	21 15       	cp	r18, r1
    1e7e:	31 05       	cpc	r19, r1
    1e80:	99 f0       	breq	.+38     	; 0x1ea8 <Dio_ReadChannel+0x72>
    1e82:	4d 81       	ldd	r20, Y+5	; 0x05
    1e84:	5e 81       	ldd	r21, Y+6	; 0x06
    1e86:	41 30       	cpi	r20, 0x01	; 1
    1e88:	51 05       	cpc	r21, r1
    1e8a:	01 f1       	breq	.+64     	; 0x1ecc <Dio_ReadChannel+0x96>
    1e8c:	66 c0       	rjmp	.+204    	; 0x1f5a <Dio_ReadChannel+0x124>
    1e8e:	8d 81       	ldd	r24, Y+5	; 0x05
    1e90:	9e 81       	ldd	r25, Y+6	; 0x06
    1e92:	83 30       	cpi	r24, 0x03	; 3
    1e94:	91 05       	cpc	r25, r1
    1e96:	09 f4       	brne	.+2      	; 0x1e9a <Dio_ReadChannel+0x64>
    1e98:	3d c0       	rjmp	.+122    	; 0x1f14 <Dio_ReadChannel+0xde>
    1e9a:	2d 81       	ldd	r18, Y+5	; 0x05
    1e9c:	3e 81       	ldd	r19, Y+6	; 0x06
    1e9e:	24 30       	cpi	r18, 0x04	; 4
    1ea0:	31 05       	cpc	r19, r1
    1ea2:	09 f4       	brne	.+2      	; 0x1ea6 <Dio_ReadChannel+0x70>
    1ea4:	49 c0       	rjmp	.+146    	; 0x1f38 <Dio_ReadChannel+0x102>
    1ea6:	59 c0       	rjmp	.+178    	; 0x1f5a <Dio_ReadChannel+0x124>
	{
		case Dio_PORTA:
			Level=GET_BIT(PINA,pin);
    1ea8:	e9 e3       	ldi	r30, 0x39	; 57
    1eaa:	f0 e0       	ldi	r31, 0x00	; 0
    1eac:	80 81       	ld	r24, Z
    1eae:	28 2f       	mov	r18, r24
    1eb0:	30 e0       	ldi	r19, 0x00	; 0
    1eb2:	8a 81       	ldd	r24, Y+2	; 0x02
    1eb4:	88 2f       	mov	r24, r24
    1eb6:	90 e0       	ldi	r25, 0x00	; 0
    1eb8:	a9 01       	movw	r20, r18
    1eba:	02 c0       	rjmp	.+4      	; 0x1ec0 <Dio_ReadChannel+0x8a>
    1ebc:	55 95       	asr	r21
    1ebe:	47 95       	ror	r20
    1ec0:	8a 95       	dec	r24
    1ec2:	e2 f7       	brpl	.-8      	; 0x1ebc <Dio_ReadChannel+0x86>
    1ec4:	ca 01       	movw	r24, r20
    1ec6:	81 70       	andi	r24, 0x01	; 1
    1ec8:	89 83       	std	Y+1, r24	; 0x01
    1eca:	47 c0       	rjmp	.+142    	; 0x1f5a <Dio_ReadChannel+0x124>
		break;
		case Dio_PORTB :
			Level=GET_BIT(PINB,pin);
    1ecc:	e6 e3       	ldi	r30, 0x36	; 54
    1ece:	f0 e0       	ldi	r31, 0x00	; 0
    1ed0:	80 81       	ld	r24, Z
    1ed2:	28 2f       	mov	r18, r24
    1ed4:	30 e0       	ldi	r19, 0x00	; 0
    1ed6:	8a 81       	ldd	r24, Y+2	; 0x02
    1ed8:	88 2f       	mov	r24, r24
    1eda:	90 e0       	ldi	r25, 0x00	; 0
    1edc:	a9 01       	movw	r20, r18
    1ede:	02 c0       	rjmp	.+4      	; 0x1ee4 <Dio_ReadChannel+0xae>
    1ee0:	55 95       	asr	r21
    1ee2:	47 95       	ror	r20
    1ee4:	8a 95       	dec	r24
    1ee6:	e2 f7       	brpl	.-8      	; 0x1ee0 <Dio_ReadChannel+0xaa>
    1ee8:	ca 01       	movw	r24, r20
    1eea:	81 70       	andi	r24, 0x01	; 1
    1eec:	89 83       	std	Y+1, r24	; 0x01
    1eee:	35 c0       	rjmp	.+106    	; 0x1f5a <Dio_ReadChannel+0x124>
	
		break;
		case Dio_PORTC:
			Level=GET_BIT(PINC,pin);
    1ef0:	e3 e3       	ldi	r30, 0x33	; 51
    1ef2:	f0 e0       	ldi	r31, 0x00	; 0
    1ef4:	80 81       	ld	r24, Z
    1ef6:	28 2f       	mov	r18, r24
    1ef8:	30 e0       	ldi	r19, 0x00	; 0
    1efa:	8a 81       	ldd	r24, Y+2	; 0x02
    1efc:	88 2f       	mov	r24, r24
    1efe:	90 e0       	ldi	r25, 0x00	; 0
    1f00:	a9 01       	movw	r20, r18
    1f02:	02 c0       	rjmp	.+4      	; 0x1f08 <Dio_ReadChannel+0xd2>
    1f04:	55 95       	asr	r21
    1f06:	47 95       	ror	r20
    1f08:	8a 95       	dec	r24
    1f0a:	e2 f7       	brpl	.-8      	; 0x1f04 <Dio_ReadChannel+0xce>
    1f0c:	ca 01       	movw	r24, r20
    1f0e:	81 70       	andi	r24, 0x01	; 1
    1f10:	89 83       	std	Y+1, r24	; 0x01
    1f12:	23 c0       	rjmp	.+70     	; 0x1f5a <Dio_ReadChannel+0x124>
		break;
		case Dio_PORTD:
			Level=GET_BIT(PIND,pin);
    1f14:	e0 e3       	ldi	r30, 0x30	; 48
    1f16:	f0 e0       	ldi	r31, 0x00	; 0
    1f18:	80 81       	ld	r24, Z
    1f1a:	28 2f       	mov	r18, r24
    1f1c:	30 e0       	ldi	r19, 0x00	; 0
    1f1e:	8a 81       	ldd	r24, Y+2	; 0x02
    1f20:	88 2f       	mov	r24, r24
    1f22:	90 e0       	ldi	r25, 0x00	; 0
    1f24:	a9 01       	movw	r20, r18
    1f26:	02 c0       	rjmp	.+4      	; 0x1f2c <Dio_ReadChannel+0xf6>
    1f28:	55 95       	asr	r21
    1f2a:	47 95       	ror	r20
    1f2c:	8a 95       	dec	r24
    1f2e:	e2 f7       	brpl	.-8      	; 0x1f28 <Dio_ReadChannel+0xf2>
    1f30:	ca 01       	movw	r24, r20
    1f32:	81 70       	andi	r24, 0x01	; 1
    1f34:	89 83       	std	Y+1, r24	; 0x01
    1f36:	11 c0       	rjmp	.+34     	; 0x1f5a <Dio_ReadChannel+0x124>
		break;
		case Dio_PORTE:
			Level=GET_BIT(PINE,pin);
    1f38:	e1 e2       	ldi	r30, 0x21	; 33
    1f3a:	f0 e0       	ldi	r31, 0x00	; 0
    1f3c:	80 81       	ld	r24, Z
    1f3e:	28 2f       	mov	r18, r24
    1f40:	30 e0       	ldi	r19, 0x00	; 0
    1f42:	8a 81       	ldd	r24, Y+2	; 0x02
    1f44:	88 2f       	mov	r24, r24
    1f46:	90 e0       	ldi	r25, 0x00	; 0
    1f48:	a9 01       	movw	r20, r18
    1f4a:	02 c0       	rjmp	.+4      	; 0x1f50 <Dio_ReadChannel+0x11a>
    1f4c:	55 95       	asr	r21
    1f4e:	47 95       	ror	r20
    1f50:	8a 95       	dec	r24
    1f52:	e2 f7       	brpl	.-8      	; 0x1f4c <Dio_ReadChannel+0x116>
    1f54:	ca 01       	movw	r24, r20
    1f56:	81 70       	andi	r24, 0x01	; 1
    1f58:	89 83       	std	Y+1, r24	; 0x01
		break;
	}
	return Level;
    1f5a:	89 81       	ldd	r24, Y+1	; 0x01
}
    1f5c:	26 96       	adiw	r28, 0x06	; 6
    1f5e:	0f b6       	in	r0, 0x3f	; 63
    1f60:	f8 94       	cli
    1f62:	de bf       	out	0x3e, r29	; 62
    1f64:	0f be       	out	0x3f, r0	; 63
    1f66:	cd bf       	out	0x3d, r28	; 61
    1f68:	cf 91       	pop	r28
    1f6a:	df 91       	pop	r29
    1f6c:	08 95       	ret

00001f6e <MOTOR_Forward>:




void MOTOR_Forward (void)
{
    1f6e:	df 93       	push	r29
    1f70:	cf 93       	push	r28
    1f72:	cd b7       	in	r28, 0x3d	; 61
    1f74:	de b7       	in	r29, 0x3e	; 62
	TMR0_SetDutyCycle(MOTOR_F_DUTY); //PWM on Timer Pin
    1f76:	86 e4       	ldi	r24, 0x46	; 70
    1f78:	0e 94 32 07 	call	0xe64	; 0xe64 <TMR0_SetDutyCycle>
	Dio_WriteChannel(I3,STD_HIGH);
    1f7c:	84 e1       	ldi	r24, 0x14	; 20
    1f7e:	61 e0       	ldi	r22, 0x01	; 1
    1f80:	0e 94 42 0d 	call	0x1a84	; 0x1a84 <Dio_WriteChannel>
	Dio_WriteChannel(I4,STD_LOW);
    1f84:	85 e1       	ldi	r24, 0x15	; 21
    1f86:	60 e0       	ldi	r22, 0x00	; 0
    1f88:	0e 94 42 0d 	call	0x1a84	; 0x1a84 <Dio_WriteChannel>
}
    1f8c:	cf 91       	pop	r28
    1f8e:	df 91       	pop	r29
    1f90:	08 95       	ret

00001f92 <MOTOR_Backward>:

void MOTOR_Backward (void)
{
    1f92:	df 93       	push	r29
    1f94:	cf 93       	push	r28
    1f96:	cd b7       	in	r28, 0x3d	; 61
    1f98:	de b7       	in	r29, 0x3e	; 62
	TMR0_SetDutyCycle(MOTOR_B_DUTY); //PWM on Timer Pin
    1f9a:	86 e4       	ldi	r24, 0x46	; 70
    1f9c:	0e 94 32 07 	call	0xe64	; 0xe64 <TMR0_SetDutyCycle>
	Dio_WriteChannel(I3,STD_LOW);
    1fa0:	84 e1       	ldi	r24, 0x14	; 20
    1fa2:	60 e0       	ldi	r22, 0x00	; 0
    1fa4:	0e 94 42 0d 	call	0x1a84	; 0x1a84 <Dio_WriteChannel>
	Dio_WriteChannel(I4,STD_HIGH);
    1fa8:	85 e1       	ldi	r24, 0x15	; 21
    1faa:	61 e0       	ldi	r22, 0x01	; 1
    1fac:	0e 94 42 0d 	call	0x1a84	; 0x1a84 <Dio_WriteChannel>
}
    1fb0:	cf 91       	pop	r28
    1fb2:	df 91       	pop	r29
    1fb4:	08 95       	ret

00001fb6 <MOTOR_Stop>:

void MOTOR_Stop (void)
{
    1fb6:	df 93       	push	r29
    1fb8:	cf 93       	push	r28
    1fba:	cd b7       	in	r28, 0x3d	; 61
    1fbc:	de b7       	in	r29, 0x3e	; 62
	TMR0_SetDutyCycle(0); //PWM on Timer Pin
    1fbe:	80 e0       	ldi	r24, 0x00	; 0
    1fc0:	0e 94 32 07 	call	0xe64	; 0xe64 <TMR0_SetDutyCycle>
	Dio_WriteChannel(I3,STD_LOW);
    1fc4:	84 e1       	ldi	r24, 0x14	; 20
    1fc6:	60 e0       	ldi	r22, 0x00	; 0
    1fc8:	0e 94 42 0d 	call	0x1a84	; 0x1a84 <Dio_WriteChannel>
	Dio_WriteChannel(I4,STD_LOW);
    1fcc:	85 e1       	ldi	r24, 0x15	; 21
    1fce:	60 e0       	ldi	r22, 0x00	; 0
    1fd0:	0e 94 42 0d 	call	0x1a84	; 0x1a84 <Dio_WriteChannel>
}
    1fd4:	cf 91       	pop	r28
    1fd6:	df 91       	pop	r29
    1fd8:	08 95       	ret

00001fda <MOTOR_Forward_SetSpeed>:

void MOTOR_Forward_SetSpeed (u8 speed)
{
    1fda:	df 93       	push	r29
    1fdc:	cf 93       	push	r28
    1fde:	0f 92       	push	r0
    1fe0:	cd b7       	in	r28, 0x3d	; 61
    1fe2:	de b7       	in	r29, 0x3e	; 62
    1fe4:	89 83       	std	Y+1, r24	; 0x01
		TMR0_SetDutyCycle(speed);
    1fe6:	89 81       	ldd	r24, Y+1	; 0x01
    1fe8:	0e 94 32 07 	call	0xe64	; 0xe64 <TMR0_SetDutyCycle>
		Dio_WriteChannel(I3,STD_HIGH);
    1fec:	84 e1       	ldi	r24, 0x14	; 20
    1fee:	61 e0       	ldi	r22, 0x01	; 1
    1ff0:	0e 94 42 0d 	call	0x1a84	; 0x1a84 <Dio_WriteChannel>
		Dio_WriteChannel(I4,STD_LOW);
    1ff4:	85 e1       	ldi	r24, 0x15	; 21
    1ff6:	60 e0       	ldi	r22, 0x00	; 0
    1ff8:	0e 94 42 0d 	call	0x1a84	; 0x1a84 <Dio_WriteChannel>
}
    1ffc:	0f 90       	pop	r0
    1ffe:	cf 91       	pop	r28
    2000:	df 91       	pop	r29
    2002:	08 95       	ret

00002004 <MOTOR_steering_Control>:
/*******************************steering motor******************************************************************/

void MOTOR_steering_Control(u8 steeringstatus)
{
    2004:	df 93       	push	r29
    2006:	cf 93       	push	r28
    2008:	00 d0       	rcall	.+0      	; 0x200a <MOTOR_steering_Control+0x6>
    200a:	0f 92       	push	r0
    200c:	cd b7       	in	r28, 0x3d	; 61
    200e:	de b7       	in	r29, 0x3e	; 62
    2010:	89 83       	std	Y+1, r24	; 0x01
	//1 step on
	//off motor
	
	switch (steeringstatus)
    2012:	89 81       	ldd	r24, Y+1	; 0x01
    2014:	28 2f       	mov	r18, r24
    2016:	30 e0       	ldi	r19, 0x00	; 0
    2018:	3b 83       	std	Y+3, r19	; 0x03
    201a:	2a 83       	std	Y+2, r18	; 0x02
    201c:	8a 81       	ldd	r24, Y+2	; 0x02
    201e:	9b 81       	ldd	r25, Y+3	; 0x03
    2020:	84 30       	cpi	r24, 0x04	; 4
    2022:	91 05       	cpc	r25, r1
    2024:	b1 f0       	breq	.+44     	; 0x2052 <MOTOR_steering_Control+0x4e>
    2026:	2a 81       	ldd	r18, Y+2	; 0x02
    2028:	3b 81       	ldd	r19, Y+3	; 0x03
    202a:	29 30       	cpi	r18, 0x09	; 9
    202c:	31 05       	cpc	r19, r1
    202e:	e9 f0       	breq	.+58     	; 0x206a <MOTOR_steering_Control+0x66>
    2030:	8a 81       	ldd	r24, Y+2	; 0x02
    2032:	9b 81       	ldd	r25, Y+3	; 0x03
    2034:	83 30       	cpi	r24, 0x03	; 3
    2036:	91 05       	cpc	r25, r1
    2038:	19 f5       	brne	.+70     	; 0x2080 <MOTOR_steering_Control+0x7c>
	{
		case STEERING_RIGHT  :
		Dio_WriteChannel(I1,STD_HIGH);
    203a:	82 e1       	ldi	r24, 0x12	; 18
    203c:	61 e0       	ldi	r22, 0x01	; 1
    203e:	0e 94 42 0d 	call	0x1a84	; 0x1a84 <Dio_WriteChannel>
		Dio_WriteChannel(I2,STD_LOW);
    2042:	83 e1       	ldi	r24, 0x13	; 19
    2044:	60 e0       	ldi	r22, 0x00	; 0
    2046:	0e 94 42 0d 	call	0x1a84	; 0x1a84 <Dio_WriteChannel>
		TMR2_SetDutyCycle(MOTOR_R_DUTY);
    204a:	83 e6       	ldi	r24, 0x63	; 99
    204c:	0e 94 83 08 	call	0x1106	; 0x1106 <TMR2_SetDutyCycle>
    2050:	17 c0       	rjmp	.+46     	; 0x2080 <MOTOR_steering_Control+0x7c>
		break;
		case STEERING_LEFT :
		Dio_WriteChannel(I1,STD_LOW);
    2052:	82 e1       	ldi	r24, 0x12	; 18
    2054:	60 e0       	ldi	r22, 0x00	; 0
    2056:	0e 94 42 0d 	call	0x1a84	; 0x1a84 <Dio_WriteChannel>
		Dio_WriteChannel(I2,STD_HIGH);
    205a:	83 e1       	ldi	r24, 0x13	; 19
    205c:	61 e0       	ldi	r22, 0x01	; 1
    205e:	0e 94 42 0d 	call	0x1a84	; 0x1a84 <Dio_WriteChannel>
		TMR2_SetDutyCycle(MOTOR_L_DUTY);
    2062:	83 e6       	ldi	r24, 0x63	; 99
    2064:	0e 94 83 08 	call	0x1106	; 0x1106 <TMR2_SetDutyCycle>
    2068:	0b c0       	rjmp	.+22     	; 0x2080 <MOTOR_steering_Control+0x7c>
		break;
		case STEERING_STRAIGHT :
		Dio_WriteChannel(I1,STD_LOW);
    206a:	82 e1       	ldi	r24, 0x12	; 18
    206c:	60 e0       	ldi	r22, 0x00	; 0
    206e:	0e 94 42 0d 	call	0x1a84	; 0x1a84 <Dio_WriteChannel>
		Dio_WriteChannel(I2,STD_LOW);
    2072:	83 e1       	ldi	r24, 0x13	; 19
    2074:	60 e0       	ldi	r22, 0x00	; 0
    2076:	0e 94 42 0d 	call	0x1a84	; 0x1a84 <Dio_WriteChannel>
		TMR2_SetDutyCycle(0);
    207a:	80 e0       	ldi	r24, 0x00	; 0
    207c:	0e 94 83 08 	call	0x1106	; 0x1106 <TMR2_SetDutyCycle>
		break;
	}
}
    2080:	0f 90       	pop	r0
    2082:	0f 90       	pop	r0
    2084:	0f 90       	pop	r0
    2086:	cf 91       	pop	r28
    2088:	df 91       	pop	r29
    208a:	08 95       	ret

0000208c <MCP2515_ReadRegister>:
#include "../../HAL/CANMCB/MCP2515_private.h"
#include "../../HAL/CANMCB/MCP2515_cfg.h"

volatile u8 buffer[14];
u8 MCP2515_ReadRegister (u8 address)
{
    208c:	df 93       	push	r29
    208e:	cf 93       	push	r28
    2090:	00 d0       	rcall	.+0      	; 0x2092 <MCP2515_ReadRegister+0x6>
    2092:	cd b7       	in	r28, 0x3d	; 61
    2094:	de b7       	in	r29, 0x3e	; 62
    2096:	8a 83       	std	Y+2, r24	; 0x02
	u8 readValue=0;
    2098:	19 82       	std	Y+1, r1	; 0x01

	//catch bus
	SPI_ChipSelect(1);
    209a:	81 e0       	ldi	r24, 0x01	; 1
    209c:	0e 94 a4 11 	call	0x2348	; 0x2348 <SPI_ChipSelect>
	
	// read instrunction to can read register MCP
	SPI_MasterTransmit(READ_INSTRUCTION); 
    20a0:	83 e0       	ldi	r24, 0x03	; 3
    20a2:	0e 94 77 0c 	call	0x18ee	; 0x18ee <SPI_MasterTransmit>
	//sending address register of mcp
	SPI_MasterTransmit(address); 
    20a6:	8a 81       	ldd	r24, Y+2	; 0x02
    20a8:	0e 94 77 0c 	call	0x18ee	; 0x18ee <SPI_MasterTransmit>
	//dont care sending data but we recieve data out
	readValue=SPI_MasterTransmit(0);
    20ac:	80 e0       	ldi	r24, 0x00	; 0
    20ae:	0e 94 77 0c 	call	0x18ee	; 0x18ee <SPI_MasterTransmit>
    20b2:	89 83       	std	Y+1, r24	; 0x01
	
	//leave bus
	SPI_ChipSelect(0);
    20b4:	80 e0       	ldi	r24, 0x00	; 0
    20b6:	0e 94 a4 11 	call	0x2348	; 0x2348 <SPI_ChipSelect>
	return readValue;
    20ba:	89 81       	ldd	r24, Y+1	; 0x01
}
    20bc:	0f 90       	pop	r0
    20be:	0f 90       	pop	r0
    20c0:	cf 91       	pop	r28
    20c2:	df 91       	pop	r29
    20c4:	08 95       	ret

000020c6 <MCP2515_bufferGet>:
void MCP2515_bufferGet (u8*buff)
{
    20c6:	df 93       	push	r29
    20c8:	cf 93       	push	r28
    20ca:	00 d0       	rcall	.+0      	; 0x20cc <MCP2515_bufferGet+0x6>
    20cc:	0f 92       	push	r0
    20ce:	cd b7       	in	r28, 0x3d	; 61
    20d0:	de b7       	in	r29, 0x3e	; 62
    20d2:	9b 83       	std	Y+3, r25	; 0x03
    20d4:	8a 83       	std	Y+2, r24	; 0x02
	for (u8 i=0;i<14;i++)
    20d6:	19 82       	std	Y+1, r1	; 0x01
    20d8:	13 c0       	rjmp	.+38     	; 0x2100 <MCP2515_bufferGet+0x3a>
	{
		buff[i]=buffer[i];
    20da:	89 81       	ldd	r24, Y+1	; 0x01
    20dc:	28 2f       	mov	r18, r24
    20de:	30 e0       	ldi	r19, 0x00	; 0
    20e0:	8a 81       	ldd	r24, Y+2	; 0x02
    20e2:	9b 81       	ldd	r25, Y+3	; 0x03
    20e4:	dc 01       	movw	r26, r24
    20e6:	a2 0f       	add	r26, r18
    20e8:	b3 1f       	adc	r27, r19
    20ea:	89 81       	ldd	r24, Y+1	; 0x01
    20ec:	88 2f       	mov	r24, r24
    20ee:	90 e0       	ldi	r25, 0x00	; 0
    20f0:	fc 01       	movw	r30, r24
    20f2:	ee 54       	subi	r30, 0x4E	; 78
    20f4:	fd 4f       	sbci	r31, 0xFD	; 253
    20f6:	80 81       	ld	r24, Z
    20f8:	8c 93       	st	X, r24
	SPI_ChipSelect(0);
	return readValue;
}
void MCP2515_bufferGet (u8*buff)
{
	for (u8 i=0;i<14;i++)
    20fa:	89 81       	ldd	r24, Y+1	; 0x01
    20fc:	8f 5f       	subi	r24, 0xFF	; 255
    20fe:	89 83       	std	Y+1, r24	; 0x01
    2100:	89 81       	ldd	r24, Y+1	; 0x01
    2102:	8e 30       	cpi	r24, 0x0E	; 14
    2104:	50 f3       	brcs	.-44     	; 0x20da <MCP2515_bufferGet+0x14>
	{
		buff[i]=buffer[i];
	}
}
    2106:	0f 90       	pop	r0
    2108:	0f 90       	pop	r0
    210a:	0f 90       	pop	r0
    210c:	cf 91       	pop	r28
    210e:	df 91       	pop	r29
    2110:	08 95       	ret

00002112 <MCP2515_WriteRegister>:
void MCP2515_WriteRegister (u8 address,u8 data )
{
    2112:	df 93       	push	r29
    2114:	cf 93       	push	r28
    2116:	00 d0       	rcall	.+0      	; 0x2118 <MCP2515_WriteRegister+0x6>
    2118:	cd b7       	in	r28, 0x3d	; 61
    211a:	de b7       	in	r29, 0x3e	; 62
    211c:	89 83       	std	Y+1, r24	; 0x01
    211e:	6a 83       	std	Y+2, r22	; 0x02
	//catch bus
	SPI_ChipSelect(1);
    2120:	81 e0       	ldi	r24, 0x01	; 1
    2122:	0e 94 a4 11 	call	0x2348	; 0x2348 <SPI_ChipSelect>
	// Write instrunction to can write on register MCP
	SPI_MasterTransmit(WRITE_INSTRUCTION);
    2126:	82 e0       	ldi	r24, 0x02	; 2
    2128:	0e 94 77 0c 	call	0x18ee	; 0x18ee <SPI_MasterTransmit>
	//sending address register of mcp
	SPI_MasterTransmit(address);
    212c:	89 81       	ldd	r24, Y+1	; 0x01
    212e:	0e 94 77 0c 	call	0x18ee	; 0x18ee <SPI_MasterTransmit>
	//send data to register 
	SPI_MasterTransmit(data);
    2132:	8a 81       	ldd	r24, Y+2	; 0x02
    2134:	0e 94 77 0c 	call	0x18ee	; 0x18ee <SPI_MasterTransmit>
	//leave bus
	SPI_ChipSelect(0);
    2138:	80 e0       	ldi	r24, 0x00	; 0
    213a:	0e 94 a4 11 	call	0x2348	; 0x2348 <SPI_ChipSelect>
}
    213e:	0f 90       	pop	r0
    2140:	0f 90       	pop	r0
    2142:	cf 91       	pop	r28
    2144:	df 91       	pop	r29
    2146:	08 95       	ret

00002148 <MCP2515_Reset>:
void MCP2515_Reset (void)
{
    2148:	df 93       	push	r29
    214a:	cf 93       	push	r28
    214c:	cd b7       	in	r28, 0x3d	; 61
    214e:	de b7       	in	r29, 0x3e	; 62
	//catch bus
	SPI_ChipSelect(1);
    2150:	81 e0       	ldi	r24, 0x01	; 1
    2152:	0e 94 a4 11 	call	0x2348	; 0x2348 <SPI_ChipSelect>
	
	// instrunction reset
	SPI_MasterTransmit(RESET_INSTRUCTION);
    2156:	80 ec       	ldi	r24, 0xC0	; 192
    2158:	0e 94 77 0c 	call	0x18ee	; 0x18ee <SPI_MasterTransmit>
	
	//leave bus
	SPI_ChipSelect(0);
    215c:	80 e0       	ldi	r24, 0x00	; 0
    215e:	0e 94 a4 11 	call	0x2348	; 0x2348 <SPI_ChipSelect>

}
    2162:	cf 91       	pop	r28
    2164:	df 91       	pop	r29
    2166:	08 95       	ret

00002168 <MCP2515_Modify>:
void MCP2515_Modify (u8 address,u8 mask,u8 data )
{
    2168:	df 93       	push	r29
    216a:	cf 93       	push	r28
    216c:	00 d0       	rcall	.+0      	; 0x216e <MCP2515_Modify+0x6>
    216e:	0f 92       	push	r0
    2170:	cd b7       	in	r28, 0x3d	; 61
    2172:	de b7       	in	r29, 0x3e	; 62
    2174:	89 83       	std	Y+1, r24	; 0x01
    2176:	6a 83       	std	Y+2, r22	; 0x02
    2178:	4b 83       	std	Y+3, r20	; 0x03
	//catch bus
	SPI_ChipSelect(1);
    217a:	81 e0       	ldi	r24, 0x01	; 1
    217c:	0e 94 a4 11 	call	0x2348	; 0x2348 <SPI_ChipSelect>
	
	// instrunction MODIFY
	SPI_MasterTransmit(MODIFY_INSTRUCTION);
    2180:	85 e0       	ldi	r24, 0x05	; 5
    2182:	0e 94 77 0c 	call	0x18ee	; 0x18ee <SPI_MasterTransmit>
	//sending address register of mcp
	SPI_MasterTransmit(address);
    2186:	89 81       	ldd	r24, Y+1	; 0x01
    2188:	0e 94 77 0c 	call	0x18ee	; 0x18ee <SPI_MasterTransmit>
	// send maskable byte
	SPI_MasterTransmit(mask);
    218c:	8a 81       	ldd	r24, Y+2	; 0x02
    218e:	0e 94 77 0c 	call	0x18ee	; 0x18ee <SPI_MasterTransmit>
	// send data will be maksed
	SPI_MasterTransmit(data);
    2192:	8b 81       	ldd	r24, Y+3	; 0x03
    2194:	0e 94 77 0c 	call	0x18ee	; 0x18ee <SPI_MasterTransmit>
	
	//leave bus
	SPI_ChipSelect(0);
    2198:	80 e0       	ldi	r24, 0x00	; 0
    219a:	0e 94 a4 11 	call	0x2348	; 0x2348 <SPI_ChipSelect>
}
    219e:	0f 90       	pop	r0
    21a0:	0f 90       	pop	r0
    21a2:	0f 90       	pop	r0
    21a4:	cf 91       	pop	r28
    21a6:	df 91       	pop	r29
    21a8:	08 95       	ret

000021aa <MCP2515_SetBitTiming>:
void MCP2515_SetBitTiming (u8 CNF1Value,u8 CNF2Value,u8 CNF3Value)
{
    21aa:	df 93       	push	r29
    21ac:	cf 93       	push	r28
    21ae:	00 d0       	rcall	.+0      	; 0x21b0 <MCP2515_SetBitTiming+0x6>
    21b0:	0f 92       	push	r0
    21b2:	cd b7       	in	r28, 0x3d	; 61
    21b4:	de b7       	in	r29, 0x3e	; 62
    21b6:	89 83       	std	Y+1, r24	; 0x01
    21b8:	6a 83       	std	Y+2, r22	; 0x02
    21ba:	4b 83       	std	Y+3, r20	; 0x03
	MCP2515_WriteRegister(CNF1,CNF1Value);
    21bc:	8a e2       	ldi	r24, 0x2A	; 42
    21be:	69 81       	ldd	r22, Y+1	; 0x01
    21c0:	0e 94 89 10 	call	0x2112	; 0x2112 <MCP2515_WriteRegister>
	MCP2515_WriteRegister(CNF2,CNF2Value);
    21c4:	89 e2       	ldi	r24, 0x29	; 41
    21c6:	6a 81       	ldd	r22, Y+2	; 0x02
    21c8:	0e 94 89 10 	call	0x2112	; 0x2112 <MCP2515_WriteRegister>
	MCP2515_WriteRegister(CNF3,CNF3Value);
    21cc:	88 e2       	ldi	r24, 0x28	; 40
    21ce:	6b 81       	ldd	r22, Y+3	; 0x03
    21d0:	0e 94 89 10 	call	0x2112	; 0x2112 <MCP2515_WriteRegister>
}
    21d4:	0f 90       	pop	r0
    21d6:	0f 90       	pop	r0
    21d8:	0f 90       	pop	r0
    21da:	cf 91       	pop	r28
    21dc:	df 91       	pop	r29
    21de:	08 95       	ret

000021e0 <MCP2515_SetMode>:
void MCP2515_SetMode (u8 mode)
{
    21e0:	df 93       	push	r29
    21e2:	cf 93       	push	r28
    21e4:	0f 92       	push	r0
    21e6:	cd b7       	in	r28, 0x3d	; 61
    21e8:	de b7       	in	r29, 0x3e	; 62
    21ea:	89 83       	std	Y+1, r24	; 0x01
	MCP2515_Modify(CANCTRL,0xE0,mode<<5);//E for change last 3 bits only and shift 5 to get last 5 bits 
    21ec:	89 81       	ldd	r24, Y+1	; 0x01
    21ee:	98 2f       	mov	r25, r24
    21f0:	92 95       	swap	r25
    21f2:	99 0f       	add	r25, r25
    21f4:	90 7e       	andi	r25, 0xE0	; 224
    21f6:	8f e0       	ldi	r24, 0x0F	; 15
    21f8:	60 ee       	ldi	r22, 0xE0	; 224
    21fa:	49 2f       	mov	r20, r25
    21fc:	0e 94 b4 10 	call	0x2168	; 0x2168 <MCP2515_Modify>
	
	while ((MCP2515_ReadRegister(CANSTAT)>>5)!=mode);  // to check if we selected right mode its additional 
    2200:	8e e0       	ldi	r24, 0x0E	; 14
    2202:	0e 94 46 10 	call	0x208c	; 0x208c <MCP2515_ReadRegister>
    2206:	98 2f       	mov	r25, r24
    2208:	92 95       	swap	r25
    220a:	96 95       	lsr	r25
    220c:	97 70       	andi	r25, 0x07	; 7
    220e:	89 81       	ldd	r24, Y+1	; 0x01
    2210:	98 17       	cp	r25, r24
    2212:	b1 f7       	brne	.-20     	; 0x2200 <MCP2515_SetMode+0x20>
	
}
    2214:	0f 90       	pop	r0
    2216:	cf 91       	pop	r28
    2218:	df 91       	pop	r29
    221a:	08 95       	ret

0000221c <MCP2515_TransmiterInit>:
void MCP2515_TransmiterInit(void)
{
    221c:	df 93       	push	r29
    221e:	cf 93       	push	r28
    2220:	cd b7       	in	r28, 0x3d	; 61
    2222:	de b7       	in	r29, 0x3e	; 62
	//spi master init
	SPI_ChipSelect(0);
    2224:	80 e0       	ldi	r24, 0x00	; 0
    2226:	0e 94 a4 11 	call	0x2348	; 0x2348 <SPI_ChipSelect>
	SPI_MasterCan_Init();
    222a:	0e 94 19 0c 	call	0x1832	; 0x1832 <SPI_MasterCan_Init>
    
	//reset  mcp
	MCP2515_Reset();
    222e:	0e 94 a4 10 	call	0x2148	; 0x2148 <MCP2515_Reset>
	
	//to select config mode and enable clock 
    MCP2515_WriteRegister(CANCTRL,0x84);
    2232:	8f e0       	ldi	r24, 0x0F	; 15
    2234:	64 e8       	ldi	r22, 0x84	; 132
    2236:	0e 94 89 10 	call	0x2112	; 0x2112 <MCP2515_WriteRegister>
	while ((MCP2515_ReadRegister(CANSTAT)>>5)!=CFG_MODE);  // to check if we selected right mode its additional
    223a:	8e e0       	ldi	r24, 0x0E	; 14
    223c:	0e 94 46 10 	call	0x208c	; 0x208c <MCP2515_ReadRegister>
    2240:	82 95       	swap	r24
    2242:	86 95       	lsr	r24
    2244:	87 70       	andi	r24, 0x07	; 7
    2246:	84 30       	cpi	r24, 0x04	; 4
    2248:	c1 f7       	brne	.-16     	; 0x223a <MCP2515_TransmiterInit+0x1e>
	
	//select bit timing
	MCP2515_SetBitTiming((2<<6),(1<<7)|(6<<3)|(1),(5));   //cnf1-> 0b1000000   01 for 3 TQ,cnf2 
    224a:	80 e8       	ldi	r24, 0x80	; 128
    224c:	61 eb       	ldi	r22, 0xB1	; 177
    224e:	45 e0       	ldi	r20, 0x05	; 5
    2250:	0e 94 d5 10 	call	0x21aa	; 0x21aa <MCP2515_SetBitTiming>
	MCP2515_SetMode(NORMAL_MODE);
    2254:	80 e0       	ldi	r24, 0x00	; 0
    2256:	0e 94 f0 10 	call	0x21e0	; 0x21e0 <MCP2515_SetMode>
	//MCP2515_SetMode(LOOP_BACK_MODE); //loop back testing
}
    225a:	cf 91       	pop	r28
    225c:	df 91       	pop	r29
    225e:	08 95       	ret

00002260 <MCP2515_SendMessage>:
void MCP2515_SendMessage(u8 bufId,u32 msgId,u8 dcl,u8*data)
{
    2260:	0f 93       	push	r16
    2262:	1f 93       	push	r17
    2264:	df 93       	push	r29
    2266:	cf 93       	push	r28
    2268:	cd b7       	in	r28, 0x3d	; 61
    226a:	de b7       	in	r29, 0x3e	; 62
    226c:	29 97       	sbiw	r28, 0x09	; 9
    226e:	0f b6       	in	r0, 0x3f	; 63
    2270:	f8 94       	cli
    2272:	de bf       	out	0x3e, r29	; 62
    2274:	0f be       	out	0x3f, r0	; 63
    2276:	cd bf       	out	0x3d, r28	; 61
    2278:	8a 83       	std	Y+2, r24	; 0x02
    227a:	4b 83       	std	Y+3, r20	; 0x03
    227c:	5c 83       	std	Y+4, r21	; 0x04
    227e:	6d 83       	std	Y+5, r22	; 0x05
    2280:	7e 83       	std	Y+6, r23	; 0x06
    2282:	2f 83       	std	Y+7, r18	; 0x07
    2284:	19 87       	std	Y+9, r17	; 0x09
    2286:	08 87       	std	Y+8, r16	; 0x08
	//catch bus
	SPI_ChipSelect(1);
    2288:	81 e0       	ldi	r24, 0x01	; 1
    228a:	0e 94 a4 11 	call	0x2348	; 0x2348 <SPI_ChipSelect>
	//write register
	SPI_MasterTransmit(WRITE_INSTRUCTION);
    228e:	82 e0       	ldi	r24, 0x02	; 2
    2290:	0e 94 77 0c 	call	0x18ee	; 0x18ee <SPI_MasterTransmit>
	//Send address first address on buffer
		SPI_MasterTransmit(TXB0CTRL);
    2294:	80 e3       	ldi	r24, 0x30	; 48
    2296:	0e 94 77 0c 	call	0x18ee	; 0x18ee <SPI_MasterTransmit>

	//setup priority  "mandatory"
	SPI_MasterTransmit(dcl>>6); 
    229a:	8f 81       	ldd	r24, Y+7	; 0x07
    229c:	82 95       	swap	r24
    229e:	86 95       	lsr	r24
    22a0:	86 95       	lsr	r24
    22a2:	83 70       	andi	r24, 0x03	; 3
    22a4:	0e 94 77 0c 	call	0x18ee	; 0x18ee <SPI_MasterTransmit>
	//send msgid
	SPI_MasterTransmit((u8)(msgId>>3)); //last 8 bits
    22a8:	8b 81       	ldd	r24, Y+3	; 0x03
    22aa:	9c 81       	ldd	r25, Y+4	; 0x04
    22ac:	ad 81       	ldd	r26, Y+5	; 0x05
    22ae:	be 81       	ldd	r27, Y+6	; 0x06
    22b0:	68 94       	set
    22b2:	12 f8       	bld	r1, 2
    22b4:	b6 95       	lsr	r27
    22b6:	a7 95       	ror	r26
    22b8:	97 95       	ror	r25
    22ba:	87 95       	ror	r24
    22bc:	16 94       	lsr	r1
    22be:	d1 f7       	brne	.-12     	; 0x22b4 <MCP2515_SendMessage+0x54>
    22c0:	0e 94 77 0c 	call	0x18ee	; 0x18ee <SPI_MasterTransmit>
	SPI_MasterTransmit((u8)(msgId<<5)); //first 3 bits
    22c4:	8b 81       	ldd	r24, Y+3	; 0x03
    22c6:	82 95       	swap	r24
    22c8:	88 0f       	add	r24, r24
    22ca:	80 7e       	andi	r24, 0xE0	; 224
    22cc:	0e 94 77 0c 	call	0x18ee	; 0x18ee <SPI_MasterTransmit>
	//no there externalID
	SPI_MasterTransmit(0);
    22d0:	80 e0       	ldi	r24, 0x00	; 0
    22d2:	0e 94 77 0c 	call	0x18ee	; 0x18ee <SPI_MasterTransmit>
	SPI_MasterTransmit(0);
    22d6:	80 e0       	ldi	r24, 0x00	; 0
    22d8:	0e 94 77 0c 	call	0x18ee	; 0x18ee <SPI_MasterTransmit>
    //send dcl
	SPI_MasterTransmit(dcl&0x0f);
    22dc:	8f 81       	ldd	r24, Y+7	; 0x07
    22de:	8f 70       	andi	r24, 0x0F	; 15
    22e0:	0e 94 77 0c 	call	0x18ee	; 0x18ee <SPI_MasterTransmit>
	//send data
	for (u8 i=0;i<(dcl&0x0f);i++)
    22e4:	19 82       	std	Y+1, r1	; 0x01
    22e6:	0e c0       	rjmp	.+28     	; 0x2304 <MCP2515_SendMessage+0xa4>
	{
		SPI_MasterTransmit(data[i]);
    22e8:	89 81       	ldd	r24, Y+1	; 0x01
    22ea:	28 2f       	mov	r18, r24
    22ec:	30 e0       	ldi	r19, 0x00	; 0
    22ee:	88 85       	ldd	r24, Y+8	; 0x08
    22f0:	99 85       	ldd	r25, Y+9	; 0x09
    22f2:	fc 01       	movw	r30, r24
    22f4:	e2 0f       	add	r30, r18
    22f6:	f3 1f       	adc	r31, r19
    22f8:	80 81       	ld	r24, Z
    22fa:	0e 94 77 0c 	call	0x18ee	; 0x18ee <SPI_MasterTransmit>
	SPI_MasterTransmit(0);
	SPI_MasterTransmit(0);
    //send dcl
	SPI_MasterTransmit(dcl&0x0f);
	//send data
	for (u8 i=0;i<(dcl&0x0f);i++)
    22fe:	89 81       	ldd	r24, Y+1	; 0x01
    2300:	8f 5f       	subi	r24, 0xFF	; 255
    2302:	89 83       	std	Y+1, r24	; 0x01
    2304:	89 81       	ldd	r24, Y+1	; 0x01
    2306:	28 2f       	mov	r18, r24
    2308:	30 e0       	ldi	r19, 0x00	; 0
    230a:	8f 81       	ldd	r24, Y+7	; 0x07
    230c:	88 2f       	mov	r24, r24
    230e:	90 e0       	ldi	r25, 0x00	; 0
    2310:	8f 70       	andi	r24, 0x0F	; 15
    2312:	90 70       	andi	r25, 0x00	; 0
    2314:	28 17       	cp	r18, r24
    2316:	39 07       	cpc	r19, r25
    2318:	3c f3       	brlt	.-50     	; 0x22e8 <MCP2515_SendMessage+0x88>
	{
		SPI_MasterTransmit(data[i]);
	}
	//leave bus
	SPI_ChipSelect(0);
    231a:	80 e0       	ldi	r24, 0x00	; 0
    231c:	0e 94 a4 11 	call	0x2348	; 0x2348 <SPI_ChipSelect>
	//here you can send anothers buffers.....
	
	SPI_ChipSelect(1);
    2320:	81 e0       	ldi	r24, 0x01	; 1
    2322:	0e 94 a4 11 	call	0x2348	; 0x2348 <SPI_ChipSelect>
	//send request to send for buffer 0
	SPI_MasterTransmit(REQUEST_TO_SEND_B0);
    2326:	81 e8       	ldi	r24, 0x81	; 129
    2328:	0e 94 77 0c 	call	0x18ee	; 0x18ee <SPI_MasterTransmit>
	SPI_ChipSelect(0);
    232c:	80 e0       	ldi	r24, 0x00	; 0
    232e:	0e 94 a4 11 	call	0x2348	; 0x2348 <SPI_ChipSelect>
	
	
}
    2332:	29 96       	adiw	r28, 0x09	; 9
    2334:	0f b6       	in	r0, 0x3f	; 63
    2336:	f8 94       	cli
    2338:	de bf       	out	0x3e, r29	; 62
    233a:	0f be       	out	0x3f, r0	; 63
    233c:	cd bf       	out	0x3d, r28	; 61
    233e:	cf 91       	pop	r28
    2340:	df 91       	pop	r29
    2342:	1f 91       	pop	r17
    2344:	0f 91       	pop	r16
    2346:	08 95       	ret

00002348 <SPI_ChipSelect>:


void SPI_ChipSelect (u8 state)
{
    2348:	df 93       	push	r29
    234a:	cf 93       	push	r28
    234c:	0f 92       	push	r0
    234e:	cd b7       	in	r28, 0x3d	; 61
    2350:	de b7       	in	r29, 0x3e	; 62
    2352:	89 83       	std	Y+1, r24	; 0x01
	if (state==1)
    2354:	89 81       	ldd	r24, Y+1	; 0x01
    2356:	81 30       	cpi	r24, 0x01	; 1
    2358:	29 f4       	brne	.+10     	; 0x2364 <SPI_ChipSelect+0x1c>
	{
		Dio_WriteChannel(SPI_SS_PIN,LOW);
    235a:	88 e0       	ldi	r24, 0x08	; 8
    235c:	60 e0       	ldi	r22, 0x00	; 0
    235e:	0e 94 42 0d 	call	0x1a84	; 0x1a84 <Dio_WriteChannel>
    2362:	04 c0       	rjmp	.+8      	; 0x236c <SPI_ChipSelect+0x24>
	}
	else
	{
		Dio_WriteChannel(SPI_SS_PIN,HIGH);
    2364:	88 e0       	ldi	r24, 0x08	; 8
    2366:	61 e0       	ldi	r22, 0x01	; 1
    2368:	0e 94 42 0d 	call	0x1a84	; 0x1a84 <Dio_WriteChannel>
	}
}
    236c:	0f 90       	pop	r0
    236e:	cf 91       	pop	r28
    2370:	df 91       	pop	r29
    2372:	08 95       	ret

00002374 <MCP2515_SetMask>:

/*receiver */
void MCP2515_SetMask (u8 address,u32 value,u8 extendedFlag)
{
    2374:	df 93       	push	r29
    2376:	cf 93       	push	r28
    2378:	00 d0       	rcall	.+0      	; 0x237a <MCP2515_SetMask+0x6>
    237a:	00 d0       	rcall	.+0      	; 0x237c <MCP2515_SetMask+0x8>
    237c:	00 d0       	rcall	.+0      	; 0x237e <MCP2515_SetMask+0xa>
    237e:	cd b7       	in	r28, 0x3d	; 61
    2380:	de b7       	in	r29, 0x3e	; 62
    2382:	89 83       	std	Y+1, r24	; 0x01
    2384:	4a 83       	std	Y+2, r20	; 0x02
    2386:	5b 83       	std	Y+3, r21	; 0x03
    2388:	6c 83       	std	Y+4, r22	; 0x04
    238a:	7d 83       	std	Y+5, r23	; 0x05
    238c:	2e 83       	std	Y+6, r18	; 0x06
	//catch bus
	SPI_ChipSelect(1);
    238e:	81 e0       	ldi	r24, 0x01	; 1
    2390:	0e 94 a4 11 	call	0x2348	; 0x2348 <SPI_ChipSelect>
	SPI_MasterTransmit(WRITE_INSTRUCTION);
    2394:	82 e0       	ldi	r24, 0x02	; 2
    2396:	0e 94 77 0c 	call	0x18ee	; 0x18ee <SPI_MasterTransmit>
	SPI_MasterTransmit(address);
    239a:	89 81       	ldd	r24, Y+1	; 0x01
    239c:	0e 94 77 0c 	call	0x18ee	; 0x18ee <SPI_MasterTransmit>
	
	if (extendedFlag)
    23a0:	8e 81       	ldd	r24, Y+6	; 0x06
    23a2:	88 23       	and	r24, r24
    23a4:	b9 f1       	breq	.+110    	; 0x2414 <MCP2515_SetMask+0xa0>
	{
		SPI_MasterTransmit((u8)(value>>3)); 
    23a6:	8a 81       	ldd	r24, Y+2	; 0x02
    23a8:	9b 81       	ldd	r25, Y+3	; 0x03
    23aa:	ac 81       	ldd	r26, Y+4	; 0x04
    23ac:	bd 81       	ldd	r27, Y+5	; 0x05
    23ae:	68 94       	set
    23b0:	12 f8       	bld	r1, 2
    23b2:	b6 95       	lsr	r27
    23b4:	a7 95       	ror	r26
    23b6:	97 95       	ror	r25
    23b8:	87 95       	ror	r24
    23ba:	16 94       	lsr	r1
    23bc:	d1 f7       	brne	.-12     	; 0x23b2 <MCP2515_SetMask+0x3e>
    23be:	0e 94 77 0c 	call	0x18ee	; 0x18ee <SPI_MasterTransmit>
		SPI_MasterTransmit((u8)(value<<5)|(1<<3)|(u8)(value>>27)); //first 3 bits and get last 3 bits  and enable extended
    23c2:	8a 81       	ldd	r24, Y+2	; 0x02
    23c4:	28 2f       	mov	r18, r24
    23c6:	22 95       	swap	r18
    23c8:	22 0f       	add	r18, r18
    23ca:	20 7e       	andi	r18, 0xE0	; 224
    23cc:	8a 81       	ldd	r24, Y+2	; 0x02
    23ce:	9b 81       	ldd	r25, Y+3	; 0x03
    23d0:	ac 81       	ldd	r26, Y+4	; 0x04
    23d2:	bd 81       	ldd	r27, Y+5	; 0x05
    23d4:	07 2e       	mov	r0, r23
    23d6:	7b e1       	ldi	r23, 0x1B	; 27
    23d8:	b6 95       	lsr	r27
    23da:	a7 95       	ror	r26
    23dc:	97 95       	ror	r25
    23de:	87 95       	ror	r24
    23e0:	7a 95       	dec	r23
    23e2:	d1 f7       	brne	.-12     	; 0x23d8 <MCP2515_SetMask+0x64>
    23e4:	70 2d       	mov	r23, r0
    23e6:	82 2b       	or	r24, r18
    23e8:	88 60       	ori	r24, 0x08	; 8
    23ea:	0e 94 77 0c 	call	0x18ee	; 0x18ee <SPI_MasterTransmit>
		SPI_MasterTransmit((u8)(value>>19)); 
    23ee:	8a 81       	ldd	r24, Y+2	; 0x02
    23f0:	9b 81       	ldd	r25, Y+3	; 0x03
    23f2:	ac 81       	ldd	r26, Y+4	; 0x04
    23f4:	bd 81       	ldd	r27, Y+5	; 0x05
    23f6:	07 2e       	mov	r0, r23
    23f8:	73 e1       	ldi	r23, 0x13	; 19
    23fa:	b6 95       	lsr	r27
    23fc:	a7 95       	ror	r26
    23fe:	97 95       	ror	r25
    2400:	87 95       	ror	r24
    2402:	7a 95       	dec	r23
    2404:	d1 f7       	brne	.-12     	; 0x23fa <MCP2515_SetMask+0x86>
    2406:	70 2d       	mov	r23, r0
    2408:	0e 94 77 0c 	call	0x18ee	; 0x18ee <SPI_MasterTransmit>
		SPI_MasterTransmit((u8)(value<<11)); 	
    240c:	80 e0       	ldi	r24, 0x00	; 0
    240e:	0e 94 77 0c 	call	0x18ee	; 0x18ee <SPI_MasterTransmit>
    2412:	14 c0       	rjmp	.+40     	; 0x243c <MCP2515_SetMask+0xc8>
	}
	else
	{
		SPI_MasterTransmit((u8)(value>>3)); //last 8 bits
    2414:	8a 81       	ldd	r24, Y+2	; 0x02
    2416:	9b 81       	ldd	r25, Y+3	; 0x03
    2418:	ac 81       	ldd	r26, Y+4	; 0x04
    241a:	bd 81       	ldd	r27, Y+5	; 0x05
    241c:	68 94       	set
    241e:	12 f8       	bld	r1, 2
    2420:	b6 95       	lsr	r27
    2422:	a7 95       	ror	r26
    2424:	97 95       	ror	r25
    2426:	87 95       	ror	r24
    2428:	16 94       	lsr	r1
    242a:	d1 f7       	brne	.-12     	; 0x2420 <MCP2515_SetMask+0xac>
    242c:	0e 94 77 0c 	call	0x18ee	; 0x18ee <SPI_MasterTransmit>
		SPI_MasterTransmit((u8)(value<<5)); //first 3 bits
    2430:	8a 81       	ldd	r24, Y+2	; 0x02
    2432:	82 95       	swap	r24
    2434:	88 0f       	add	r24, r24
    2436:	80 7e       	andi	r24, 0xE0	; 224
    2438:	0e 94 77 0c 	call	0x18ee	; 0x18ee <SPI_MasterTransmit>
	}
	SPI_ChipSelect(0);	
    243c:	80 e0       	ldi	r24, 0x00	; 0
    243e:	0e 94 a4 11 	call	0x2348	; 0x2348 <SPI_ChipSelect>
}
    2442:	26 96       	adiw	r28, 0x06	; 6
    2444:	0f b6       	in	r0, 0x3f	; 63
    2446:	f8 94       	cli
    2448:	de bf       	out	0x3e, r29	; 62
    244a:	0f be       	out	0x3f, r0	; 63
    244c:	cd bf       	out	0x3d, r28	; 61
    244e:	cf 91       	pop	r28
    2450:	df 91       	pop	r29
    2452:	08 95       	ret

00002454 <MCP2515_receiverInit>:

void MCP2515_receiverInit(void)
{
    2454:	df 93       	push	r29
    2456:	cf 93       	push	r28
    2458:	cd b7       	in	r28, 0x3d	; 61
    245a:	de b7       	in	r29, 0x3e	; 62
	//spi master init
	SPI_ChipSelect(0);
    245c:	80 e0       	ldi	r24, 0x00	; 0
    245e:	0e 94 a4 11 	call	0x2348	; 0x2348 <SPI_ChipSelect>
	SPI_MasterCan_Init();
    2462:	0e 94 19 0c 	call	0x1832	; 0x1832 <SPI_MasterCan_Init>
	//reset  mcp
	MCP2515_Reset();
    2466:	0e 94 a4 10 	call	0x2148	; 0x2148 <MCP2515_Reset>
	//to select config mode and enable clock
	MCP2515_WriteRegister(CANCTRL,0x84);
    246a:	8f e0       	ldi	r24, 0x0F	; 15
    246c:	64 e8       	ldi	r22, 0x84	; 132
    246e:	0e 94 89 10 	call	0x2112	; 0x2112 <MCP2515_WriteRegister>
	while ((MCP2515_ReadRegister(CANSTAT)>>5)!=CFG_MODE);  // to check if we selected right mode its additional
    2472:	8e e0       	ldi	r24, 0x0E	; 14
    2474:	0e 94 46 10 	call	0x208c	; 0x208c <MCP2515_ReadRegister>
    2478:	82 95       	swap	r24
    247a:	86 95       	lsr	r24
    247c:	87 70       	andi	r24, 0x07	; 7
    247e:	84 30       	cpi	r24, 0x04	; 4
    2480:	c1 f7       	brne	.-16     	; 0x2472 <MCP2515_receiverInit+0x1e>
	//select bit timing
	MCP2515_SetBitTiming(0x80,0xb1,0x5);   //cnf1-> 0b1000000   01 for 3 TQ,cnf2
    2482:	80 e8       	ldi	r24, 0x80	; 128
    2484:	61 eb       	ldi	r22, 0xB1	; 177
    2486:	45 e0       	ldi	r20, 0x05	; 5
    2488:	0e 94 d5 10 	call	0x21aa	; 0x21aa <MCP2515_SetBitTiming>
	// set mask all msgs accepted
	MCP2515_SetMask(RXM0SIDH,MASK_RXB0,1);
    248c:	80 e2       	ldi	r24, 0x20	; 32
    248e:	40 e0       	ldi	r20, 0x00	; 0
    2490:	50 e0       	ldi	r21, 0x00	; 0
    2492:	60 e0       	ldi	r22, 0x00	; 0
    2494:	70 e0       	ldi	r23, 0x00	; 0
    2496:	21 e0       	ldi	r18, 0x01	; 1
    2498:	0e 94 ba 11 	call	0x2374	; 0x2374 <MCP2515_SetMask>
	MCP2515_SetMask(RXM1SIDH,MASK_RXB1,1);
    249c:	84 e2       	ldi	r24, 0x24	; 36
    249e:	40 e0       	ldi	r20, 0x00	; 0
    24a0:	50 e0       	ldi	r21, 0x00	; 0
    24a2:	60 e0       	ldi	r22, 0x00	; 0
    24a4:	70 e0       	ldi	r23, 0x00	; 0
    24a6:	21 e0       	ldi	r18, 0x01	; 1
    24a8:	0e 94 ba 11 	call	0x2374	; 0x2374 <MCP2515_SetMask>
	//enable interrupt rx
	MCP2515_WriteRegister(CANINTE,1<<0);
    24ac:	8b e2       	ldi	r24, 0x2B	; 43
    24ae:	61 e0       	ldi	r22, 0x01	; 1
    24b0:	0e 94 89 10 	call	0x2112	; 0x2112 <MCP2515_WriteRegister>
	
	MCP2515_SetMode(NORMAL_MODE);
    24b4:	80 e0       	ldi	r24, 0x00	; 0
    24b6:	0e 94 f0 10 	call	0x21e0	; 0x21e0 <MCP2515_SetMode>
	//MCP2515_SetMode(LOOP_BACK_MODE); //loop back testing
	
}
    24ba:	cf 91       	pop	r28
    24bc:	df 91       	pop	r29
    24be:	08 95       	ret

000024c0 <MCP2515_receiverB0>:

void MCP2515_receiverB0 (void)
{
    24c0:	0f 93       	push	r16
    24c2:	1f 93       	push	r17
    24c4:	df 93       	push	r29
    24c6:	cf 93       	push	r28
    24c8:	0f 92       	push	r0
    24ca:	cd b7       	in	r28, 0x3d	; 61
    24cc:	de b7       	in	r29, 0x3e	; 62
	//catch bus
	SPI_ChipSelect(1);
    24ce:	81 e0       	ldi	r24, 0x01	; 1
    24d0:	0e 94 a4 11 	call	0x2348	; 0x2348 <SPI_ChipSelect>
	SPI_MasterTransmit(READ_INSTRUCTION);
    24d4:	83 e0       	ldi	r24, 0x03	; 3
    24d6:	0e 94 77 0c 	call	0x18ee	; 0x18ee <SPI_MasterTransmit>
	SPI_MasterTransmit(RXB0CTRL);
    24da:	80 e6       	ldi	r24, 0x60	; 96
    24dc:	0e 94 77 0c 	call	0x18ee	; 0x18ee <SPI_MasterTransmit>
	for (u8 i=0 ;i<14;i++)
    24e0:	19 82       	std	Y+1, r1	; 0x01
    24e2:	0d c0       	rjmp	.+26     	; 0x24fe <MCP2515_receiverB0+0x3e>
	{
		buffer[i]=SPI_MasterTransmit(0);
    24e4:	89 81       	ldd	r24, Y+1	; 0x01
    24e6:	08 2f       	mov	r16, r24
    24e8:	10 e0       	ldi	r17, 0x00	; 0
    24ea:	80 e0       	ldi	r24, 0x00	; 0
    24ec:	0e 94 77 0c 	call	0x18ee	; 0x18ee <SPI_MasterTransmit>
    24f0:	f8 01       	movw	r30, r16
    24f2:	ee 54       	subi	r30, 0x4E	; 78
    24f4:	fd 4f       	sbci	r31, 0xFD	; 253
    24f6:	80 83       	st	Z, r24
{
	//catch bus
	SPI_ChipSelect(1);
	SPI_MasterTransmit(READ_INSTRUCTION);
	SPI_MasterTransmit(RXB0CTRL);
	for (u8 i=0 ;i<14;i++)
    24f8:	89 81       	ldd	r24, Y+1	; 0x01
    24fa:	8f 5f       	subi	r24, 0xFF	; 255
    24fc:	89 83       	std	Y+1, r24	; 0x01
    24fe:	89 81       	ldd	r24, Y+1	; 0x01
    2500:	8e 30       	cpi	r24, 0x0E	; 14
    2502:	80 f3       	brcs	.-32     	; 0x24e4 <MCP2515_receiverB0+0x24>
	{
		buffer[i]=SPI_MasterTransmit(0);
	}
	SPI_ChipSelect(0);
    2504:	80 e0       	ldi	r24, 0x00	; 0
    2506:	0e 94 a4 11 	call	0x2348	; 0x2348 <SPI_ChipSelect>
	//clear interrupt rx
	MCP2515_WriteRegister(CANINTF,0);
    250a:	8c e2       	ldi	r24, 0x2C	; 44
    250c:	60 e0       	ldi	r22, 0x00	; 0
    250e:	0e 94 89 10 	call	0x2112	; 0x2112 <MCP2515_WriteRegister>
}
    2512:	0f 90       	pop	r0
    2514:	cf 91       	pop	r28
    2516:	df 91       	pop	r29
    2518:	1f 91       	pop	r17
    251a:	0f 91       	pop	r16
    251c:	08 95       	ret

0000251e <RX_Interrupt>:
u8 motor_status ;

/*************************************************ISR FUNC******************************************/

void RX_Interrupt (void)
{
    251e:	df 93       	push	r29
    2520:	cf 93       	push	r28
    2522:	cd b7       	in	r28, 0x3d	; 61
    2524:	de b7       	in	r29, 0x3e	; 62
	//read UART buffer
	UART_DATA= UART_ReceiveNum(); //Read data with no block
    2526:	0e 94 d9 05 	call	0xbb2	; 0xbb2 <UART_ReceiveNum>
    252a:	80 93 c3 02 	sts	0x02C3, r24
	UART_FLAG=ENABLE;
    252e:	81 e0       	ldi	r24, 0x01	; 1
    2530:	80 93 c9 02 	sts	0x02C9, r24
}
    2534:	cf 91       	pop	r28
    2536:	df 91       	pop	r29
    2538:	08 95       	ret

0000253a <MOTOR_Init>:


/*********************************************Init & Runnble*******************************************/

void MOTOR_Init (void)
{
    253a:	df 93       	push	r29
    253c:	cf 93       	push	r28
    253e:	cd b7       	in	r28, 0x3d	; 61
    2540:	de b7       	in	r29, 0x3e	; 62
	Port_Init();
    2542:	0e 94 67 00 	call	0xce	; 0xce <Port_Init>
	while (Dio_ReadChannel(KEY_ACCESS_PIN)==DISABLE);// key access  off
    2546:	80 e1       	ldi	r24, 0x10	; 16
    2548:	0e 94 1b 0f 	call	0x1e36	; 0x1e36 <Dio_ReadChannel>
    254c:	88 23       	and	r24, r24
    254e:	d9 f3       	breq	.-10     	; 0x2546 <MOTOR_Init+0xc>
	TMR0_Init();
    2550:	0e 94 cf 06 	call	0xd9e	; 0xd9e <TMR0_Init>
	TMR0_Start();
    2554:	0e 94 16 07 	call	0xe2c	; 0xe2c <TMR0_Start>
	TIMER2_Init(TIMER2_PHASECORRECT_MODE,TIMER2_SCALER_64);
    2558:	81 e0       	ldi	r24, 0x01	; 1
    255a:	63 e0       	ldi	r22, 0x03	; 3
    255c:	0e 94 a1 07 	call	0xf42	; 0xf42 <TIMER2_Init>
	TIMER2_OC2Mode(OC2_NON_INVERTING);
    2560:	82 e0       	ldi	r24, 0x02	; 2
    2562:	0e 94 1c 08 	call	0x1038	; 0x1038 <TIMER2_OC2Mode>
 	UART_Init();
    2566:	0e 94 74 05 	call	0xae8	; 0xae8 <UART_Init>
    MCP2515_TransmiterInit();
    256a:	0e 94 0e 11 	call	0x221c	; 0x221c <MCP2515_TransmiterInit>
	MCP2515_receiverInit();
    256e:	0e 94 2a 12 	call	0x2454	; 0x2454 <MCP2515_receiverInit>
	UART_RX_SetCallBack(RX_Interrupt);
    2572:	8f e8       	ldi	r24, 0x8F	; 143
    2574:	92 e1       	ldi	r25, 0x12	; 18
    2576:	0e 94 21 06 	call	0xc42	; 0xc42 <UART_RX_SetCallBack>
	UART_RX_InterruptEnable();
    257a:	0e 94 e9 05 	call	0xbd2	; 0xbd2 <UART_RX_InterruptEnable>
	UART_Send_String("5/ACC ON - 6/ACC OFF - 7/lane on - 8/lane off - 9/save zone \r\n");
    257e:	80 e0       	ldi	r24, 0x00	; 0
    2580:	91 e0       	ldi	r25, 0x01	; 1
    2582:	0e 94 b0 05 	call	0xb60	; 0xb60 <UART_Send_String>

	
	
}
    2586:	cf 91       	pop	r28
    2588:	df 91       	pop	r29
    258a:	08 95       	ret

0000258c <UART_Get>:

void UART_Get (void)
{
    258c:	df 93       	push	r29
    258e:	cf 93       	push	r28
    2590:	cd b7       	in	r28, 0x3d	; 61
    2592:	de b7       	in	r29, 0x3e	; 62
	if (UART_FLAG==ENABLE) // if UART Received any data save it in (UART_DATA) And CLR the flag
    2594:	80 91 c9 02 	lds	r24, 0x02C9
    2598:	81 30       	cpi	r24, 0x01	; 1
    259a:	09 f0       	breq	.+2      	; 0x259e <UART_Get+0x12>
    259c:	45 c0       	rjmp	.+138    	; 0x2628 <UART_Get+0x9c>
	{
		
	if(UART_DATA<UART_MAX_NUM_MANUAL_MSG) //MANUAL_mode
    259e:	80 91 c3 02 	lds	r24, 0x02C3
    25a2:	85 30       	cpi	r24, 0x05	; 5
    25a4:	18 f4       	brcc	.+6      	; 0x25ac <UART_Get+0x20>
	{
		
		MANIUAL_FLAG = ENABLE ; 
    25a6:	81 e0       	ldi	r24, 0x01	; 1
    25a8:	80 93 c1 02 	sts	0x02C1, r24
		
	}
	if (UART_DATA==UART_ACC_ON_MSG) //ACC mode on
    25ac:	80 91 c3 02 	lds	r24, 0x02C3
    25b0:	85 30       	cpi	r24, 0x05	; 5
    25b2:	31 f4       	brne	.+12     	; 0x25c0 <UART_Get+0x34>
	{
		
		ACC_FLAG = ENABLE ; 
    25b4:	81 e0       	ldi	r24, 0x01	; 1
    25b6:	80 93 c8 02 	sts	0x02C8, r24
		LANE_KEEP_FLAG=ENABLE;
    25ba:	81 e0       	ldi	r24, 0x01	; 1
    25bc:	80 93 c6 02 	sts	0x02C6, r24
	}
	if(UART_DATA==UART_ACC_OFF_MSG) // ACC mode off
    25c0:	80 91 c3 02 	lds	r24, 0x02C3
    25c4:	86 30       	cpi	r24, 0x06	; 6
    25c6:	71 f4       	brne	.+28     	; 0x25e4 <UART_Get+0x58>
	{
		UART_Send_String("\r\n ACC IS OFF RETURN TO MANIUAL MODE \r\n");
    25c8:	8f e3       	ldi	r24, 0x3F	; 63
    25ca:	91 e0       	ldi	r25, 0x01	; 1
    25cc:	0e 94 b0 05 	call	0xb60	; 0xb60 <UART_Send_String>
		ACC_FLAG =DISABLE ;
    25d0:	10 92 c8 02 	sts	0x02C8, r1
		LANE_KEEP_FLAG=DISABLE;
    25d4:	10 92 c6 02 	sts	0x02C6, r1
		MANIUAL_FLAG=ENABLE;
    25d8:	81 e0       	ldi	r24, 0x01	; 1
    25da:	80 93 c1 02 	sts	0x02C1, r24
		msgReq1=ENABLE; //send msg acc
    25de:	81 e0       	ldi	r24, 0x01	; 1
    25e0:	80 93 c4 02 	sts	0x02C4, r24
	}
	if(UART_DATA==UART_LANE_ON_MSG) // lane keep on
    25e4:	80 91 c3 02 	lds	r24, 0x02C3
    25e8:	87 30       	cpi	r24, 0x07	; 7
    25ea:	61 f4       	brne	.+24     	; 0x2604 <UART_Get+0x78>
	{
		UART_Send_String("\r\n lanekeep on \r\n");
    25ec:	87 e6       	ldi	r24, 0x67	; 103
    25ee:	91 e0       	ldi	r25, 0x01	; 1
    25f0:	0e 94 b0 05 	call	0xb60	; 0xb60 <UART_Send_String>
		LANE_KEEP_FLAG =ENABLE ;
    25f4:	81 e0       	ldi	r24, 0x01	; 1
    25f6:	80 93 c6 02 	sts	0x02C6, r24
		MANIUAL_FLAG=DISABLE;
    25fa:	10 92 c1 02 	sts	0x02C1, r1
		msgReq2=ENABLE; //send msg lanekeep
    25fe:	81 e0       	ldi	r24, 0x01	; 1
    2600:	80 93 c7 02 	sts	0x02C7, r24
	}
	if(UART_DATA==UART_LANE_OFF_MSG) // lane keep off
    2604:	80 91 c3 02 	lds	r24, 0x02C3
    2608:	88 30       	cpi	r24, 0x08	; 8
    260a:	61 f4       	brne	.+24     	; 0x2624 <UART_Get+0x98>
	{
		UART_Send_String("\r\n lanekeep oFF \r\n");
    260c:	89 e7       	ldi	r24, 0x79	; 121
    260e:	91 e0       	ldi	r25, 0x01	; 1
    2610:	0e 94 b0 05 	call	0xb60	; 0xb60 <UART_Send_String>
		LANE_KEEP_FLAG=DISABLE;
    2614:	10 92 c6 02 	sts	0x02C6, r1
		MANIUAL_FLAG=ENABLE;
    2618:	81 e0       	ldi	r24, 0x01	; 1
    261a:	80 93 c1 02 	sts	0x02C1, r24
		msgReq2=ENABLE; //send msg lanekeep
    261e:	81 e0       	ldi	r24, 0x01	; 1
    2620:	80 93 c7 02 	sts	0x02C7, r24
	}
	UART_FLAG=DISABLE;	
    2624:	10 92 c9 02 	sts	0x02C9, r1
}
	
}
    2628:	cf 91       	pop	r28
    262a:	df 91       	pop	r29
    262c:	08 95       	ret

0000262e <CarDirection>:




void CarDirection (void)
{
    262e:	df 93       	push	r29
    2630:	cf 93       	push	r28
    2632:	00 d0       	rcall	.+0      	; 0x2634 <CarDirection+0x6>
    2634:	cd b7       	in	r28, 0x3d	; 61
    2636:	de b7       	in	r29, 0x3e	; 62
	
	if (MANIUAL_FLAG==ENABLE && ACC_FLAG == DISABLE)//IF  ACC Off
    2638:	80 91 c1 02 	lds	r24, 0x02C1
    263c:	81 30       	cpi	r24, 0x01	; 1
    263e:	49 f5       	brne	.+82     	; 0x2692 <CarDirection+0x64>
    2640:	80 91 c8 02 	lds	r24, 0x02C8
    2644:	88 23       	and	r24, r24
    2646:	29 f5       	brne	.+74     	; 0x2692 <CarDirection+0x64>
	{
		
		motor_status = UART_DATA ;
    2648:	80 91 c3 02 	lds	r24, 0x02C3
    264c:	80 93 c2 02 	sts	0x02C2, r24
		
		//motor_status from uart data
		switch (motor_status)
    2650:	80 91 c2 02 	lds	r24, 0x02C2
    2654:	28 2f       	mov	r18, r24
    2656:	30 e0       	ldi	r19, 0x00	; 0
    2658:	3a 83       	std	Y+2, r19	; 0x02
    265a:	29 83       	std	Y+1, r18	; 0x01
    265c:	89 81       	ldd	r24, Y+1	; 0x01
    265e:	9a 81       	ldd	r25, Y+2	; 0x02
    2660:	84 30       	cpi	r24, 0x04	; 4
    2662:	91 05       	cpc	r25, r1
    2664:	59 f0       	breq	.+22     	; 0x267c <CarDirection+0x4e>
    2666:	29 81       	ldd	r18, Y+1	; 0x01
    2668:	3a 81       	ldd	r19, Y+2	; 0x02
    266a:	29 30       	cpi	r18, 0x09	; 9
    266c:	31 05       	cpc	r19, r1
    266e:	71 f0       	breq	.+28     	; 0x268c <CarDirection+0x5e>
    2670:	89 81       	ldd	r24, Y+1	; 0x01
    2672:	9a 81       	ldd	r25, Y+2	; 0x02
    2674:	83 30       	cpi	r24, 0x03	; 3
    2676:	91 05       	cpc	r25, r1
    2678:	29 f0       	breq	.+10     	; 0x2684 <CarDirection+0x56>
    267a:	0b c0       	rjmp	.+22     	; 0x2692 <CarDirection+0x64>
		{
			
			case MOTOR_LEFT :  MOTOR_steering_Control (MOTOR_LEFT) ;   break;
    267c:	84 e0       	ldi	r24, 0x04	; 4
    267e:	0e 94 02 10 	call	0x2004	; 0x2004 <MOTOR_steering_Control>
    2682:	07 c0       	rjmp	.+14     	; 0x2692 <CarDirection+0x64>
			case MOTOR_RIGHT:  MOTOR_steering_Control (MOTOR_RIGHT) ;  break;
    2684:	83 e0       	ldi	r24, 0x03	; 3
    2686:	0e 94 02 10 	call	0x2004	; 0x2004 <MOTOR_steering_Control>
    268a:	03 c0       	rjmp	.+6      	; 0x2692 <CarDirection+0x64>
			case MOTOR_STRAIGHT:  MOTOR_steering_Control (MOTOR_STRAIGHT) ;  break;
    268c:	89 e0       	ldi	r24, 0x09	; 9
    268e:	0e 94 02 10 	call	0x2004	; 0x2004 <MOTOR_steering_Control>
		}
	}
	
	if (LANE_KEEP_FLAG==ENABLE)
    2692:	80 91 c6 02 	lds	r24, 0x02C6
    2696:	81 30       	cpi	r24, 0x01	; 1
    2698:	b1 f4       	brne	.+44     	; 0x26c6 <CarDirection+0x98>
	{
		if(dir_COM==ALARM_LANE_MSG_ON)// if acc off but lane keep on set alarm
    269a:	80 91 af 02 	lds	r24, 0x02AF
    269e:	85 30       	cpi	r24, 0x05	; 5
    26a0:	29 f4       	brne	.+10     	; 0x26ac <CarDirection+0x7e>
		{
			Dio_WriteChannel(ALARM_LANE_KEEP,STD_HIGH);
    26a2:	84 e0       	ldi	r24, 0x04	; 4
    26a4:	61 e0       	ldi	r22, 0x01	; 1
    26a6:	0e 94 42 0d 	call	0x1a84	; 0x1a84 <Dio_WriteChannel>
    26aa:	0d c0       	rjmp	.+26     	; 0x26c6 <CarDirection+0x98>
		}
		else if(dir_COM==ALARM_LANE_MSG_OFF)// if acc off but lane keep on set alarm
    26ac:	80 91 af 02 	lds	r24, 0x02AF
    26b0:	86 30       	cpi	r24, 0x06	; 6
    26b2:	29 f4       	brne	.+10     	; 0x26be <CarDirection+0x90>
		{
			Dio_WriteChannel(ALARM_LANE_KEEP,STD_LOW);
    26b4:	84 e0       	ldi	r24, 0x04	; 4
    26b6:	60 e0       	ldi	r22, 0x00	; 0
    26b8:	0e 94 42 0d 	call	0x1a84	; 0x1a84 <Dio_WriteChannel>
    26bc:	04 c0       	rjmp	.+8      	; 0x26c6 <CarDirection+0x98>
		}
		else
		{
			//read spi and set on motor_status
			MOTOR_steering_Control(dir_COM); //3 RIGHt   4 LEFT    9 STRAIGHT   
    26be:	80 91 af 02 	lds	r24, 0x02AF
    26c2:	0e 94 02 10 	call	0x2004	; 0x2004 <MOTOR_steering_Control>
		}
	}
}
    26c6:	0f 90       	pop	r0
    26c8:	0f 90       	pop	r0
    26ca:	cf 91       	pop	r28
    26cc:	df 91       	pop	r29
    26ce:	08 95       	ret

000026d0 <CarSpeed>:

void CarSpeed (void)
{
    26d0:	df 93       	push	r29
    26d2:	cf 93       	push	r28
    26d4:	00 d0       	rcall	.+0      	; 0x26d6 <CarSpeed+0x6>
    26d6:	00 d0       	rcall	.+0      	; 0x26d8 <CarSpeed+0x8>
    26d8:	cd b7       	in	r28, 0x3d	; 61
    26da:	de b7       	in	r29, 0x3e	; 62
	static u8 flag=DISABLE;
	
	if (MANIUAL_FLAG==ENABLE && ACC_FLAG == DISABLE)//IF NOT ACC ON
    26dc:	80 91 c1 02 	lds	r24, 0x02C1
    26e0:	81 30       	cpi	r24, 0x01	; 1
    26e2:	21 f5       	brne	.+72     	; 0x272c <CarSpeed+0x5c>
    26e4:	80 91 c8 02 	lds	r24, 0x02C8
    26e8:	88 23       	and	r24, r24
    26ea:	01 f5       	brne	.+64     	; 0x272c <CarSpeed+0x5c>
	{
		
		motor_status = UART_DATA ;
    26ec:	80 91 c3 02 	lds	r24, 0x02C3
    26f0:	80 93 c2 02 	sts	0x02C2, r24
		
		//motor_status from uart data
		switch (motor_status)
    26f4:	80 91 c2 02 	lds	r24, 0x02C2
    26f8:	28 2f       	mov	r18, r24
    26fa:	30 e0       	ldi	r19, 0x00	; 0
    26fc:	3c 83       	std	Y+4, r19	; 0x04
    26fe:	2b 83       	std	Y+3, r18	; 0x03
    2700:	8b 81       	ldd	r24, Y+3	; 0x03
    2702:	9c 81       	ldd	r25, Y+4	; 0x04
    2704:	81 30       	cpi	r24, 0x01	; 1
    2706:	91 05       	cpc	r25, r1
    2708:	61 f0       	breq	.+24     	; 0x2722 <CarSpeed+0x52>
    270a:	2b 81       	ldd	r18, Y+3	; 0x03
    270c:	3c 81       	ldd	r19, Y+4	; 0x04
    270e:	22 30       	cpi	r18, 0x02	; 2
    2710:	31 05       	cpc	r19, r1
    2712:	51 f0       	breq	.+20     	; 0x2728 <CarSpeed+0x58>
    2714:	8b 81       	ldd	r24, Y+3	; 0x03
    2716:	9c 81       	ldd	r25, Y+4	; 0x04
    2718:	00 97       	sbiw	r24, 0x00	; 0
    271a:	41 f4       	brne	.+16     	; 0x272c <CarSpeed+0x5c>
		{
			case MOTOR_STOP :      MOTOR_Stop();     break ;
    271c:	0e 94 db 0f 	call	0x1fb6	; 0x1fb6 <MOTOR_Stop>
    2720:	05 c0       	rjmp	.+10     	; 0x272c <CarSpeed+0x5c>
			case MOTOR_FORWARED:   MOTOR_Forward();  break ;
    2722:	0e 94 b7 0f 	call	0x1f6e	; 0x1f6e <MOTOR_Forward>
    2726:	02 c0       	rjmp	.+4      	; 0x272c <CarSpeed+0x5c>
			case MOTOR_BACKWARD:   MOTOR_Backward(); break ;
    2728:	0e 94 c9 0f 	call	0x1f92	; 0x1f92 <MOTOR_Backward>
		}
		
	}
	
	
	if ( ACC_FLAG == ENABLE ) //IF ACC ON
    272c:	80 91 c8 02 	lds	r24, 0x02C8
    2730:	81 30       	cpi	r24, 0x01	; 1
    2732:	09 f0       	breq	.+2      	; 0x2736 <CarSpeed+0x66>
    2734:	9d c0       	rjmp	.+314    	; 0x2870 <CarSpeed+0x1a0>
	{
			
			flag=ENABLE;
    2736:	81 e0       	ldi	r24, 0x01	; 1
    2738:	80 93 ab 02 	sts	0x02AB, r24
			
			speed_UART = UART_DATA ; //save speed from uart to use it at frist time in acc mode
    273c:	80 91 c3 02 	lds	r24, 0x02C3
    2740:	80 93 ac 02 	sts	0x02AC, r24
			if (FristTimeOnAcc==DISABLE)
    2744:	80 91 c0 02 	lds	r24, 0x02C0
    2748:	88 23       	and	r24, r24
    274a:	09 f0       	breq	.+2      	; 0x274e <CarSpeed+0x7e>
    274c:	7a c0       	rjmp	.+244    	; 0x2842 <CarSpeed+0x172>
			{
				switch (speed_UART)
    274e:	80 91 ac 02 	lds	r24, 0x02AC
    2752:	28 2f       	mov	r18, r24
    2754:	30 e0       	ldi	r19, 0x00	; 0
    2756:	3a 83       	std	Y+2, r19	; 0x02
    2758:	29 83       	std	Y+1, r18	; 0x01
    275a:	89 81       	ldd	r24, Y+1	; 0x01
    275c:	9a 81       	ldd	r25, Y+2	; 0x02
    275e:	82 30       	cpi	r24, 0x02	; 2
    2760:	91 05       	cpc	r25, r1
    2762:	e9 f1       	breq	.+122    	; 0x27de <CarSpeed+0x10e>
    2764:	29 81       	ldd	r18, Y+1	; 0x01
    2766:	3a 81       	ldd	r19, Y+2	; 0x02
    2768:	23 30       	cpi	r18, 0x03	; 3
    276a:	31 05       	cpc	r19, r1
    276c:	54 f4       	brge	.+20     	; 0x2782 <CarSpeed+0xb2>
    276e:	89 81       	ldd	r24, Y+1	; 0x01
    2770:	9a 81       	ldd	r25, Y+2	; 0x02
    2772:	00 97       	sbiw	r24, 0x00	; 0
    2774:	91 f0       	breq	.+36     	; 0x279a <CarSpeed+0xca>
    2776:	29 81       	ldd	r18, Y+1	; 0x01
    2778:	3a 81       	ldd	r19, Y+2	; 0x02
    277a:	21 30       	cpi	r18, 0x01	; 1
    277c:	31 05       	cpc	r19, r1
    277e:	f1 f0       	breq	.+60     	; 0x27bc <CarSpeed+0xec>
    2780:	60 c0       	rjmp	.+192    	; 0x2842 <CarSpeed+0x172>
    2782:	89 81       	ldd	r24, Y+1	; 0x01
    2784:	9a 81       	ldd	r25, Y+2	; 0x02
    2786:	83 30       	cpi	r24, 0x03	; 3
    2788:	91 05       	cpc	r25, r1
    278a:	d1 f1       	breq	.+116    	; 0x2800 <CarSpeed+0x130>
    278c:	29 81       	ldd	r18, Y+1	; 0x01
    278e:	3a 81       	ldd	r19, Y+2	; 0x02
    2790:	24 30       	cpi	r18, 0x04	; 4
    2792:	31 05       	cpc	r19, r1
    2794:	09 f4       	brne	.+2      	; 0x2798 <CarSpeed+0xc8>
    2796:	45 c0       	rjmp	.+138    	; 0x2822 <CarSpeed+0x152>
    2798:	54 c0       	rjmp	.+168    	; 0x2842 <CarSpeed+0x172>
				{
					case SPEED_0 : speed_COM = SET_SPEED0 ; default_speed = SET_SPEED0; MOTOR_Forward_SetSpeed(speed_COM); FristTimeOnAcc=ENABLE; msgReq1=ENABLE; break;
    279a:	8e e1       	ldi	r24, 0x1E	; 30
    279c:	80 93 ae 02 	sts	0x02AE, r24
    27a0:	8e e1       	ldi	r24, 0x1E	; 30
    27a2:	80 93 ad 02 	sts	0x02AD, r24
    27a6:	80 91 ae 02 	lds	r24, 0x02AE
    27aa:	0e 94 ed 0f 	call	0x1fda	; 0x1fda <MOTOR_Forward_SetSpeed>
    27ae:	81 e0       	ldi	r24, 0x01	; 1
    27b0:	80 93 c0 02 	sts	0x02C0, r24
    27b4:	81 e0       	ldi	r24, 0x01	; 1
    27b6:	80 93 c4 02 	sts	0x02C4, r24
    27ba:	43 c0       	rjmp	.+134    	; 0x2842 <CarSpeed+0x172>
					case SPEED_1 : speed_COM = SET_SPEED1 ; default_speed = SET_SPEED1 ; MOTOR_Forward_SetSpeed(speed_COM); FristTimeOnAcc=ENABLE; msgReq1=ENABLE; break;
    27bc:	88 e2       	ldi	r24, 0x28	; 40
    27be:	80 93 ae 02 	sts	0x02AE, r24
    27c2:	88 e2       	ldi	r24, 0x28	; 40
    27c4:	80 93 ad 02 	sts	0x02AD, r24
    27c8:	80 91 ae 02 	lds	r24, 0x02AE
    27cc:	0e 94 ed 0f 	call	0x1fda	; 0x1fda <MOTOR_Forward_SetSpeed>
    27d0:	81 e0       	ldi	r24, 0x01	; 1
    27d2:	80 93 c0 02 	sts	0x02C0, r24
    27d6:	81 e0       	ldi	r24, 0x01	; 1
    27d8:	80 93 c4 02 	sts	0x02C4, r24
    27dc:	32 c0       	rjmp	.+100    	; 0x2842 <CarSpeed+0x172>
					case SPEED_2 : speed_COM = SET_SPEED2 ; default_speed = SET_SPEED2 ; MOTOR_Forward_SetSpeed(speed_COM); FristTimeOnAcc=ENABLE; msgReq1=ENABLE; break;
    27de:	8c e3       	ldi	r24, 0x3C	; 60
    27e0:	80 93 ae 02 	sts	0x02AE, r24
    27e4:	8c e3       	ldi	r24, 0x3C	; 60
    27e6:	80 93 ad 02 	sts	0x02AD, r24
    27ea:	80 91 ae 02 	lds	r24, 0x02AE
    27ee:	0e 94 ed 0f 	call	0x1fda	; 0x1fda <MOTOR_Forward_SetSpeed>
    27f2:	81 e0       	ldi	r24, 0x01	; 1
    27f4:	80 93 c0 02 	sts	0x02C0, r24
    27f8:	81 e0       	ldi	r24, 0x01	; 1
    27fa:	80 93 c4 02 	sts	0x02C4, r24
    27fe:	21 c0       	rjmp	.+66     	; 0x2842 <CarSpeed+0x172>
					case SPEED_3 : speed_COM = SET_SPEED3 ; default_speed = SET_SPEED3 ; MOTOR_Forward_SetSpeed(speed_COM); FristTimeOnAcc=ENABLE; msgReq1=ENABLE; break;
    2800:	80 e5       	ldi	r24, 0x50	; 80
    2802:	80 93 ae 02 	sts	0x02AE, r24
    2806:	80 e5       	ldi	r24, 0x50	; 80
    2808:	80 93 ad 02 	sts	0x02AD, r24
    280c:	80 91 ae 02 	lds	r24, 0x02AE
    2810:	0e 94 ed 0f 	call	0x1fda	; 0x1fda <MOTOR_Forward_SetSpeed>
    2814:	81 e0       	ldi	r24, 0x01	; 1
    2816:	80 93 c0 02 	sts	0x02C0, r24
    281a:	81 e0       	ldi	r24, 0x01	; 1
    281c:	80 93 c4 02 	sts	0x02C4, r24
    2820:	10 c0       	rjmp	.+32     	; 0x2842 <CarSpeed+0x172>
					case SPEED_4 : speed_COM = SET_SPEED4 ; default_speed = SET_SPEED4 ; MOTOR_Forward_SetSpeed(speed_COM); FristTimeOnAcc=ENABLE; msgReq1=ENABLE; break;
    2822:	8a e5       	ldi	r24, 0x5A	; 90
    2824:	80 93 ae 02 	sts	0x02AE, r24
    2828:	8a e5       	ldi	r24, 0x5A	; 90
    282a:	80 93 ad 02 	sts	0x02AD, r24
    282e:	80 91 ae 02 	lds	r24, 0x02AE
    2832:	0e 94 ed 0f 	call	0x1fda	; 0x1fda <MOTOR_Forward_SetSpeed>
    2836:	81 e0       	ldi	r24, 0x01	; 1
    2838:	80 93 c0 02 	sts	0x02C0, r24
    283c:	81 e0       	ldi	r24, 0x01	; 1
    283e:	80 93 c4 02 	sts	0x02C4, r24
				}
			}
			
			
			if(print_flag==DISABLE) // that means we still waiting the frist speed from the user
    2842:	80 91 c5 02 	lds	r24, 0x02C5
    2846:	88 23       	and	r24, r24
    2848:	59 f4       	brne	.+22     	; 0x2860 <CarSpeed+0x190>
			{
				UART_Send_String("\r\n ACC IS ON PRESS 6 TO OFF THE MODE \r\n");
    284a:	8c e8       	ldi	r24, 0x8C	; 140
    284c:	91 e0       	ldi	r25, 0x01	; 1
    284e:	0e 94 b0 05 	call	0xb60	; 0xb60 <UART_Send_String>
				UART_Send_String("\r\n enter speed \r\n");
    2852:	84 eb       	ldi	r24, 0xB4	; 180
    2854:	91 e0       	ldi	r25, 0x01	; 1
    2856:	0e 94 b0 05 	call	0xb60	; 0xb60 <UART_Send_String>
				print_flag=ENABLE;
    285a:	81 e0       	ldi	r24, 0x01	; 1
    285c:	80 93 c5 02 	sts	0x02C5, r24
			}
			
			if(FristTimeOnAcc == ENABLE )
    2860:	80 91 c0 02 	lds	r24, 0x02C0
    2864:	81 30       	cpi	r24, 0x01	; 1
    2866:	21 f4       	brne	.+8      	; 0x2870 <CarSpeed+0x1a0>
			{
				MOTOR_Forward_SetSpeed(speed_COM);
    2868:	80 91 ae 02 	lds	r24, 0x02AE
    286c:	0e 94 ed 0f 	call	0x1fda	; 0x1fda <MOTOR_Forward_SetSpeed>
				
			}
			
	}
		
		if(ACC_FLAG==DISABLE&&flag==ENABLE)
    2870:	80 91 c8 02 	lds	r24, 0x02C8
    2874:	88 23       	and	r24, r24
    2876:	61 f4       	brne	.+24     	; 0x2890 <CarSpeed+0x1c0>
    2878:	80 91 ab 02 	lds	r24, 0x02AB
    287c:	81 30       	cpi	r24, 0x01	; 1
    287e:	41 f4       	brne	.+16     	; 0x2890 <CarSpeed+0x1c0>
	 {
			/*when go out from acc mode motor will not stop and will continue with its last speed status in (acc on) 
			until read another motor status for the motor thrue uart*/
			 MOTOR_Forward_SetSpeed(default_speed); 
    2880:	80 91 ad 02 	lds	r24, 0x02AD
    2884:	0e 94 ed 0f 	call	0x1fda	; 0x1fda <MOTOR_Forward_SetSpeed>
			 FristTimeOnAcc=DISABLE; 
    2888:	10 92 c0 02 	sts	0x02C0, r1
			 flag=DISABLE;
    288c:	10 92 ab 02 	sts	0x02AB, r1
	 }
}
    2890:	0f 90       	pop	r0
    2892:	0f 90       	pop	r0
    2894:	0f 90       	pop	r0
    2896:	0f 90       	pop	r0
    2898:	cf 91       	pop	r28
    289a:	df 91       	pop	r29
    289c:	08 95       	ret

0000289e <COM_handle>:

void COM_handle (void)
{
    289e:	df 93       	push	r29
    28a0:	cf 93       	push	r28
    28a2:	cd b7       	in	r28, 0x3d	; 61
    28a4:	de b7       	in	r29, 0x3e	; 62
     //transmit msg
	 COM_Tx(); 
    28a6:	0e 94 5a 14 	call	0x28b4	; 0x28b4 <COM_Tx>
	 // receiver  msg
	 COM_Rx ();
    28aa:	0e 94 dd 14 	call	0x29ba	; 0x29ba <COM_Rx>
	
}
    28ae:	cf 91       	pop	r28
    28b0:	df 91       	pop	r29
    28b2:	08 95       	ret

000028b4 <COM_Tx>:
void COM_Tx (void)
{
    28b4:	0f 93       	push	r16
    28b6:	1f 93       	push	r17
    28b8:	df 93       	push	r29
    28ba:	cf 93       	push	r28
    28bc:	cd b7       	in	r28, 0x3d	; 61
    28be:	de b7       	in	r29, 0x3e	; 62
    28c0:	27 97       	sbiw	r28, 0x07	; 7
    28c2:	0f b6       	in	r0, 0x3f	; 63
    28c4:	f8 94       	cli
    28c6:	de bf       	out	0x3e, r29	; 62
    28c8:	0f be       	out	0x3f, r0	; 63
    28ca:	cd bf       	out	0x3d, r28	; 61
	u8 accData[2]={ACC_FLAG,speed_COM};
    28cc:	80 91 c8 02 	lds	r24, 0x02C8
    28d0:	90 91 ae 02 	lds	r25, 0x02AE
    28d4:	89 83       	std	Y+1, r24	; 0x01
    28d6:	9a 83       	std	Y+2, r25	; 0x02
	u8 laneFlag=LANE_KEEP_FLAG;
    28d8:	80 91 c6 02 	lds	r24, 0x02C6
    28dc:	8b 83       	std	Y+3, r24	; 0x03
	/* transmit msg */
	if (msgReq1) // check if ecu want send acc msg
    28de:	80 91 c4 02 	lds	r24, 0x02C4
    28e2:	88 23       	and	r24, r24
    28e4:	71 f1       	breq	.+92     	; 0x2942 <COM_Tx+0x8e>
	{
		UART_Send_String("ACC SENT \r\n");
    28e6:	86 ec       	ldi	r24, 0xC6	; 198
    28e8:	91 e0       	ldi	r25, 0x01	; 1
    28ea:	0e 94 b0 05 	call	0xb60	; 0xb60 <UART_Send_String>
		switch (ACC_FLAG)
    28ee:	80 91 c8 02 	lds	r24, 0x02C8
    28f2:	28 2f       	mov	r18, r24
    28f4:	30 e0       	ldi	r19, 0x00	; 0
    28f6:	3f 83       	std	Y+7, r19	; 0x07
    28f8:	2e 83       	std	Y+6, r18	; 0x06
    28fa:	8e 81       	ldd	r24, Y+6	; 0x06
    28fc:	9f 81       	ldd	r25, Y+7	; 0x07
    28fe:	00 97       	sbiw	r24, 0x00	; 0
    2900:	31 f0       	breq	.+12     	; 0x290e <COM_Tx+0x5a>
    2902:	2e 81       	ldd	r18, Y+6	; 0x06
    2904:	3f 81       	ldd	r19, Y+7	; 0x07
    2906:	21 30       	cpi	r18, 0x01	; 1
    2908:	31 05       	cpc	r19, r1
    290a:	69 f0       	breq	.+26     	; 0x2926 <COM_Tx+0x72>
    290c:	17 c0       	rjmp	.+46     	; 0x293c <COM_Tx+0x88>
		{
			case ACC_OFF:
			//msg1 2 byte first byte acc flag on or off ,second byte speed of car
			MCP2515_SendMessage(CAN_TX_BUFF_0,CAN_ACC_MSG,CAN_ACC_OFF_DLC,&accData[0]);
    290e:	80 e0       	ldi	r24, 0x00	; 0
    2910:	41 e0       	ldi	r20, 0x01	; 1
    2912:	50 e0       	ldi	r21, 0x00	; 0
    2914:	60 e0       	ldi	r22, 0x00	; 0
    2916:	70 e0       	ldi	r23, 0x00	; 0
    2918:	21 e0       	ldi	r18, 0x01	; 1
    291a:	fe 01       	movw	r30, r28
    291c:	31 96       	adiw	r30, 0x01	; 1
    291e:	8f 01       	movw	r16, r30
    2920:	0e 94 30 11 	call	0x2260	; 0x2260 <MCP2515_SendMessage>
    2924:	0b c0       	rjmp	.+22     	; 0x293c <COM_Tx+0x88>
			break;
			case ACC_ON:
			//msg1 2 byte first byte acc flag on or off ,second byte speed of car
			MCP2515_SendMessage(CAN_TX_BUFF_0,CAN_ACC_MSG,CAN_ACC_ON_DLC,accData);
    2926:	80 e0       	ldi	r24, 0x00	; 0
    2928:	41 e0       	ldi	r20, 0x01	; 1
    292a:	50 e0       	ldi	r21, 0x00	; 0
    292c:	60 e0       	ldi	r22, 0x00	; 0
    292e:	70 e0       	ldi	r23, 0x00	; 0
    2930:	22 e0       	ldi	r18, 0x02	; 2
    2932:	fe 01       	movw	r30, r28
    2934:	31 96       	adiw	r30, 0x01	; 1
    2936:	8f 01       	movw	r16, r30
    2938:	0e 94 30 11 	call	0x2260	; 0x2260 <MCP2515_SendMessage>
			
			break;
		}
		msgReq1=DISABLE; // to disable req
    293c:	10 92 c4 02 	sts	0x02C4, r1
    2940:	31 c0       	rjmp	.+98     	; 0x29a4 <COM_Tx+0xf0>
	}
	else if (msgReq2)
    2942:	80 91 c7 02 	lds	r24, 0x02C7
    2946:	88 23       	and	r24, r24
    2948:	69 f1       	breq	.+90     	; 0x29a4 <COM_Tx+0xf0>
	{
		switch (LANE_KEEP_FLAG)
    294a:	80 91 c6 02 	lds	r24, 0x02C6
    294e:	28 2f       	mov	r18, r24
    2950:	30 e0       	ldi	r19, 0x00	; 0
    2952:	3d 83       	std	Y+5, r19	; 0x05
    2954:	2c 83       	std	Y+4, r18	; 0x04
    2956:	8c 81       	ldd	r24, Y+4	; 0x04
    2958:	9d 81       	ldd	r25, Y+5	; 0x05
    295a:	00 97       	sbiw	r24, 0x00	; 0
    295c:	31 f0       	breq	.+12     	; 0x296a <COM_Tx+0xb6>
    295e:	2c 81       	ldd	r18, Y+4	; 0x04
    2960:	3d 81       	ldd	r19, Y+5	; 0x05
    2962:	21 30       	cpi	r18, 0x01	; 1
    2964:	31 05       	cpc	r19, r1
    2966:	69 f0       	breq	.+26     	; 0x2982 <COM_Tx+0xce>
    2968:	17 c0       	rjmp	.+46     	; 0x2998 <COM_Tx+0xe4>
		{
			case LANE_OFF:
			//msg2 1 byte lane flag on or off
			MCP2515_SendMessage(CAN_TX_BUFF_0,CAN_LANE_MSG,CAN_LANE_OFF_DLC,&laneFlag);
    296a:	fe 01       	movw	r30, r28
    296c:	33 96       	adiw	r30, 0x03	; 3
    296e:	80 e0       	ldi	r24, 0x00	; 0
    2970:	42 e0       	ldi	r20, 0x02	; 2
    2972:	50 e0       	ldi	r21, 0x00	; 0
    2974:	60 e0       	ldi	r22, 0x00	; 0
    2976:	70 e0       	ldi	r23, 0x00	; 0
    2978:	22 e0       	ldi	r18, 0x02	; 2
    297a:	8f 01       	movw	r16, r30
    297c:	0e 94 30 11 	call	0x2260	; 0x2260 <MCP2515_SendMessage>
    2980:	0b c0       	rjmp	.+22     	; 0x2998 <COM_Tx+0xe4>
			break;
			case LANE_ON:
			//msg2 1 byte lane flag on or off
			MCP2515_SendMessage(CAN_TX_BUFF_0,CAN_LANE_MSG,CAN_LANE_ON_DLC,&laneFlag);
    2982:	fe 01       	movw	r30, r28
    2984:	33 96       	adiw	r30, 0x03	; 3
    2986:	80 e0       	ldi	r24, 0x00	; 0
    2988:	42 e0       	ldi	r20, 0x02	; 2
    298a:	50 e0       	ldi	r21, 0x00	; 0
    298c:	60 e0       	ldi	r22, 0x00	; 0
    298e:	70 e0       	ldi	r23, 0x00	; 0
    2990:	22 e0       	ldi	r18, 0x02	; 2
    2992:	8f 01       	movw	r16, r30
    2994:	0e 94 30 11 	call	0x2260	; 0x2260 <MCP2515_SendMessage>
			break;
		}
		msgReq2=DISABLE;// to disable req
    2998:	10 92 c7 02 	sts	0x02C7, r1
		UART_Send_String("LANE SENT \r\n");
    299c:	82 ed       	ldi	r24, 0xD2	; 210
    299e:	91 e0       	ldi	r25, 0x01	; 1
    29a0:	0e 94 b0 05 	call	0xb60	; 0xb60 <UART_Send_String>
	}
}
    29a4:	27 96       	adiw	r28, 0x07	; 7
    29a6:	0f b6       	in	r0, 0x3f	; 63
    29a8:	f8 94       	cli
    29aa:	de bf       	out	0x3e, r29	; 62
    29ac:	0f be       	out	0x3f, r0	; 63
    29ae:	cd bf       	out	0x3d, r28	; 61
    29b0:	cf 91       	pop	r28
    29b2:	df 91       	pop	r29
    29b4:	1f 91       	pop	r17
    29b6:	0f 91       	pop	r16
    29b8:	08 95       	ret

000029ba <COM_Rx>:
void COM_Rx (void)
{
    29ba:	df 93       	push	r29
    29bc:	cf 93       	push	r28
    29be:	cd b7       	in	r28, 0x3d	; 61
    29c0:	de b7       	in	r29, 0x3e	; 62
    29c2:	2f 97       	sbiw	r28, 0x0f	; 15
    29c4:	0f b6       	in	r0, 0x3f	; 63
    29c6:	f8 94       	cli
    29c8:	de bf       	out	0x3e, r29	; 62
    29ca:	0f be       	out	0x3f, r0	; 63
    29cc:	cd bf       	out	0x3d, r28	; 61
	  u8 msgId=DISABLE;
    29ce:	19 82       	std	Y+1, r1	; 0x01
	  u8 recvData[14]={0};
    29d0:	8e e0       	ldi	r24, 0x0E	; 14
    29d2:	fe 01       	movw	r30, r28
    29d4:	32 96       	adiw	r30, 0x02	; 2
    29d6:	df 01       	movw	r26, r30
    29d8:	98 2f       	mov	r25, r24
    29da:	1d 92       	st	X+, r1
    29dc:	9a 95       	dec	r25
    29de:	e9 f7       	brne	.-6      	; 0x29da <COM_Rx+0x20>
	  // msg1 ->> speed acc
	  // msg2 ->> dir
	  //msg3 ->> emg
	  
	if (Dio_ReadChannel(CAN_INT_PIN)==LOW)
    29e0:	81 e0       	ldi	r24, 0x01	; 1
    29e2:	0e 94 1b 0f 	call	0x1e36	; 0x1e36 <Dio_ReadChannel>
    29e6:	88 23       	and	r24, r24
    29e8:	c9 f5       	brne	.+114    	; 0x2a5c <COM_Rx+0xa2>
	{
		MCP2515_bufferGet(recvData);//get frame data
    29ea:	ce 01       	movw	r24, r28
    29ec:	02 96       	adiw	r24, 0x02	; 2
    29ee:	0e 94 63 10 	call	0x20c6	; 0x20c6 <MCP2515_bufferGet>
		MCP2515_receiverB0();
    29f2:	0e 94 60 12 	call	0x24c0	; 0x24c0 <MCP2515_receiverB0>
		msgId=((recvData[2])>>5);
    29f6:	8c 81       	ldd	r24, Y+4	; 0x04
    29f8:	82 95       	swap	r24
    29fa:	86 95       	lsr	r24
    29fc:	87 70       	andi	r24, 0x07	; 7
    29fe:	89 83       	std	Y+1, r24	; 0x01
		if (msgId==CAN_SPEED_MSG)
    2a00:	89 81       	ldd	r24, Y+1	; 0x01
    2a02:	81 30       	cpi	r24, 0x01	; 1
    2a04:	49 f4       	brne	.+18     	; 0x2a18 <COM_Rx+0x5e>
		{
			speed_COM=recvData[6];
    2a06:	88 85       	ldd	r24, Y+8	; 0x08
    2a08:	80 93 ae 02 	sts	0x02AE, r24
			msgId=DISABLE;	
    2a0c:	19 82       	std	Y+1, r1	; 0x01
			UART_Send_String("ACC RECV \r\n");
    2a0e:	8f ed       	ldi	r24, 0xDF	; 223
    2a10:	91 e0       	ldi	r25, 0x01	; 1
    2a12:	0e 94 b0 05 	call	0xb60	; 0xb60 <UART_Send_String>
    2a16:	22 c0       	rjmp	.+68     	; 0x2a5c <COM_Rx+0xa2>
		}
		else if (msgId==CAN_DIR_MSG)
    2a18:	89 81       	ldd	r24, Y+1	; 0x01
    2a1a:	82 30       	cpi	r24, 0x02	; 2
    2a1c:	49 f4       	brne	.+18     	; 0x2a30 <COM_Rx+0x76>
		{
			dir_COM=recvData[6]; 
    2a1e:	88 85       	ldd	r24, Y+8	; 0x08
    2a20:	80 93 af 02 	sts	0x02AF, r24
			msgId=DISABLE;
    2a24:	19 82       	std	Y+1, r1	; 0x01
			UART_Send_String("LANE RECV \r\n");
    2a26:	8b ee       	ldi	r24, 0xEB	; 235
    2a28:	91 e0       	ldi	r25, 0x01	; 1
    2a2a:	0e 94 b0 05 	call	0xb60	; 0xb60 <UART_Send_String>
    2a2e:	16 c0       	rjmp	.+44     	; 0x2a5c <COM_Rx+0xa2>
		}
		else if (msgId==CAN_EMG_MSG)
    2a30:	89 81       	ldd	r24, Y+1	; 0x01
    2a32:	83 30       	cpi	r24, 0x03	; 3
    2a34:	99 f4       	brne	.+38     	; 0x2a5c <COM_Rx+0xa2>
		{
			UART_Send_String("EMG RECV \r\n");
    2a36:	88 ef       	ldi	r24, 0xF8	; 248
    2a38:	91 e0       	ldi	r25, 0x01	; 1
    2a3a:	0e 94 b0 05 	call	0xb60	; 0xb60 <UART_Send_String>
			if (recvData[6]==CAN_EMG_FLAG_ON)
    2a3e:	88 85       	ldd	r24, Y+8	; 0x08
    2a40:	81 30       	cpi	r24, 0x01	; 1
    2a42:	59 f4       	brne	.+22     	; 0x2a5a <COM_Rx+0xa0>
			{
				ACC_FLAG=DISABLE;
    2a44:	10 92 c8 02 	sts	0x02C8, r1
				LANE_KEEP_FLAG=DISABLE;
    2a48:	10 92 c6 02 	sts	0x02C6, r1
				MOTOR_Stop();
    2a4c:	0e 94 db 0f 	call	0x1fb6	; 0x1fb6 <MOTOR_Stop>
				MANIUAL_FLAG=ENABLE;
    2a50:	81 e0       	ldi	r24, 0x01	; 1
    2a52:	80 93 c1 02 	sts	0x02C1, r24
				UART_DATA=DISABLE;
    2a56:	10 92 c3 02 	sts	0x02C3, r1
				if (recvData[7]==CAN_ACCIDENT_FLAG_ON)
				{
					//accident 
				}
			}
			msgId=DISABLE;
    2a5a:	19 82       	std	Y+1, r1	; 0x01
		}
	}
}
    2a5c:	2f 96       	adiw	r28, 0x0f	; 15
    2a5e:	0f b6       	in	r0, 0x3f	; 63
    2a60:	f8 94       	cli
    2a62:	de bf       	out	0x3e, r29	; 62
    2a64:	0f be       	out	0x3f, r0	; 63
    2a66:	cd bf       	out	0x3d, r28	; 61
    2a68:	cf 91       	pop	r28
    2a6a:	df 91       	pop	r29
    2a6c:	08 95       	ret

00002a6e <vMillisIncrement>:
#include "MCAL/DIO/DIO.h"
#include "Services/PORT/Port.h"
#define   GLOBAL_ENABLE    sei
// ISR Callback
void vMillisIncrement(void)
{
    2a6e:	df 93       	push	r29
    2a70:	cf 93       	push	r28
    2a72:	cd b7       	in	r28, 0x3d	; 61
    2a74:	de b7       	in	r29, 0x3e	; 62
	static u16 u16_MillisCounter=0;
	u16_MillisCounter++;
    2a76:	80 91 b0 02 	lds	r24, 0x02B0
    2a7a:	90 91 b1 02 	lds	r25, 0x02B1
    2a7e:	01 96       	adiw	r24, 0x01	; 1
    2a80:	90 93 b1 02 	sts	0x02B1, r25
    2a84:	80 93 b0 02 	sts	0x02B0, r24
	if (u16_MillisCounter>=TICK_TIME)
    2a88:	80 91 b0 02 	lds	r24, 0x02B0
    2a8c:	90 91 b1 02 	lds	r25, 0x02B1
    2a90:	85 30       	cpi	r24, 0x05	; 5
    2a92:	91 05       	cpc	r25, r1
    2a94:	30 f0       	brcs	.+12     	; 0x2aa2 <vMillisIncrement+0x34>
	{
		//blocked -> ready if its time
		OS_Task_Handler();
    2a96:	0e 94 7a 04 	call	0x8f4	; 0x8f4 <OS_Task_Handler>
		//reset counterl
		u16_MillisCounter=0;
    2a9a:	10 92 b1 02 	sts	0x02B1, r1
    2a9e:	10 92 b0 02 	sts	0x02B0, r1
	}
}
    2aa2:	cf 91       	pop	r28
    2aa4:	df 91       	pop	r29
    2aa6:	08 95       	ret

00002aa8 <vInitEcu>:
void vInitEcu(void)
{
    2aa8:	df 93       	push	r29
    2aaa:	cf 93       	push	r28
    2aac:	cd b7       	in	r28, 0x3d	; 61
    2aae:	de b7       	in	r29, 0x3e	; 62
	
	TIMER1_Init(TIMER1_CTC_OCRA_TOP_MODE,TIMER1_SCALER_64);
    2ab0:	83 e0       	ldi	r24, 0x03	; 3
    2ab2:	63 e0       	ldi	r22, 0x03	; 3
    2ab4:	0e 94 aa 08 	call	0x1154	; 0x1154 <TIMER1_Init>
	TIMER1_OC1AMode(OCRA_TOGGLE);
    2ab8:	81 e0       	ldi	r24, 0x01	; 1
    2aba:	0e 94 a6 09 	call	0x134c	; 0x134c <TIMER1_OC1AMode>
	GLOBAL_ENABLE();
    2abe:	78 94       	sei
	TIMER1_OC1A_Enable();
    2ac0:	0e 94 c1 0a 	call	0x1582	; 0x1582 <TIMER1_OC1A_Enable>
	TIMER1_OC1A_SetCallBack(vMillisIncrement);
    2ac4:	87 e3       	ldi	r24, 0x37	; 55
    2ac6:	95 e1       	ldi	r25, 0x15	; 21
    2ac8:	0e 94 27 0b 	call	0x164e	; 0x164e <TIMER1_OC1A_SetCallBack>
	MOTOR_Init();
    2acc:	0e 94 9d 12 	call	0x253a	; 0x253a <MOTOR_Init>
}
    2ad0:	cf 91       	pop	r28
    2ad2:	df 91       	pop	r29
    2ad4:	08 95       	ret

00002ad6 <InitScheduler>:
void InitScheduler(void)
{
    2ad6:	df 93       	push	r29
    2ad8:	cf 93       	push	r28
    2ada:	cd b7       	in	r28, 0x3d	; 61
    2adc:	de b7       	in	r29, 0x3e	; 62
	//func working on ms
	OS_TaskCreate(Task_UART_Get_20mS,20,BLOCKED,0);
    2ade:	80 e5       	ldi	r24, 0x50	; 80
    2ae0:	95 e0       	ldi	r25, 0x05	; 5
    2ae2:	64 e1       	ldi	r22, 0x14	; 20
    2ae4:	70 e0       	ldi	r23, 0x00	; 0
    2ae6:	41 e0       	ldi	r20, 0x01	; 1
    2ae8:	20 e0       	ldi	r18, 0x00	; 0
    2aea:	0e 94 f1 03 	call	0x7e2	; 0x7e2 <OS_TaskCreate>
	OS_TaskCreate(Task_MOTOR_GetDirection_40mS,40,BLOCKED,0);
    2aee:	82 e6       	ldi	r24, 0x62	; 98
    2af0:	95 e0       	ldi	r25, 0x05	; 5
    2af2:	68 e2       	ldi	r22, 0x28	; 40
    2af4:	70 e0       	ldi	r23, 0x00	; 0
    2af6:	41 e0       	ldi	r20, 0x01	; 1
    2af8:	20 e0       	ldi	r18, 0x00	; 0
    2afa:	0e 94 f1 03 	call	0x7e2	; 0x7e2 <OS_TaskCreate>
	OS_TaskCreate(Task_MOTOR_GetSpeed_50mS,50,BLOCKED,10);
    2afe:	89 e5       	ldi	r24, 0x59	; 89
    2b00:	95 e0       	ldi	r25, 0x05	; 5
    2b02:	62 e3       	ldi	r22, 0x32	; 50
    2b04:	70 e0       	ldi	r23, 0x00	; 0
    2b06:	41 e0       	ldi	r20, 0x01	; 1
    2b08:	2a e0       	ldi	r18, 0x0A	; 10
    2b0a:	0e 94 f1 03 	call	0x7e2	; 0x7e2 <OS_TaskCreate>
	OS_TaskCreate(Task_MOTOR_COM_5mS,5,BLOCKED,0);
    2b0e:	8b e6       	ldi	r24, 0x6B	; 107
    2b10:	95 e0       	ldi	r25, 0x05	; 5
    2b12:	65 e0       	ldi	r22, 0x05	; 5
    2b14:	70 e0       	ldi	r23, 0x00	; 0
    2b16:	41 e0       	ldi	r20, 0x01	; 1
    2b18:	20 e0       	ldi	r18, 0x00	; 0
    2b1a:	0e 94 f1 03 	call	0x7e2	; 0x7e2 <OS_TaskCreate>
}
    2b1e:	cf 91       	pop	r28
    2b20:	df 91       	pop	r29
    2b22:	08 95       	ret

00002b24 <main>:


int main(void)
{
    2b24:	df 93       	push	r29
    2b26:	cf 93       	push	r28
    2b28:	cd b7       	in	r28, 0x3d	; 61
    2b2a:	de b7       	in	r29, 0x3e	; 62
	vInitEcu();
    2b2c:	0e 94 54 15 	call	0x2aa8	; 0x2aa8 <vInitEcu>
	InitScheduler();
    2b30:	0e 94 6b 15 	call	0x2ad6	; 0x2ad6 <InitScheduler>

	while(1)
	{
		
		OS_TaskExecution();
    2b34:	0e 94 0b 05 	call	0xa16	; 0xa16 <OS_TaskExecution>
    2b38:	fd cf       	rjmp	.-6      	; 0x2b34 <main+0x10>

00002b3a <__udivmodhi4>:
    2b3a:	aa 1b       	sub	r26, r26
    2b3c:	bb 1b       	sub	r27, r27
    2b3e:	51 e1       	ldi	r21, 0x11	; 17
    2b40:	07 c0       	rjmp	.+14     	; 0x2b50 <__udivmodhi4_ep>

00002b42 <__udivmodhi4_loop>:
    2b42:	aa 1f       	adc	r26, r26
    2b44:	bb 1f       	adc	r27, r27
    2b46:	a6 17       	cp	r26, r22
    2b48:	b7 07       	cpc	r27, r23
    2b4a:	10 f0       	brcs	.+4      	; 0x2b50 <__udivmodhi4_ep>
    2b4c:	a6 1b       	sub	r26, r22
    2b4e:	b7 0b       	sbc	r27, r23

00002b50 <__udivmodhi4_ep>:
    2b50:	88 1f       	adc	r24, r24
    2b52:	99 1f       	adc	r25, r25
    2b54:	5a 95       	dec	r21
    2b56:	a9 f7       	brne	.-22     	; 0x2b42 <__udivmodhi4_loop>
    2b58:	80 95       	com	r24
    2b5a:	90 95       	com	r25
    2b5c:	bc 01       	movw	r22, r24
    2b5e:	cd 01       	movw	r24, r26
    2b60:	08 95       	ret

00002b62 <_exit>:
    2b62:	f8 94       	cli

00002b64 <__stop_program>:
    2b64:	ff cf       	rjmp	.-2      	; 0x2b64 <__stop_program>
