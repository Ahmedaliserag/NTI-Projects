
ATMega128_control.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000017c  00800100  00002c44  00002cd8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002c44  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000004e  0080027c  0080027c  00002e54  2**0
                  ALLOC
  3 .stab         00004adc  00000000  00000000  00002e54  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      0000358e  00000000  00000000  00007930  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 46 00 	jmp	0x8c	; 0x8c <__ctors_end>
       4:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
       8:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
       c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      10:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      14:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      18:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      1c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      20:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      24:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      28:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      2c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      30:	0c 94 98 08 	jmp	0x1130	; 0x1130 <__vector_12>
      34:	0c 94 5f 08 	jmp	0x10be	; 0x10be <__vector_13>
      38:	0c 94 26 08 	jmp	0x104c	; 0x104c <__vector_14>
      3c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      40:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      44:	0c 94 d0 09 	jmp	0x13a0	; 0x13a0 <__vector_17>
      48:	0c 94 26 03 	jmp	0x64c	; 0x64c <__vector_18>
      4c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      50:	0c 94 5f 03 	jmp	0x6be	; 0x6be <__vector_20>
      54:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      58:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      5c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      60:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      64:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      68:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      6c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      70:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      74:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      78:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      7c:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      80:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      84:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>
      88:	0c 94 65 00 	jmp	0xca	; 0xca <__bad_interrupt>

0000008c <__ctors_end>:
      8c:	11 24       	eor	r1, r1
      8e:	1f be       	out	0x3f, r1	; 63
      90:	cf ef       	ldi	r28, 0xFF	; 255
      92:	d0 e1       	ldi	r29, 0x10	; 16
      94:	de bf       	out	0x3e, r29	; 62
      96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_copy_data>:
      98:	12 e0       	ldi	r17, 0x02	; 2
      9a:	a0 e0       	ldi	r26, 0x00	; 0
      9c:	b1 e0       	ldi	r27, 0x01	; 1
      9e:	e4 e4       	ldi	r30, 0x44	; 68
      a0:	fc e2       	ldi	r31, 0x2C	; 44
      a2:	00 e0       	ldi	r16, 0x00	; 0
      a4:	0b bf       	out	0x3b, r16	; 59
      a6:	02 c0       	rjmp	.+4      	; 0xac <__do_copy_data+0x14>
      a8:	07 90       	elpm	r0, Z+
      aa:	0d 92       	st	X+, r0
      ac:	ac 37       	cpi	r26, 0x7C	; 124
      ae:	b1 07       	cpc	r27, r17
      b0:	d9 f7       	brne	.-10     	; 0xa8 <__do_copy_data+0x10>

000000b2 <__do_clear_bss>:
      b2:	12 e0       	ldi	r17, 0x02	; 2
      b4:	ac e7       	ldi	r26, 0x7C	; 124
      b6:	b2 e0       	ldi	r27, 0x02	; 2
      b8:	01 c0       	rjmp	.+2      	; 0xbc <.do_clear_bss_start>

000000ba <.do_clear_bss_loop>:
      ba:	1d 92       	st	X+, r1

000000bc <.do_clear_bss_start>:
      bc:	aa 3c       	cpi	r26, 0xCA	; 202
      be:	b1 07       	cpc	r27, r17
      c0:	e1 f7       	brne	.-8      	; 0xba <.do_clear_bss_loop>
      c2:	0e 94 01 16 	call	0x2c02	; 0x2c02 <main>
      c6:	0c 94 20 16 	jmp	0x2c40	; 0x2c40 <_exit>

000000ca <__bad_interrupt>:
      ca:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ce <OS_TaskCreate>:
      ce:	df 93       	push	r29
      d0:	cf 93       	push	r28
      d2:	cd b7       	in	r28, 0x3d	; 61
      d4:	de b7       	in	r29, 0x3e	; 62
      d6:	27 97       	sbiw	r28, 0x07	; 7
      d8:	0f b6       	in	r0, 0x3f	; 63
      da:	f8 94       	cli
      dc:	de bf       	out	0x3e, r29	; 62
      de:	0f be       	out	0x3f, r0	; 63
      e0:	cd bf       	out	0x3d, r28	; 61
      e2:	9b 83       	std	Y+3, r25	; 0x03
      e4:	8a 83       	std	Y+2, r24	; 0x02
      e6:	7d 83       	std	Y+5, r23	; 0x05
      e8:	6c 83       	std	Y+4, r22	; 0x04
      ea:	4e 83       	std	Y+6, r20	; 0x06
      ec:	2f 83       	std	Y+7, r18	; 0x07
      ee:	19 82       	std	Y+1, r1	; 0x01
      f0:	8a 81       	ldd	r24, Y+2	; 0x02
      f2:	9b 81       	ldd	r25, Y+3	; 0x03
      f4:	00 97       	sbiw	r24, 0x00	; 0
      f6:	19 f4       	brne	.+6      	; 0xfe <OS_TaskCreate+0x30>
      f8:	83 e0       	ldi	r24, 0x03	; 3
      fa:	89 83       	std	Y+1, r24	; 0x01
      fc:	67 c0       	rjmp	.+206    	; 0x1cc <OS_TaskCreate+0xfe>
      fe:	8c 81       	ldd	r24, Y+4	; 0x04
     100:	9d 81       	ldd	r25, Y+5	; 0x05
     102:	89 3c       	cpi	r24, 0xC9	; 201
     104:	91 05       	cpc	r25, r1
     106:	18 f0       	brcs	.+6      	; 0x10e <OS_TaskCreate+0x40>
     108:	81 e0       	ldi	r24, 0x01	; 1
     10a:	89 83       	std	Y+1, r24	; 0x01
     10c:	5f c0       	rjmp	.+190    	; 0x1cc <OS_TaskCreate+0xfe>
     10e:	80 91 7c 02 	lds	r24, 0x027C
     112:	84 30       	cpi	r24, 0x04	; 4
     114:	18 f0       	brcs	.+6      	; 0x11c <OS_TaskCreate+0x4e>
     116:	82 e0       	ldi	r24, 0x02	; 2
     118:	89 83       	std	Y+1, r24	; 0x01
     11a:	58 c0       	rjmp	.+176    	; 0x1cc <OS_TaskCreate+0xfe>
     11c:	80 91 7c 02 	lds	r24, 0x027C
     120:	28 2f       	mov	r18, r24
     122:	30 e0       	ldi	r19, 0x00	; 0
     124:	c9 01       	movw	r24, r18
     126:	88 0f       	add	r24, r24
     128:	99 1f       	adc	r25, r25
     12a:	82 0f       	add	r24, r18
     12c:	93 1f       	adc	r25, r19
     12e:	88 0f       	add	r24, r24
     130:	99 1f       	adc	r25, r25
     132:	fc 01       	movw	r30, r24
     134:	e3 58       	subi	r30, 0x83	; 131
     136:	fd 4f       	sbci	r31, 0xFD	; 253
     138:	8a 81       	ldd	r24, Y+2	; 0x02
     13a:	9b 81       	ldd	r25, Y+3	; 0x03
     13c:	91 83       	std	Z+1, r25	; 0x01
     13e:	80 83       	st	Z, r24
     140:	80 91 7c 02 	lds	r24, 0x027C
     144:	28 2f       	mov	r18, r24
     146:	30 e0       	ldi	r19, 0x00	; 0
     148:	4c 81       	ldd	r20, Y+4	; 0x04
     14a:	c9 01       	movw	r24, r18
     14c:	88 0f       	add	r24, r24
     14e:	99 1f       	adc	r25, r25
     150:	82 0f       	add	r24, r18
     152:	93 1f       	adc	r25, r19
     154:	88 0f       	add	r24, r24
     156:	99 1f       	adc	r25, r25
     158:	fc 01       	movw	r30, r24
     15a:	e0 58       	subi	r30, 0x80	; 128
     15c:	fd 4f       	sbci	r31, 0xFD	; 253
     15e:	40 83       	st	Z, r20
     160:	80 91 7c 02 	lds	r24, 0x027C
     164:	28 2f       	mov	r18, r24
     166:	30 e0       	ldi	r19, 0x00	; 0
     168:	c9 01       	movw	r24, r18
     16a:	88 0f       	add	r24, r24
     16c:	99 1f       	adc	r25, r25
     16e:	82 0f       	add	r24, r18
     170:	93 1f       	adc	r25, r19
     172:	01 96       	adiw	r24, 0x01	; 1
     174:	88 0f       	add	r24, r24
     176:	99 1f       	adc	r25, r25
     178:	fc 01       	movw	r30, r24
     17a:	e3 58       	subi	r30, 0x83	; 131
     17c:	fd 4f       	sbci	r31, 0xFD	; 253
     17e:	8e 81       	ldd	r24, Y+6	; 0x06
     180:	80 83       	st	Z, r24
     182:	80 91 7c 02 	lds	r24, 0x027C
     186:	28 2f       	mov	r18, r24
     188:	30 e0       	ldi	r19, 0x00	; 0
     18a:	c9 01       	movw	r24, r18
     18c:	88 0f       	add	r24, r24
     18e:	99 1f       	adc	r25, r25
     190:	82 0f       	add	r24, r18
     192:	93 1f       	adc	r25, r19
     194:	88 0f       	add	r24, r24
     196:	99 1f       	adc	r25, r25
     198:	fc 01       	movw	r30, r24
     19a:	ef 57       	subi	r30, 0x7F	; 127
     19c:	fd 4f       	sbci	r31, 0xFD	; 253
     19e:	85 e0       	ldi	r24, 0x05	; 5
     1a0:	80 83       	st	Z, r24
     1a2:	80 91 7c 02 	lds	r24, 0x027C
     1a6:	28 2f       	mov	r18, r24
     1a8:	30 e0       	ldi	r19, 0x00	; 0
     1aa:	c9 01       	movw	r24, r18
     1ac:	88 0f       	add	r24, r24
     1ae:	99 1f       	adc	r25, r25
     1b0:	82 0f       	add	r24, r18
     1b2:	93 1f       	adc	r25, r19
     1b4:	88 0f       	add	r24, r24
     1b6:	99 1f       	adc	r25, r25
     1b8:	fc 01       	movw	r30, r24
     1ba:	ee 57       	subi	r30, 0x7E	; 126
     1bc:	fd 4f       	sbci	r31, 0xFD	; 253
     1be:	8f 81       	ldd	r24, Y+7	; 0x07
     1c0:	80 83       	st	Z, r24
     1c2:	80 91 7c 02 	lds	r24, 0x027C
     1c6:	8f 5f       	subi	r24, 0xFF	; 255
     1c8:	80 93 7c 02 	sts	0x027C, r24
     1cc:	89 81       	ldd	r24, Y+1	; 0x01
     1ce:	27 96       	adiw	r28, 0x07	; 7
     1d0:	0f b6       	in	r0, 0x3f	; 63
     1d2:	f8 94       	cli
     1d4:	de bf       	out	0x3e, r29	; 62
     1d6:	0f be       	out	0x3f, r0	; 63
     1d8:	cd bf       	out	0x3d, r28	; 61
     1da:	cf 91       	pop	r28
     1dc:	df 91       	pop	r29
     1de:	08 95       	ret

000001e0 <OS_Task_Handler>:
	return status;
}

/* LInked to ISR --- Time --- Task Ststes by ms*/
void OS_Task_Handler(void)
{
     1e0:	df 93       	push	r29
     1e2:	cf 93       	push	r28
     1e4:	0f 92       	push	r0
     1e6:	cd b7       	in	r28, 0x3d	; 61
     1e8:	de b7       	in	r29, 0x3e	; 62
  u8 Task_id;
  for (Task_id=0;Task_id<taskCounter;Task_id++)
     1ea:	19 82       	std	Y+1, r1	; 0x01
     1ec:	80 c0       	rjmp	.+256    	; 0x2ee <OS_Task_Handler+0x10e>
  {
	    if (taskArray[Task_id].task_state!=SUSPENDED)
     1ee:	89 81       	ldd	r24, Y+1	; 0x01
     1f0:	28 2f       	mov	r18, r24
     1f2:	30 e0       	ldi	r19, 0x00	; 0
     1f4:	c9 01       	movw	r24, r18
     1f6:	88 0f       	add	r24, r24
     1f8:	99 1f       	adc	r25, r25
     1fa:	82 0f       	add	r24, r18
     1fc:	93 1f       	adc	r25, r19
     1fe:	01 96       	adiw	r24, 0x01	; 1
     200:	88 0f       	add	r24, r24
     202:	99 1f       	adc	r25, r25
     204:	fc 01       	movw	r30, r24
     206:	e3 58       	subi	r30, 0x83	; 131
     208:	fd 4f       	sbci	r31, 0xFD	; 253
     20a:	80 81       	ld	r24, Z
     20c:	88 23       	and	r24, r24
     20e:	09 f4       	brne	.+2      	; 0x212 <OS_Task_Handler+0x32>
     210:	6b c0       	rjmp	.+214    	; 0x2e8 <OS_Task_Handler+0x108>
	    {
			//using in first system first delay only
		    if (taskArray[Task_id].Task_tick_counter>=taskArray[Task_id].task_Periodicity)
     212:	89 81       	ldd	r24, Y+1	; 0x01
     214:	28 2f       	mov	r18, r24
     216:	30 e0       	ldi	r19, 0x00	; 0
     218:	c9 01       	movw	r24, r18
     21a:	88 0f       	add	r24, r24
     21c:	99 1f       	adc	r25, r25
     21e:	82 0f       	add	r24, r18
     220:	93 1f       	adc	r25, r19
     222:	88 0f       	add	r24, r24
     224:	99 1f       	adc	r25, r25
     226:	fc 01       	movw	r30, r24
     228:	ef 57       	subi	r30, 0x7F	; 127
     22a:	fd 4f       	sbci	r31, 0xFD	; 253
     22c:	40 81       	ld	r20, Z
     22e:	89 81       	ldd	r24, Y+1	; 0x01
     230:	28 2f       	mov	r18, r24
     232:	30 e0       	ldi	r19, 0x00	; 0
     234:	c9 01       	movw	r24, r18
     236:	88 0f       	add	r24, r24
     238:	99 1f       	adc	r25, r25
     23a:	82 0f       	add	r24, r18
     23c:	93 1f       	adc	r25, r19
     23e:	88 0f       	add	r24, r24
     240:	99 1f       	adc	r25, r25
     242:	fc 01       	movw	r30, r24
     244:	e0 58       	subi	r30, 0x80	; 128
     246:	fd 4f       	sbci	r31, 0xFD	; 253
     248:	80 81       	ld	r24, Z
     24a:	48 17       	cp	r20, r24
     24c:	78 f1       	brcs	.+94     	; 0x2ac <OS_Task_Handler+0xcc>
		    {
			    taskArray[Task_id].task_state=READY;
     24e:	89 81       	ldd	r24, Y+1	; 0x01
     250:	28 2f       	mov	r18, r24
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	c9 01       	movw	r24, r18
     256:	88 0f       	add	r24, r24
     258:	99 1f       	adc	r25, r25
     25a:	82 0f       	add	r24, r18
     25c:	93 1f       	adc	r25, r19
     25e:	01 96       	adiw	r24, 0x01	; 1
     260:	88 0f       	add	r24, r24
     262:	99 1f       	adc	r25, r25
     264:	fc 01       	movw	r30, r24
     266:	e3 58       	subi	r30, 0x83	; 131
     268:	fd 4f       	sbci	r31, 0xFD	; 253
     26a:	82 e0       	ldi	r24, 0x02	; 2
     26c:	80 83       	st	Z, r24
			    taskArray[Task_id].Task_tick_counter=TICK_TIME+taskArray[Task_id].delay; //to setup time user need after first periodicity
     26e:	89 81       	ldd	r24, Y+1	; 0x01
     270:	48 2f       	mov	r20, r24
     272:	50 e0       	ldi	r21, 0x00	; 0
     274:	89 81       	ldd	r24, Y+1	; 0x01
     276:	28 2f       	mov	r18, r24
     278:	30 e0       	ldi	r19, 0x00	; 0
     27a:	c9 01       	movw	r24, r18
     27c:	88 0f       	add	r24, r24
     27e:	99 1f       	adc	r25, r25
     280:	82 0f       	add	r24, r18
     282:	93 1f       	adc	r25, r19
     284:	88 0f       	add	r24, r24
     286:	99 1f       	adc	r25, r25
     288:	fc 01       	movw	r30, r24
     28a:	ee 57       	subi	r30, 0x7E	; 126
     28c:	fd 4f       	sbci	r31, 0xFD	; 253
     28e:	80 81       	ld	r24, Z
     290:	28 2f       	mov	r18, r24
     292:	2b 5f       	subi	r18, 0xFB	; 251
     294:	ca 01       	movw	r24, r20
     296:	88 0f       	add	r24, r24
     298:	99 1f       	adc	r25, r25
     29a:	84 0f       	add	r24, r20
     29c:	95 1f       	adc	r25, r21
     29e:	88 0f       	add	r24, r24
     2a0:	99 1f       	adc	r25, r25
     2a2:	fc 01       	movw	r30, r24
     2a4:	ef 57       	subi	r30, 0x7F	; 127
     2a6:	fd 4f       	sbci	r31, 0xFD	; 253
     2a8:	20 83       	st	Z, r18
     2aa:	1e c0       	rjmp	.+60     	; 0x2e8 <OS_Task_Handler+0x108>
		    }
		    else
		    {
			    taskArray[Task_id].Task_tick_counter+=TICK_TIME;
     2ac:	89 81       	ldd	r24, Y+1	; 0x01
     2ae:	48 2f       	mov	r20, r24
     2b0:	50 e0       	ldi	r21, 0x00	; 0
     2b2:	89 81       	ldd	r24, Y+1	; 0x01
     2b4:	28 2f       	mov	r18, r24
     2b6:	30 e0       	ldi	r19, 0x00	; 0
     2b8:	c9 01       	movw	r24, r18
     2ba:	88 0f       	add	r24, r24
     2bc:	99 1f       	adc	r25, r25
     2be:	82 0f       	add	r24, r18
     2c0:	93 1f       	adc	r25, r19
     2c2:	88 0f       	add	r24, r24
     2c4:	99 1f       	adc	r25, r25
     2c6:	fc 01       	movw	r30, r24
     2c8:	ef 57       	subi	r30, 0x7F	; 127
     2ca:	fd 4f       	sbci	r31, 0xFD	; 253
     2cc:	80 81       	ld	r24, Z
     2ce:	28 2f       	mov	r18, r24
     2d0:	2b 5f       	subi	r18, 0xFB	; 251
     2d2:	ca 01       	movw	r24, r20
     2d4:	88 0f       	add	r24, r24
     2d6:	99 1f       	adc	r25, r25
     2d8:	84 0f       	add	r24, r20
     2da:	95 1f       	adc	r25, r21
     2dc:	88 0f       	add	r24, r24
     2de:	99 1f       	adc	r25, r25
     2e0:	fc 01       	movw	r30, r24
     2e2:	ef 57       	subi	r30, 0x7F	; 127
     2e4:	fd 4f       	sbci	r31, 0xFD	; 253
     2e6:	20 83       	st	Z, r18

/* LInked to ISR --- Time --- Task Ststes by ms*/
void OS_Task_Handler(void)
{
  u8 Task_id;
  for (Task_id=0;Task_id<taskCounter;Task_id++)
     2e8:	89 81       	ldd	r24, Y+1	; 0x01
     2ea:	8f 5f       	subi	r24, 0xFF	; 255
     2ec:	89 83       	std	Y+1, r24	; 0x01
     2ee:	90 91 7c 02 	lds	r25, 0x027C
     2f2:	89 81       	ldd	r24, Y+1	; 0x01
     2f4:	89 17       	cp	r24, r25
     2f6:	08 f4       	brcc	.+2      	; 0x2fa <OS_Task_Handler+0x11a>
     2f8:	7a cf       	rjmp	.-268    	; 0x1ee <OS_Task_Handler+0xe>
		    {
			    taskArray[Task_id].Task_tick_counter+=TICK_TIME;
		    }
	    }  
  }
}
     2fa:	0f 90       	pop	r0
     2fc:	cf 91       	pop	r28
     2fe:	df 91       	pop	r29
     300:	08 95       	ret

00000302 <OS_TaskExecution>:


void OS_TaskExecution(void)
{
     302:	df 93       	push	r29
     304:	cf 93       	push	r28
     306:	0f 92       	push	r0
     308:	cd b7       	in	r28, 0x3d	; 61
     30a:	de b7       	in	r29, 0x3e	; 62
	u8 Task_id;
	for(Task_id = 0; Task_id<taskCounter; Task_id++)
     30c:	19 82       	std	Y+1, r1	; 0x01
     30e:	35 c0       	rjmp	.+106    	; 0x37a <OS_TaskExecution+0x78>
	{

		if(taskArray[Task_id].task_state == READY)
     310:	89 81       	ldd	r24, Y+1	; 0x01
     312:	28 2f       	mov	r18, r24
     314:	30 e0       	ldi	r19, 0x00	; 0
     316:	c9 01       	movw	r24, r18
     318:	88 0f       	add	r24, r24
     31a:	99 1f       	adc	r25, r25
     31c:	82 0f       	add	r24, r18
     31e:	93 1f       	adc	r25, r19
     320:	01 96       	adiw	r24, 0x01	; 1
     322:	88 0f       	add	r24, r24
     324:	99 1f       	adc	r25, r25
     326:	fc 01       	movw	r30, r24
     328:	e3 58       	subi	r30, 0x83	; 131
     32a:	fd 4f       	sbci	r31, 0xFD	; 253
     32c:	80 81       	ld	r24, Z
     32e:	82 30       	cpi	r24, 0x02	; 2
     330:	09 f5       	brne	.+66     	; 0x374 <OS_TaskExecution+0x72>
		{
			
			taskArray[Task_id].function();
     332:	89 81       	ldd	r24, Y+1	; 0x01
     334:	28 2f       	mov	r18, r24
     336:	30 e0       	ldi	r19, 0x00	; 0
     338:	c9 01       	movw	r24, r18
     33a:	88 0f       	add	r24, r24
     33c:	99 1f       	adc	r25, r25
     33e:	82 0f       	add	r24, r18
     340:	93 1f       	adc	r25, r19
     342:	88 0f       	add	r24, r24
     344:	99 1f       	adc	r25, r25
     346:	fc 01       	movw	r30, r24
     348:	e3 58       	subi	r30, 0x83	; 131
     34a:	fd 4f       	sbci	r31, 0xFD	; 253
     34c:	01 90       	ld	r0, Z+
     34e:	f0 81       	ld	r31, Z
     350:	e0 2d       	mov	r30, r0
     352:	09 95       	icall
			taskArray[Task_id].task_state = BLOCKED;
     354:	89 81       	ldd	r24, Y+1	; 0x01
     356:	28 2f       	mov	r18, r24
     358:	30 e0       	ldi	r19, 0x00	; 0
     35a:	c9 01       	movw	r24, r18
     35c:	88 0f       	add	r24, r24
     35e:	99 1f       	adc	r25, r25
     360:	82 0f       	add	r24, r18
     362:	93 1f       	adc	r25, r19
     364:	01 96       	adiw	r24, 0x01	; 1
     366:	88 0f       	add	r24, r24
     368:	99 1f       	adc	r25, r25
     36a:	fc 01       	movw	r30, r24
     36c:	e3 58       	subi	r30, 0x83	; 131
     36e:	fd 4f       	sbci	r31, 0xFD	; 253
     370:	81 e0       	ldi	r24, 0x01	; 1
     372:	80 83       	st	Z, r24


void OS_TaskExecution(void)
{
	u8 Task_id;
	for(Task_id = 0; Task_id<taskCounter; Task_id++)
     374:	89 81       	ldd	r24, Y+1	; 0x01
     376:	8f 5f       	subi	r24, 0xFF	; 255
     378:	89 83       	std	Y+1, r24	; 0x01
     37a:	90 91 7c 02 	lds	r25, 0x027C
     37e:	89 81       	ldd	r24, Y+1	; 0x01
     380:	89 17       	cp	r24, r25
     382:	30 f2       	brcs	.-116    	; 0x310 <OS_TaskExecution+0xe>
			taskArray[Task_id].function();
			taskArray[Task_id].task_state = BLOCKED;
		}
	}

}
     384:	0f 90       	pop	r0
     386:	cf 91       	pop	r28
     388:	df 91       	pop	r29
     38a:	08 95       	ret

0000038c <Task_UART_Get_20mS>:
#include "../OS/Tasks.h"
#include "../APP/control/MoveControl.h"
#include "../MCAL/UART/UART_interface.h"
void Task_UART_Get_20mS (void)
{
     38c:	df 93       	push	r29
     38e:	cf 93       	push	r28
     390:	cd b7       	in	r28, 0x3d	; 61
     392:	de b7       	in	r29, 0x3e	; 62

	UART_Get();
     394:	0e 94 35 13 	call	0x266a	; 0x266a <UART_Get>
	
}
     398:	cf 91       	pop	r28
     39a:	df 91       	pop	r29
     39c:	08 95       	ret

0000039e <Task_MOTOR_GetSpeed_50mS>:
void Task_MOTOR_GetSpeed_50mS(void)
{
     39e:	df 93       	push	r29
     3a0:	cf 93       	push	r28
     3a2:	cd b7       	in	r28, 0x3d	; 61
     3a4:	de b7       	in	r29, 0x3e	; 62

	CarSpeed();
     3a6:	0e 94 d7 13 	call	0x27ae	; 0x27ae <CarSpeed>
}
     3aa:	cf 91       	pop	r28
     3ac:	df 91       	pop	r29
     3ae:	08 95       	ret

000003b0 <Task_MOTOR_GetDirection_40mS>:
void Task_MOTOR_GetDirection_40mS(void)
{
     3b0:	df 93       	push	r29
     3b2:	cf 93       	push	r28
     3b4:	cd b7       	in	r28, 0x3d	; 61
     3b6:	de b7       	in	r29, 0x3e	; 62

	CarDirection();
     3b8:	0e 94 86 13 	call	0x270c	; 0x270c <CarDirection>
}
     3bc:	cf 91       	pop	r28
     3be:	df 91       	pop	r29
     3c0:	08 95       	ret

000003c2 <Task_MOTOR_COM_5mS>:

void Task_MOTOR_COM_5mS(void)
{
     3c2:	df 93       	push	r29
     3c4:	cf 93       	push	r28
     3c6:	cd b7       	in	r28, 0x3d	; 61
     3c8:	de b7       	in	r29, 0x3e	; 62

	COM_handle();
     3ca:	0e 94 be 14 	call	0x297c	; 0x297c <COM_handle>
}
     3ce:	cf 91       	pop	r28
     3d0:	df 91       	pop	r29
     3d2:	08 95       	ret

000003d4 <UART_Init>:

static void(*UART_RX_Fptr)(void)=NULLPTR;
static void(*UART_TX_Fptr)(void)=NULLPTR;
//============================================================================================
void UART_Init (void)
{
     3d4:	df 93       	push	r29
     3d6:	cf 93       	push	r28
     3d8:	cd b7       	in	r28, 0x3d	; 61
     3da:	de b7       	in	r29, 0x3e	; 62
	//UBRRH = (u8)((MyUBRR)>>8);
	UBRRL = (u8) 103;
     3dc:	e9 e2       	ldi	r30, 0x29	; 41
     3de:	f0 e0       	ldi	r31, 0x00	; 0
     3e0:	87 e6       	ldi	r24, 0x67	; 103
     3e2:	80 83       	st	Z, r24

	/* Configuration of UCSRnA Register  */
	UCSRnB = ( (RXEN<<4) | (TXEN<<3) | (UCSZ2<<2) );
     3e4:	ea e2       	ldi	r30, 0x2A	; 42
     3e6:	f0 e0       	ldi	r31, 0x00	; 0
     3e8:	88 e1       	ldi	r24, 0x18	; 24
     3ea:	80 83       	st	Z, r24

	/* Enable Transmit bit(3) and Receive bit(4) in UCSRnC Register */
	//UCSRnB = ( (RXEN<<4) | (TXEN<<3) | (UCSZ2<<2) );

	/* Configure UCRnC Register to make 8-bit data & 1 stop bit & no parity  Asynchronous Mode*/
	UCSRnC = ((UMSEL << 6) | (UPM1 << 5) | (UPM0 << 4)| (USBS << 3) | (UCSZ1 << 2) | (UCSZ0 << 1));
     3ec:	e5 e9       	ldi	r30, 0x95	; 149
     3ee:	f0 e0       	ldi	r31, 0x00	; 0
     3f0:	86 e0       	ldi	r24, 0x06	; 6
     3f2:	80 83       	st	Z, r24


}
     3f4:	cf 91       	pop	r28
     3f6:	df 91       	pop	r29
     3f8:	08 95       	ret

000003fa <UART_TransmitData>:

//==================================================================================================
void UART_TransmitData (u8 UART_DataToBeSent)
{
     3fa:	df 93       	push	r29
     3fc:	cf 93       	push	r28
     3fe:	0f 92       	push	r0
     400:	cd b7       	in	r28, 0x3d	; 61
     402:	de b7       	in	r29, 0x3e	; 62
     404:	89 83       	std	Y+1, r24	; 0x01
	while(GET_BIT(UCSRnA,5)==0);
     406:	eb e2       	ldi	r30, 0x2B	; 43
     408:	f0 e0       	ldi	r31, 0x00	; 0
     40a:	80 81       	ld	r24, Z
     40c:	82 95       	swap	r24
     40e:	86 95       	lsr	r24
     410:	87 70       	andi	r24, 0x07	; 7
     412:	88 2f       	mov	r24, r24
     414:	90 e0       	ldi	r25, 0x00	; 0
     416:	81 70       	andi	r24, 0x01	; 1
     418:	90 70       	andi	r25, 0x00	; 0
     41a:	00 97       	sbiw	r24, 0x00	; 0
     41c:	a1 f3       	breq	.-24     	; 0x406 <UART_TransmitData+0xc>

	/* So put data in the UDR Register */
	UDR=(u8)UART_DataToBeSent;
     41e:	ec e2       	ldi	r30, 0x2C	; 44
     420:	f0 e0       	ldi	r31, 0x00	; 0
     422:	89 81       	ldd	r24, Y+1	; 0x01
     424:	80 83       	st	Z, r24


}
     426:	0f 90       	pop	r0
     428:	cf 91       	pop	r28
     42a:	df 91       	pop	r29
     42c:	08 95       	ret

0000042e <UART_RecieveData>:
///////////////////////////////////////////////////////////////////////////////////////////////////
u8 UART_RecieveData(void)
{
     42e:	df 93       	push	r29
     430:	cf 93       	push	r28
     432:	cd b7       	in	r28, 0x3d	; 61
     434:	de b7       	in	r29, 0x3e	; 62
	while ( ! (UCSRnA & (1<<7)) );
     436:	eb e2       	ldi	r30, 0x2B	; 43
     438:	f0 e0       	ldi	r31, 0x00	; 0
     43a:	80 81       	ld	r24, Z
     43c:	88 23       	and	r24, r24
     43e:	dc f7       	brge	.-10     	; 0x436 <UART_RecieveData+0x8>
	return UDR;
     440:	ec e2       	ldi	r30, 0x2C	; 44
     442:	f0 e0       	ldi	r31, 0x00	; 0
     444:	80 81       	ld	r24, Z

}
     446:	cf 91       	pop	r28
     448:	df 91       	pop	r29
     44a:	08 95       	ret

0000044c <UART_Send_String>:

//////////////////////////////////////////////////////////////////////////////////////////


void UART_Send_String(char *ptr)
{
     44c:	df 93       	push	r29
     44e:	cf 93       	push	r28
     450:	00 d0       	rcall	.+0      	; 0x452 <UART_Send_String+0x6>
     452:	0f 92       	push	r0
     454:	cd b7       	in	r28, 0x3d	; 61
     456:	de b7       	in	r29, 0x3e	; 62
     458:	9b 83       	std	Y+3, r25	; 0x03
     45a:	8a 83       	std	Y+2, r24	; 0x02
	u8 Iteretor=0;
     45c:	19 82       	std	Y+1, r1	; 0x01
     45e:	0e c0       	rjmp	.+28     	; 0x47c <UART_Send_String+0x30>
	while(ptr[Iteretor]!='\0')
	{
		UART_TransmitData(ptr[Iteretor]);
     460:	89 81       	ldd	r24, Y+1	; 0x01
     462:	28 2f       	mov	r18, r24
     464:	30 e0       	ldi	r19, 0x00	; 0
     466:	8a 81       	ldd	r24, Y+2	; 0x02
     468:	9b 81       	ldd	r25, Y+3	; 0x03
     46a:	fc 01       	movw	r30, r24
     46c:	e2 0f       	add	r30, r18
     46e:	f3 1f       	adc	r31, r19
     470:	80 81       	ld	r24, Z
     472:	0e 94 fd 01 	call	0x3fa	; 0x3fa <UART_TransmitData>
		Iteretor++;
     476:	89 81       	ldd	r24, Y+1	; 0x01
     478:	8f 5f       	subi	r24, 0xFF	; 255
     47a:	89 83       	std	Y+1, r24	; 0x01


void UART_Send_String(char *ptr)
{
	u8 Iteretor=0;
	while(ptr[Iteretor]!='\0')
     47c:	89 81       	ldd	r24, Y+1	; 0x01
     47e:	28 2f       	mov	r18, r24
     480:	30 e0       	ldi	r19, 0x00	; 0
     482:	8a 81       	ldd	r24, Y+2	; 0x02
     484:	9b 81       	ldd	r25, Y+3	; 0x03
     486:	fc 01       	movw	r30, r24
     488:	e2 0f       	add	r30, r18
     48a:	f3 1f       	adc	r31, r19
     48c:	80 81       	ld	r24, Z
     48e:	88 23       	and	r24, r24
     490:	39 f7       	brne	.-50     	; 0x460 <UART_Send_String+0x14>
	{
		UART_TransmitData(ptr[Iteretor]);
		Iteretor++;
	}
}
     492:	0f 90       	pop	r0
     494:	0f 90       	pop	r0
     496:	0f 90       	pop	r0
     498:	cf 91       	pop	r28
     49a:	df 91       	pop	r29
     49c:	08 95       	ret

0000049e <UART_ReceiveNum>:

////////////////////////////////////////////////////////////////////////////////////////////////////

u8 UART_ReceiveNum(void)
{
     49e:	df 93       	push	r29
     4a0:	cf 93       	push	r28
     4a2:	0f 92       	push	r0
     4a4:	cd b7       	in	r28, 0x3d	; 61
     4a6:	de b7       	in	r29, 0x3e	; 62
	u8 NUM1;
	NUM1 = UART_ReceiveNoBlock();
     4a8:	0e 94 1c 03 	call	0x638	; 0x638 <UART_ReceiveNoBlock>
     4ac:	89 83       	std	Y+1, r24	; 0x01
	NUM1=NUM1-'0';
     4ae:	89 81       	ldd	r24, Y+1	; 0x01
     4b0:	80 53       	subi	r24, 0x30	; 48
     4b2:	89 83       	std	Y+1, r24	; 0x01
	return NUM1;
     4b4:	89 81       	ldd	r24, Y+1	; 0x01
}
     4b6:	0f 90       	pop	r0
     4b8:	cf 91       	pop	r28
     4ba:	df 91       	pop	r29
     4bc:	08 95       	ret

000004be <BlutouthMOdule_Init>:

///////////////////////////////////////////////BLEUTOOTH MODULE/////////////////////////////////////////////////////
void BlutouthMOdule_Init(void)
{
     4be:	df 93       	push	r29
     4c0:	cf 93       	push	r28
     4c2:	cd b7       	in	r28, 0x3d	; 61
     4c4:	de b7       	in	r29, 0x3e	; 62

	UART_Init();
     4c6:	0e 94 ea 01 	call	0x3d4	; 0x3d4 <UART_Init>

}
     4ca:	cf 91       	pop	r28
     4cc:	df 91       	pop	r29
     4ce:	08 95       	ret

000004d0 <Bluetooth_Module_Send_Data>:

void Bluetooth_Module_Send_Data(u8 Copy_Data)
{
     4d0:	df 93       	push	r29
     4d2:	cf 93       	push	r28
     4d4:	0f 92       	push	r0
     4d6:	cd b7       	in	r28, 0x3d	; 61
     4d8:	de b7       	in	r29, 0x3e	; 62
     4da:	89 83       	std	Y+1, r24	; 0x01
	UART_SendNoBlock(Copy_Data);
     4dc:	89 81       	ldd	r24, Y+1	; 0x01
     4de:	0e 94 0e 03 	call	0x61c	; 0x61c <UART_SendNoBlock>

}
     4e2:	0f 90       	pop	r0
     4e4:	cf 91       	pop	r28
     4e6:	df 91       	pop	r29
     4e8:	08 95       	ret

000004ea <Bluetooth_Module_Recieve_Data>:
void Bluetooth_Module_Recieve_Data(u8 *Copy_Data){
     4ea:	df 93       	push	r29
     4ec:	cf 93       	push	r28
     4ee:	00 d0       	rcall	.+0      	; 0x4f0 <Bluetooth_Module_Recieve_Data+0x6>
     4f0:	cd b7       	in	r28, 0x3d	; 61
     4f2:	de b7       	in	r29, 0x3e	; 62
     4f4:	9a 83       	std	Y+2, r25	; 0x02
     4f6:	89 83       	std	Y+1, r24	; 0x01

	*Copy_Data=UART_RecieveData();
     4f8:	0e 94 17 02 	call	0x42e	; 0x42e <UART_RecieveData>
     4fc:	e9 81       	ldd	r30, Y+1	; 0x01
     4fe:	fa 81       	ldd	r31, Y+2	; 0x02
     500:	80 83       	st	Z, r24

}
     502:	0f 90       	pop	r0
     504:	0f 90       	pop	r0
     506:	cf 91       	pop	r28
     508:	df 91       	pop	r29
     50a:	08 95       	ret

0000050c <Bluetooth_Module_SEND_String>:
void Bluetooth_Module_SEND_String(char *ptr)
{
     50c:	df 93       	push	r29
     50e:	cf 93       	push	r28
     510:	00 d0       	rcall	.+0      	; 0x512 <Bluetooth_Module_SEND_String+0x6>
     512:	cd b7       	in	r28, 0x3d	; 61
     514:	de b7       	in	r29, 0x3e	; 62
     516:	9a 83       	std	Y+2, r25	; 0x02
     518:	89 83       	std	Y+1, r24	; 0x01
	UART_Send_String(ptr);
     51a:	89 81       	ldd	r24, Y+1	; 0x01
     51c:	9a 81       	ldd	r25, Y+2	; 0x02
     51e:	0e 94 26 02 	call	0x44c	; 0x44c <UART_Send_String>
}
     522:	0f 90       	pop	r0
     524:	0f 90       	pop	r0
     526:	cf 91       	pop	r28
     528:	df 91       	pop	r29
     52a:	08 95       	ret

0000052c <Bluetooth_Module_RECEIVE_NUM>:
{
	UART_ReceivePass(userPass);

}*/
u8 Bluetooth_Module_RECEIVE_NUM()
{
     52c:	df 93       	push	r29
     52e:	cf 93       	push	r28
     530:	0f 92       	push	r0
     532:	cd b7       	in	r28, 0x3d	; 61
     534:	de b7       	in	r29, 0x3e	; 62
	u8 NUM1;
	NUM1=UART_RecieveData()-'0';
     536:	0e 94 17 02 	call	0x42e	; 0x42e <UART_RecieveData>
     53a:	80 53       	subi	r24, 0x30	; 48
     53c:	89 83       	std	Y+1, r24	; 0x01
	//UART_Send_String("\r\n");
	return NUM1;
     53e:	89 81       	ldd	r24, Y+1	; 0x01

}
     540:	0f 90       	pop	r0
     542:	cf 91       	pop	r28
     544:	df 91       	pop	r29
     546:	08 95       	ret

00000548 <Bluetooth_Module_RECEIVE_ID>:


u8 Bluetooth_Module_RECEIVE_ID()
{
     548:	df 93       	push	r29
     54a:	cf 93       	push	r28
     54c:	0f 92       	push	r0
     54e:	cd b7       	in	r28, 0x3d	; 61
     550:	de b7       	in	r29, 0x3e	; 62

	u8 NUM1;
	NUM1=UART_RecieveData()-'0';
     552:	0e 94 17 02 	call	0x42e	; 0x42e <UART_RecieveData>
     556:	80 53       	subi	r24, 0x30	; 48
     558:	89 83       	std	Y+1, r24	; 0x01
	//UART_Send_String("\r\n");
	return NUM1;
     55a:	89 81       	ldd	r24, Y+1	; 0x01

}
     55c:	0f 90       	pop	r0
     55e:	cf 91       	pop	r28
     560:	df 91       	pop	r29
     562:	08 95       	ret

00000564 <UART_RX_InterruptEnable>:


/***********************************UART INTERRUPT**********************/
void UART_RX_InterruptEnable(void)
{
     564:	df 93       	push	r29
     566:	cf 93       	push	r28
     568:	cd b7       	in	r28, 0x3d	; 61
     56a:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(UCSRB,RXCIE);
     56c:	aa e2       	ldi	r26, 0x2A	; 42
     56e:	b0 e0       	ldi	r27, 0x00	; 0
     570:	ea e2       	ldi	r30, 0x2A	; 42
     572:	f0 e0       	ldi	r31, 0x00	; 0
     574:	80 81       	ld	r24, Z
     576:	80 68       	ori	r24, 0x80	; 128
     578:	8c 93       	st	X, r24
}
     57a:	cf 91       	pop	r28
     57c:	df 91       	pop	r29
     57e:	08 95       	ret

00000580 <UART_RX_InterruptDisable>:

void UART_RX_InterruptDisable(void)
{
     580:	df 93       	push	r29
     582:	cf 93       	push	r28
     584:	cd b7       	in	r28, 0x3d	; 61
     586:	de b7       	in	r29, 0x3e	; 62
	CLR_BIT(UCSRB,RXCIE);
     588:	aa e2       	ldi	r26, 0x2A	; 42
     58a:	b0 e0       	ldi	r27, 0x00	; 0
     58c:	ea e2       	ldi	r30, 0x2A	; 42
     58e:	f0 e0       	ldi	r31, 0x00	; 0
     590:	80 81       	ld	r24, Z
     592:	8f 77       	andi	r24, 0x7F	; 127
     594:	8c 93       	st	X, r24
}
     596:	cf 91       	pop	r28
     598:	df 91       	pop	r29
     59a:	08 95       	ret

0000059c <UART_TX_InterruptEnable>:

void UART_TX_InterruptEnable(void)
{
     59c:	df 93       	push	r29
     59e:	cf 93       	push	r28
     5a0:	cd b7       	in	r28, 0x3d	; 61
     5a2:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(UCSRB,TXCIE);
     5a4:	aa e2       	ldi	r26, 0x2A	; 42
     5a6:	b0 e0       	ldi	r27, 0x00	; 0
     5a8:	ea e2       	ldi	r30, 0x2A	; 42
     5aa:	f0 e0       	ldi	r31, 0x00	; 0
     5ac:	80 81       	ld	r24, Z
     5ae:	80 64       	ori	r24, 0x40	; 64
     5b0:	8c 93       	st	X, r24
}
     5b2:	cf 91       	pop	r28
     5b4:	df 91       	pop	r29
     5b6:	08 95       	ret

000005b8 <UART_TX_InterruptDisable>:

void UART_TX_InterruptDisable(void)
{
     5b8:	df 93       	push	r29
     5ba:	cf 93       	push	r28
     5bc:	cd b7       	in	r28, 0x3d	; 61
     5be:	de b7       	in	r29, 0x3e	; 62
	CLR_BIT(UCSRB,TXCIE);
     5c0:	aa e2       	ldi	r26, 0x2A	; 42
     5c2:	b0 e0       	ldi	r27, 0x00	; 0
     5c4:	ea e2       	ldi	r30, 0x2A	; 42
     5c6:	f0 e0       	ldi	r31, 0x00	; 0
     5c8:	80 81       	ld	r24, Z
     5ca:	8f 7b       	andi	r24, 0xBF	; 191
     5cc:	8c 93       	st	X, r24
}
     5ce:	cf 91       	pop	r28
     5d0:	df 91       	pop	r29
     5d2:	08 95       	ret

000005d4 <UART_RX_SetCallBack>:

void UART_RX_SetCallBack(void (*LocalFptr)(void))
{
     5d4:	df 93       	push	r29
     5d6:	cf 93       	push	r28
     5d8:	00 d0       	rcall	.+0      	; 0x5da <UART_RX_SetCallBack+0x6>
     5da:	cd b7       	in	r28, 0x3d	; 61
     5dc:	de b7       	in	r29, 0x3e	; 62
     5de:	9a 83       	std	Y+2, r25	; 0x02
     5e0:	89 83       	std	Y+1, r24	; 0x01
	UART_RX_Fptr = LocalFptr;
     5e2:	89 81       	ldd	r24, Y+1	; 0x01
     5e4:	9a 81       	ldd	r25, Y+2	; 0x02
     5e6:	90 93 96 02 	sts	0x0296, r25
     5ea:	80 93 95 02 	sts	0x0295, r24
}
     5ee:	0f 90       	pop	r0
     5f0:	0f 90       	pop	r0
     5f2:	cf 91       	pop	r28
     5f4:	df 91       	pop	r29
     5f6:	08 95       	ret

000005f8 <UART_TX_SetCallBack>:

void UART_TX_SetCallBack(void (*LocalFptr)(void))
{
     5f8:	df 93       	push	r29
     5fa:	cf 93       	push	r28
     5fc:	00 d0       	rcall	.+0      	; 0x5fe <UART_TX_SetCallBack+0x6>
     5fe:	cd b7       	in	r28, 0x3d	; 61
     600:	de b7       	in	r29, 0x3e	; 62
     602:	9a 83       	std	Y+2, r25	; 0x02
     604:	89 83       	std	Y+1, r24	; 0x01
	UART_TX_Fptr = LocalFptr;
     606:	89 81       	ldd	r24, Y+1	; 0x01
     608:	9a 81       	ldd	r25, Y+2	; 0x02
     60a:	90 93 98 02 	sts	0x0298, r25
     60e:	80 93 97 02 	sts	0x0297, r24
}
     612:	0f 90       	pop	r0
     614:	0f 90       	pop	r0
     616:	cf 91       	pop	r28
     618:	df 91       	pop	r29
     61a:	08 95       	ret

0000061c <UART_SendNoBlock>:

void UART_SendNoBlock (u8 data)
{
     61c:	df 93       	push	r29
     61e:	cf 93       	push	r28
     620:	0f 92       	push	r0
     622:	cd b7       	in	r28, 0x3d	; 61
     624:	de b7       	in	r29, 0x3e	; 62
     626:	89 83       	std	Y+1, r24	; 0x01
	UDR = data ;
     628:	ec e2       	ldi	r30, 0x2C	; 44
     62a:	f0 e0       	ldi	r31, 0x00	; 0
     62c:	89 81       	ldd	r24, Y+1	; 0x01
     62e:	80 83       	st	Z, r24
}
     630:	0f 90       	pop	r0
     632:	cf 91       	pop	r28
     634:	df 91       	pop	r29
     636:	08 95       	ret

00000638 <UART_ReceiveNoBlock>:
u8 UART_ReceiveNoBlock (void)
{
     638:	df 93       	push	r29
     63a:	cf 93       	push	r28
     63c:	cd b7       	in	r28, 0x3d	; 61
     63e:	de b7       	in	r29, 0x3e	; 62
	return UDR ;
     640:	ec e2       	ldi	r30, 0x2C	; 44
     642:	f0 e0       	ldi	r31, 0x00	; 0
     644:	80 81       	ld	r24, Z
}
     646:	cf 91       	pop	r28
     648:	df 91       	pop	r29
     64a:	08 95       	ret

0000064c <__vector_18>:

void __vector_18 (void) __attribute__((signal));
void __vector_18 (void)
{
     64c:	1f 92       	push	r1
     64e:	0f 92       	push	r0
     650:	0f b6       	in	r0, 0x3f	; 63
     652:	0f 92       	push	r0
     654:	00 90 5b 00 	lds	r0, 0x005B
     658:	0f 92       	push	r0
     65a:	11 24       	eor	r1, r1
     65c:	2f 93       	push	r18
     65e:	3f 93       	push	r19
     660:	4f 93       	push	r20
     662:	5f 93       	push	r21
     664:	6f 93       	push	r22
     666:	7f 93       	push	r23
     668:	8f 93       	push	r24
     66a:	9f 93       	push	r25
     66c:	af 93       	push	r26
     66e:	bf 93       	push	r27
     670:	ef 93       	push	r30
     672:	ff 93       	push	r31
     674:	df 93       	push	r29
     676:	cf 93       	push	r28
     678:	cd b7       	in	r28, 0x3d	; 61
     67a:	de b7       	in	r29, 0x3e	; 62
	if (UART_RX_Fptr!=NULLPTR)
     67c:	80 91 95 02 	lds	r24, 0x0295
     680:	90 91 96 02 	lds	r25, 0x0296
     684:	00 97       	sbiw	r24, 0x00	; 0
     686:	29 f0       	breq	.+10     	; 0x692 <__vector_18+0x46>
	{
		UART_RX_Fptr();
     688:	e0 91 95 02 	lds	r30, 0x0295
     68c:	f0 91 96 02 	lds	r31, 0x0296
     690:	09 95       	icall
	}
}
     692:	cf 91       	pop	r28
     694:	df 91       	pop	r29
     696:	ff 91       	pop	r31
     698:	ef 91       	pop	r30
     69a:	bf 91       	pop	r27
     69c:	af 91       	pop	r26
     69e:	9f 91       	pop	r25
     6a0:	8f 91       	pop	r24
     6a2:	7f 91       	pop	r23
     6a4:	6f 91       	pop	r22
     6a6:	5f 91       	pop	r21
     6a8:	4f 91       	pop	r20
     6aa:	3f 91       	pop	r19
     6ac:	2f 91       	pop	r18
     6ae:	0f 90       	pop	r0
     6b0:	00 92 5b 00 	sts	0x005B, r0
     6b4:	0f 90       	pop	r0
     6b6:	0f be       	out	0x3f, r0	; 63
     6b8:	0f 90       	pop	r0
     6ba:	1f 90       	pop	r1
     6bc:	18 95       	reti

000006be <__vector_20>:

void __vector_20 (void) __attribute__((signal));
void __vector_20 (void)
{
     6be:	1f 92       	push	r1
     6c0:	0f 92       	push	r0
     6c2:	0f b6       	in	r0, 0x3f	; 63
     6c4:	0f 92       	push	r0
     6c6:	00 90 5b 00 	lds	r0, 0x005B
     6ca:	0f 92       	push	r0
     6cc:	11 24       	eor	r1, r1
     6ce:	2f 93       	push	r18
     6d0:	3f 93       	push	r19
     6d2:	4f 93       	push	r20
     6d4:	5f 93       	push	r21
     6d6:	6f 93       	push	r22
     6d8:	7f 93       	push	r23
     6da:	8f 93       	push	r24
     6dc:	9f 93       	push	r25
     6de:	af 93       	push	r26
     6e0:	bf 93       	push	r27
     6e2:	ef 93       	push	r30
     6e4:	ff 93       	push	r31
     6e6:	df 93       	push	r29
     6e8:	cf 93       	push	r28
     6ea:	cd b7       	in	r28, 0x3d	; 61
     6ec:	de b7       	in	r29, 0x3e	; 62
	if (UART_TX_Fptr!=NULLPTR)
     6ee:	80 91 97 02 	lds	r24, 0x0297
     6f2:	90 91 98 02 	lds	r25, 0x0298
     6f6:	00 97       	sbiw	r24, 0x00	; 0
     6f8:	29 f0       	breq	.+10     	; 0x704 <__vector_20+0x46>
	{
		UART_TX_Fptr();
     6fa:	e0 91 97 02 	lds	r30, 0x0297
     6fe:	f0 91 98 02 	lds	r31, 0x0298
     702:	09 95       	icall
	}
}
     704:	cf 91       	pop	r28
     706:	df 91       	pop	r29
     708:	ff 91       	pop	r31
     70a:	ef 91       	pop	r30
     70c:	bf 91       	pop	r27
     70e:	af 91       	pop	r26
     710:	9f 91       	pop	r25
     712:	8f 91       	pop	r24
     714:	7f 91       	pop	r23
     716:	6f 91       	pop	r22
     718:	5f 91       	pop	r21
     71a:	4f 91       	pop	r20
     71c:	3f 91       	pop	r19
     71e:	2f 91       	pop	r18
     720:	0f 90       	pop	r0
     722:	00 92 5b 00 	sts	0x005B, r0
     726:	0f 90       	pop	r0
     728:	0f be       	out	0x3f, r0	; 63
     72a:	0f 90       	pop	r0
     72c:	1f 90       	pop	r1
     72e:	18 95       	reti

00000730 <TMR0_Init>:
static void (*private_pCallBackOVF)(void)=NULLPTR;
static void (*private_pCallBackCTC)(void)=NULLPTR;
volatile static u16 private_ctcCounter;

void TMR0_Init (void)
{
     730:	df 93       	push	r29
     732:	cf 93       	push	r28
     734:	cd b7       	in	r28, 0x3d	; 61
     736:	de b7       	in	r29, 0x3e	; 62
	 SET_BIT(TCCR0,COM00);
	 #endif
	 /******** PHASE_CORRECT MODE ********/
	 #elif TMR0_MODE == TMR0_PHASE_CORRECT_MODE
	 /*	SelectMode=TMR0_FAST_PWM_MODE */
	 SET_BIT(TCCR0,WGM00);
     738:	a3 e5       	ldi	r26, 0x53	; 83
     73a:	b0 e0       	ldi	r27, 0x00	; 0
     73c:	e3 e5       	ldi	r30, 0x53	; 83
     73e:	f0 e0       	ldi	r31, 0x00	; 0
     740:	80 81       	ld	r24, Z
     742:	80 64       	ori	r24, 0x40	; 64
     744:	8c 93       	st	X, r24
	 CLR_BIT(TCCR0,WGM01);
     746:	a3 e5       	ldi	r26, 0x53	; 83
     748:	b0 e0       	ldi	r27, 0x00	; 0
     74a:	e3 e5       	ldi	r30, 0x53	; 83
     74c:	f0 e0       	ldi	r31, 0x00	; 0
     74e:	80 81       	ld	r24, Z
     750:	87 7f       	andi	r24, 0xF7	; 247
     752:	8c 93       	st	X, r24
	 
	 /*	Select Mode OF PHASE_CORRECT  */
	 #if TMR0_PWM_MOD == TMR0_PWM_NONINVERTING
	 CLR_BIT(TCCR0,COM00);
     754:	a3 e5       	ldi	r26, 0x53	; 83
     756:	b0 e0       	ldi	r27, 0x00	; 0
     758:	e3 e5       	ldi	r30, 0x53	; 83
     75a:	f0 e0       	ldi	r31, 0x00	; 0
     75c:	80 81       	ld	r24, Z
     75e:	8f 7e       	andi	r24, 0xEF	; 239
     760:	8c 93       	st	X, r24
	 SET_BIT(TCCR0,COM01);
     762:	a3 e5       	ldi	r26, 0x53	; 83
     764:	b0 e0       	ldi	r27, 0x00	; 0
     766:	e3 e5       	ldi	r30, 0x53	; 83
     768:	f0 e0       	ldi	r31, 0x00	; 0
     76a:	80 81       	ld	r24, Z
     76c:	80 62       	ori	r24, 0x20	; 32
     76e:	8c 93       	st	X, r24
	 SET_BIT(TCCR0,COM01);
	 SET_BIT(TCCR0,COM00);
	 #endif
		
	#endif
}
     770:	cf 91       	pop	r28
     772:	df 91       	pop	r29
     774:	08 95       	ret

00000776 <TMR0_SetComparematchValue>:
/*   Output Compare Register */
void TMR0_SetComparematchValue (u8 copy_u8compareValue) //set value to compare 
{
     776:	df 93       	push	r29
     778:	cf 93       	push	r28
     77a:	0f 92       	push	r0
     77c:	cd b7       	in	r28, 0x3d	; 61
     77e:	de b7       	in	r29, 0x3e	; 62
     780:	89 83       	std	Y+1, r24	; 0x01
	OCR0=copy_u8compareValue;
     782:	e1 e5       	ldi	r30, 0x51	; 81
     784:	f0 e0       	ldi	r31, 0x00	; 0
     786:	89 81       	ldd	r24, Y+1	; 0x01
     788:	80 83       	st	Z, r24
}
     78a:	0f 90       	pop	r0
     78c:	cf 91       	pop	r28
     78e:	df 91       	pop	r29
     790:	08 95       	ret

00000792 <TMR0_setDelay_ms_usingCTC>:
void TMR0_setDelay_ms_usingCTC (u16 copy_u16Delay_ms)
{
     792:	df 93       	push	r29
     794:	cf 93       	push	r28
     796:	00 d0       	rcall	.+0      	; 0x798 <TMR0_setDelay_ms_usingCTC+0x6>
     798:	cd b7       	in	r28, 0x3d	; 61
     79a:	de b7       	in	r29, 0x3e	; 62
     79c:	9a 83       	std	Y+2, r25	; 0x02
     79e:	89 83       	std	Y+1, r24	; 0x01
	// under condition tick time .5ms
	OCR0=249;
	private_ctcCounter= copy_u16Delay_ms*8 ; // TimeDelay configurable delay from developer  /8=1000/125
	#elif TMR0_PRESCALER == TMR0_PRESCALER_64
	// under condition tick time 4ms
	OCR0=249;
     7a0:	e1 e5       	ldi	r30, 0x51	; 81
     7a2:	f0 e0       	ldi	r31, 0x00	; 0
     7a4:	89 ef       	ldi	r24, 0xF9	; 249
     7a6:	80 83       	st	Z, r24
	private_ctcCounter=copy_u16Delay_ms; // TimeDelay configurable delay from developer
     7a8:	89 81       	ldd	r24, Y+1	; 0x01
     7aa:	9a 81       	ldd	r25, Y+2	; 0x02
     7ac:	90 93 9e 02 	sts	0x029E, r25
     7b0:	80 93 9d 02 	sts	0x029D, r24
	
	#elif TMR0_PRESCALER == TMR0_PRESCALER_1024
	
	#endif
	
}
     7b4:	0f 90       	pop	r0
     7b6:	0f 90       	pop	r0
     7b8:	cf 91       	pop	r28
     7ba:	df 91       	pop	r29
     7bc:	08 95       	ret

000007be <TMR0_Start>:
void TMR0_Start (void)
{
     7be:	df 93       	push	r29
     7c0:	cf 93       	push	r28
     7c2:	cd b7       	in	r28, 0x3d	; 61
     7c4:	de b7       	in	r29, 0x3e	; 62
	CLR_BIT(TCCR0,CS00);
	SET_BIT(TCCR0,CS01);
	CLR_BIT(TCCR0,CS02);
	#elif TMR0_PRESCALER == TMR0_PRESCALER_64
	/*	SelectPreScaller=64 */
	SET_BIT(TCCR0,CS00);
     7c6:	a3 e5       	ldi	r26, 0x53	; 83
     7c8:	b0 e0       	ldi	r27, 0x00	; 0
     7ca:	e3 e5       	ldi	r30, 0x53	; 83
     7cc:	f0 e0       	ldi	r31, 0x00	; 0
     7ce:	80 81       	ld	r24, Z
     7d0:	81 60       	ori	r24, 0x01	; 1
     7d2:	8c 93       	st	X, r24
	SET_BIT(TCCR0,CS01);
     7d4:	a3 e5       	ldi	r26, 0x53	; 83
     7d6:	b0 e0       	ldi	r27, 0x00	; 0
     7d8:	e3 e5       	ldi	r30, 0x53	; 83
     7da:	f0 e0       	ldi	r31, 0x00	; 0
     7dc:	80 81       	ld	r24, Z
     7de:	82 60       	ori	r24, 0x02	; 2
     7e0:	8c 93       	st	X, r24
	CLR_BIT(TCCR0,CS02);
     7e2:	a3 e5       	ldi	r26, 0x53	; 83
     7e4:	b0 e0       	ldi	r27, 0x00	; 0
     7e6:	e3 e5       	ldi	r30, 0x53	; 83
     7e8:	f0 e0       	ldi	r31, 0x00	; 0
     7ea:	80 81       	ld	r24, Z
     7ec:	8b 7f       	andi	r24, 0xFB	; 251
     7ee:	8c 93       	st	X, r24
	/*	SelectPreScaller=1024 */
	SET_BIT(TCCR0,CS00);
	CLR_BIT(TCCR0,CS01);
	SET_BIT(TCCR0,CS02);
	#endif
}
     7f0:	cf 91       	pop	r28
     7f2:	df 91       	pop	r29
     7f4:	08 95       	ret

000007f6 <TMR0_SetDutyCycle>:
void TMR0_SetDutyCycle (u8 copy_u8DutyCycle)
{
     7f6:	df 93       	push	r29
     7f8:	cf 93       	push	r28
     7fa:	0f 92       	push	r0
     7fc:	cd b7       	in	r28, 0x3d	; 61
     7fe:	de b7       	in	r29, 0x3e	; 62
     800:	89 83       	std	Y+1, r24	; 0x01
		copy_u8DutyCycle=100-copy_u8DutyCycle;
		OCR0=(((u16) copy_u8DutyCycle *256)/100)-1;
		#endif
	}
	#elif TMR0_MODE == TMR0_PHASE_CORRECT_MODE
	if(copy_u8DutyCycle<=100)
     802:	89 81       	ldd	r24, Y+1	; 0x01
     804:	85 36       	cpi	r24, 0x65	; 101
     806:	d0 f4       	brcc	.+52     	; 0x83c <TMR0_SetDutyCycle+0x46>
	{
		#if TMR0_PWM_MOD == TMR0_PWM_NONINVERTING
		OCR0=(((u16) copy_u8DutyCycle *255)/100);
     808:	e1 e5       	ldi	r30, 0x51	; 81
     80a:	f0 e0       	ldi	r31, 0x00	; 0
     80c:	89 81       	ldd	r24, Y+1	; 0x01
     80e:	48 2f       	mov	r20, r24
     810:	50 e0       	ldi	r21, 0x00	; 0
     812:	ca 01       	movw	r24, r20
     814:	9c 01       	movw	r18, r24
     816:	22 0f       	add	r18, r18
     818:	33 1f       	adc	r19, r19
     81a:	c9 01       	movw	r24, r18
     81c:	96 95       	lsr	r25
     81e:	98 2f       	mov	r25, r24
     820:	88 27       	eor	r24, r24
     822:	97 95       	ror	r25
     824:	87 95       	ror	r24
     826:	82 1b       	sub	r24, r18
     828:	93 0b       	sbc	r25, r19
     82a:	84 0f       	add	r24, r20
     82c:	95 1f       	adc	r25, r21
     82e:	24 e6       	ldi	r18, 0x64	; 100
     830:	30 e0       	ldi	r19, 0x00	; 0
     832:	b9 01       	movw	r22, r18
     834:	0e 94 0c 16 	call	0x2c18	; 0x2c18 <__udivmodhi4>
     838:	cb 01       	movw	r24, r22
     83a:	80 83       	st	Z, r24
		copy_u8DutyCycle=100-copy_u8DutyCycle;
		OCR0=(((u16) copy_u8DutyCycle *255)/100);
		#endif
	}
	#endif
}
     83c:	0f 90       	pop	r0
     83e:	cf 91       	pop	r28
     840:	df 91       	pop	r29
     842:	08 95       	ret

00000844 <TMR0_Stop>:
void TMR0_Stop (void)
{
     844:	df 93       	push	r29
     846:	cf 93       	push	r28
     848:	cd b7       	in	r28, 0x3d	; 61
     84a:	de b7       	in	r29, 0x3e	; 62
		/*	stop timer */
		CLR_BIT(TCCR0,CS00);
     84c:	a3 e5       	ldi	r26, 0x53	; 83
     84e:	b0 e0       	ldi	r27, 0x00	; 0
     850:	e3 e5       	ldi	r30, 0x53	; 83
     852:	f0 e0       	ldi	r31, 0x00	; 0
     854:	80 81       	ld	r24, Z
     856:	8e 7f       	andi	r24, 0xFE	; 254
     858:	8c 93       	st	X, r24
		CLR_BIT(TCCR0,CS01);
     85a:	a3 e5       	ldi	r26, 0x53	; 83
     85c:	b0 e0       	ldi	r27, 0x00	; 0
     85e:	e3 e5       	ldi	r30, 0x53	; 83
     860:	f0 e0       	ldi	r31, 0x00	; 0
     862:	80 81       	ld	r24, Z
     864:	8d 7f       	andi	r24, 0xFD	; 253
     866:	8c 93       	st	X, r24
		CLR_BIT(TCCR0,CS02);
     868:	a3 e5       	ldi	r26, 0x53	; 83
     86a:	b0 e0       	ldi	r27, 0x00	; 0
     86c:	e3 e5       	ldi	r30, 0x53	; 83
     86e:	f0 e0       	ldi	r31, 0x00	; 0
     870:	80 81       	ld	r24, Z
     872:	8b 7f       	andi	r24, 0xFB	; 251
     874:	8c 93       	st	X, r24
}
     876:	cf 91       	pop	r28
     878:	df 91       	pop	r29
     87a:	08 95       	ret

0000087c <TMR0_SetCallBackOVF>:
/* CallBack OVF */
void TMR0_SetCallBackOVF (void(*PtrToFun)(void))
{
     87c:	df 93       	push	r29
     87e:	cf 93       	push	r28
     880:	00 d0       	rcall	.+0      	; 0x882 <TMR0_SetCallBackOVF+0x6>
     882:	cd b7       	in	r28, 0x3d	; 61
     884:	de b7       	in	r29, 0x3e	; 62
     886:	9a 83       	std	Y+2, r25	; 0x02
     888:	89 83       	std	Y+1, r24	; 0x01
	if (PtrToFun!=NULLPTR) //validation to check if pointer == null or not 
     88a:	89 81       	ldd	r24, Y+1	; 0x01
     88c:	9a 81       	ldd	r25, Y+2	; 0x02
     88e:	00 97       	sbiw	r24, 0x00	; 0
     890:	31 f0       	breq	.+12     	; 0x89e <TMR0_SetCallBackOVF+0x22>
	{
		private_pCallBackOVF=PtrToFun;
     892:	89 81       	ldd	r24, Y+1	; 0x01
     894:	9a 81       	ldd	r25, Y+2	; 0x02
     896:	90 93 9a 02 	sts	0x029A, r25
     89a:	80 93 99 02 	sts	0x0299, r24
	}

}
     89e:	0f 90       	pop	r0
     8a0:	0f 90       	pop	r0
     8a2:	cf 91       	pop	r28
     8a4:	df 91       	pop	r29
     8a6:	08 95       	ret

000008a8 <TMR0_SetCallBackCTC>:
/* CallBack CTC */
void TMR0_SetCallBackCTC (void(*PtrToFun)(void))
{
     8a8:	df 93       	push	r29
     8aa:	cf 93       	push	r28
     8ac:	00 d0       	rcall	.+0      	; 0x8ae <TMR0_SetCallBackCTC+0x6>
     8ae:	cd b7       	in	r28, 0x3d	; 61
     8b0:	de b7       	in	r29, 0x3e	; 62
     8b2:	9a 83       	std	Y+2, r25	; 0x02
     8b4:	89 83       	std	Y+1, r24	; 0x01
	if (PtrToFun!=NULLPTR)
     8b6:	89 81       	ldd	r24, Y+1	; 0x01
     8b8:	9a 81       	ldd	r25, Y+2	; 0x02
     8ba:	00 97       	sbiw	r24, 0x00	; 0
     8bc:	31 f0       	breq	.+12     	; 0x8ca <TMR0_SetCallBackCTC+0x22>
	{
			private_pCallBackCTC=PtrToFun;
     8be:	89 81       	ldd	r24, Y+1	; 0x01
     8c0:	9a 81       	ldd	r25, Y+2	; 0x02
     8c2:	90 93 9c 02 	sts	0x029C, r25
     8c6:	80 93 9b 02 	sts	0x029B, r24
	}

}
     8ca:	0f 90       	pop	r0
     8cc:	0f 90       	pop	r0
     8ce:	cf 91       	pop	r28
     8d0:	df 91       	pop	r29
     8d2:	08 95       	ret

000008d4 <TIMER2_Init>:
#include "../DIO/DIO.h"
#include "../../MCAL/TIMERS/TIMERS_Int.h"


void TIMER2_Init (Timer2Mode_type local_mode,Timer2Scaler_type scaler)
{
     8d4:	df 93       	push	r29
     8d6:	cf 93       	push	r28
     8d8:	00 d0       	rcall	.+0      	; 0x8da <TIMER2_Init+0x6>
     8da:	00 d0       	rcall	.+0      	; 0x8dc <TIMER2_Init+0x8>
     8dc:	cd b7       	in	r28, 0x3d	; 61
     8de:	de b7       	in	r29, 0x3e	; 62
     8e0:	89 83       	std	Y+1, r24	; 0x01
     8e2:	6a 83       	std	Y+2, r22	; 0x02
	//Select TIMER0 Mode
	switch(local_mode)
     8e4:	89 81       	ldd	r24, Y+1	; 0x01
     8e6:	28 2f       	mov	r18, r24
     8e8:	30 e0       	ldi	r19, 0x00	; 0
     8ea:	3c 83       	std	Y+4, r19	; 0x04
     8ec:	2b 83       	std	Y+3, r18	; 0x03
     8ee:	8b 81       	ldd	r24, Y+3	; 0x03
     8f0:	9c 81       	ldd	r25, Y+4	; 0x04
     8f2:	81 30       	cpi	r24, 0x01	; 1
     8f4:	91 05       	cpc	r25, r1
     8f6:	21 f1       	breq	.+72     	; 0x940 <TIMER2_Init+0x6c>
     8f8:	2b 81       	ldd	r18, Y+3	; 0x03
     8fa:	3c 81       	ldd	r19, Y+4	; 0x04
     8fc:	22 30       	cpi	r18, 0x02	; 2
     8fe:	31 05       	cpc	r19, r1
     900:	2c f4       	brge	.+10     	; 0x90c <TIMER2_Init+0x38>
     902:	8b 81       	ldd	r24, Y+3	; 0x03
     904:	9c 81       	ldd	r25, Y+4	; 0x04
     906:	00 97       	sbiw	r24, 0x00	; 0
     908:	61 f0       	breq	.+24     	; 0x922 <TIMER2_Init+0x4e>
     90a:	46 c0       	rjmp	.+140    	; 0x998 <TIMER2_Init+0xc4>
     90c:	2b 81       	ldd	r18, Y+3	; 0x03
     90e:	3c 81       	ldd	r19, Y+4	; 0x04
     910:	22 30       	cpi	r18, 0x02	; 2
     912:	31 05       	cpc	r19, r1
     914:	21 f1       	breq	.+72     	; 0x95e <TIMER2_Init+0x8a>
     916:	8b 81       	ldd	r24, Y+3	; 0x03
     918:	9c 81       	ldd	r25, Y+4	; 0x04
     91a:	83 30       	cpi	r24, 0x03	; 3
     91c:	91 05       	cpc	r25, r1
     91e:	71 f1       	breq	.+92     	; 0x97c <TIMER2_Init+0xa8>
     920:	3b c0       	rjmp	.+118    	; 0x998 <TIMER2_Init+0xc4>
	{
		case TIMER2_NORMAL_MODE:
		CLR_BIT(TCCR2,WGM20);
     922:	a5 e4       	ldi	r26, 0x45	; 69
     924:	b0 e0       	ldi	r27, 0x00	; 0
     926:	e5 e4       	ldi	r30, 0x45	; 69
     928:	f0 e0       	ldi	r31, 0x00	; 0
     92a:	80 81       	ld	r24, Z
     92c:	8f 7b       	andi	r24, 0xBF	; 191
     92e:	8c 93       	st	X, r24
		CLR_BIT(TCCR2,WGM21);
     930:	a5 e4       	ldi	r26, 0x45	; 69
     932:	b0 e0       	ldi	r27, 0x00	; 0
     934:	e5 e4       	ldi	r30, 0x45	; 69
     936:	f0 e0       	ldi	r31, 0x00	; 0
     938:	80 81       	ld	r24, Z
     93a:	87 7f       	andi	r24, 0xF7	; 247
     93c:	8c 93       	st	X, r24
     93e:	2c c0       	rjmp	.+88     	; 0x998 <TIMER2_Init+0xc4>
		break;
		case TIMER2_PHASECORRECT_MODE:
		SET_BIT(TCCR2,WGM20);
     940:	a5 e4       	ldi	r26, 0x45	; 69
     942:	b0 e0       	ldi	r27, 0x00	; 0
     944:	e5 e4       	ldi	r30, 0x45	; 69
     946:	f0 e0       	ldi	r31, 0x00	; 0
     948:	80 81       	ld	r24, Z
     94a:	80 64       	ori	r24, 0x40	; 64
     94c:	8c 93       	st	X, r24
		CLR_BIT(TCCR2,WGM21);
     94e:	a5 e4       	ldi	r26, 0x45	; 69
     950:	b0 e0       	ldi	r27, 0x00	; 0
     952:	e5 e4       	ldi	r30, 0x45	; 69
     954:	f0 e0       	ldi	r31, 0x00	; 0
     956:	80 81       	ld	r24, Z
     958:	87 7f       	andi	r24, 0xF7	; 247
     95a:	8c 93       	st	X, r24
     95c:	1d c0       	rjmp	.+58     	; 0x998 <TIMER2_Init+0xc4>
		break;
		case TIMER2_CTC_MODE:
		CLR_BIT(TCCR2,WGM20);
     95e:	a5 e4       	ldi	r26, 0x45	; 69
     960:	b0 e0       	ldi	r27, 0x00	; 0
     962:	e5 e4       	ldi	r30, 0x45	; 69
     964:	f0 e0       	ldi	r31, 0x00	; 0
     966:	80 81       	ld	r24, Z
     968:	8f 7b       	andi	r24, 0xBF	; 191
     96a:	8c 93       	st	X, r24
		SET_BIT(TCCR2,WGM21);
     96c:	a5 e4       	ldi	r26, 0x45	; 69
     96e:	b0 e0       	ldi	r27, 0x00	; 0
     970:	e5 e4       	ldi	r30, 0x45	; 69
     972:	f0 e0       	ldi	r31, 0x00	; 0
     974:	80 81       	ld	r24, Z
     976:	88 60       	ori	r24, 0x08	; 8
     978:	8c 93       	st	X, r24
     97a:	0e c0       	rjmp	.+28     	; 0x998 <TIMER2_Init+0xc4>
		break;
		case TIMER2_FASTPWM_MODE:
		SET_BIT(TCCR2,WGM20);
     97c:	a5 e4       	ldi	r26, 0x45	; 69
     97e:	b0 e0       	ldi	r27, 0x00	; 0
     980:	e5 e4       	ldi	r30, 0x45	; 69
     982:	f0 e0       	ldi	r31, 0x00	; 0
     984:	80 81       	ld	r24, Z
     986:	80 64       	ori	r24, 0x40	; 64
     988:	8c 93       	st	X, r24
		SET_BIT(TCCR2,WGM21);
     98a:	a5 e4       	ldi	r26, 0x45	; 69
     98c:	b0 e0       	ldi	r27, 0x00	; 0
     98e:	e5 e4       	ldi	r30, 0x45	; 69
     990:	f0 e0       	ldi	r31, 0x00	; 0
     992:	80 81       	ld	r24, Z
     994:	88 60       	ori	r24, 0x08	; 8
     996:	8c 93       	st	X, r24
		break;
	}
	TCCR2&=0xF8;//0b11111000
     998:	a5 e4       	ldi	r26, 0x45	; 69
     99a:	b0 e0       	ldi	r27, 0x00	; 0
     99c:	e5 e4       	ldi	r30, 0x45	; 69
     99e:	f0 e0       	ldi	r31, 0x00	; 0
     9a0:	80 81       	ld	r24, Z
     9a2:	88 7f       	andi	r24, 0xF8	; 248
     9a4:	8c 93       	st	X, r24
	scaler&=0x07;//Filter
     9a6:	8a 81       	ldd	r24, Y+2	; 0x02
     9a8:	87 70       	andi	r24, 0x07	; 7
     9aa:	8a 83       	std	Y+2, r24	; 0x02
	TCCR2|=scaler;
     9ac:	a5 e4       	ldi	r26, 0x45	; 69
     9ae:	b0 e0       	ldi	r27, 0x00	; 0
     9b0:	e5 e4       	ldi	r30, 0x45	; 69
     9b2:	f0 e0       	ldi	r31, 0x00	; 0
     9b4:	90 81       	ld	r25, Z
     9b6:	8a 81       	ldd	r24, Y+2	; 0x02
     9b8:	89 2b       	or	r24, r25
     9ba:	8c 93       	st	X, r24
}
     9bc:	0f 90       	pop	r0
     9be:	0f 90       	pop	r0
     9c0:	0f 90       	pop	r0
     9c2:	0f 90       	pop	r0
     9c4:	cf 91       	pop	r28
     9c6:	df 91       	pop	r29
     9c8:	08 95       	ret

000009ca <TIMER2_OC2Mode>:

void TIMER2_OC2Mode (OC2Mode_type local_mode)
{
     9ca:	df 93       	push	r29
     9cc:	cf 93       	push	r28
     9ce:	00 d0       	rcall	.+0      	; 0x9d0 <TIMER2_OC2Mode+0x6>
     9d0:	0f 92       	push	r0
     9d2:	cd b7       	in	r28, 0x3d	; 61
     9d4:	de b7       	in	r29, 0x3e	; 62
     9d6:	89 83       	std	Y+1, r24	; 0x01
	switch(local_mode)
     9d8:	89 81       	ldd	r24, Y+1	; 0x01
     9da:	28 2f       	mov	r18, r24
     9dc:	30 e0       	ldi	r19, 0x00	; 0
     9de:	3b 83       	std	Y+3, r19	; 0x03
     9e0:	2a 83       	std	Y+2, r18	; 0x02
     9e2:	8a 81       	ldd	r24, Y+2	; 0x02
     9e4:	9b 81       	ldd	r25, Y+3	; 0x03
     9e6:	81 30       	cpi	r24, 0x01	; 1
     9e8:	91 05       	cpc	r25, r1
     9ea:	21 f1       	breq	.+72     	; 0xa34 <TIMER2_OC2Mode+0x6a>
     9ec:	2a 81       	ldd	r18, Y+2	; 0x02
     9ee:	3b 81       	ldd	r19, Y+3	; 0x03
     9f0:	22 30       	cpi	r18, 0x02	; 2
     9f2:	31 05       	cpc	r19, r1
     9f4:	2c f4       	brge	.+10     	; 0xa00 <TIMER2_OC2Mode+0x36>
     9f6:	8a 81       	ldd	r24, Y+2	; 0x02
     9f8:	9b 81       	ldd	r25, Y+3	; 0x03
     9fa:	00 97       	sbiw	r24, 0x00	; 0
     9fc:	61 f0       	breq	.+24     	; 0xa16 <TIMER2_OC2Mode+0x4c>
     9fe:	46 c0       	rjmp	.+140    	; 0xa8c <TIMER2_OC2Mode+0xc2>
     a00:	2a 81       	ldd	r18, Y+2	; 0x02
     a02:	3b 81       	ldd	r19, Y+3	; 0x03
     a04:	22 30       	cpi	r18, 0x02	; 2
     a06:	31 05       	cpc	r19, r1
     a08:	21 f1       	breq	.+72     	; 0xa52 <TIMER2_OC2Mode+0x88>
     a0a:	8a 81       	ldd	r24, Y+2	; 0x02
     a0c:	9b 81       	ldd	r25, Y+3	; 0x03
     a0e:	83 30       	cpi	r24, 0x03	; 3
     a10:	91 05       	cpc	r25, r1
     a12:	71 f1       	breq	.+92     	; 0xa70 <TIMER2_OC2Mode+0xa6>
     a14:	3b c0       	rjmp	.+118    	; 0xa8c <TIMER2_OC2Mode+0xc2>
	{
		case OC2_DISCONNECTED:
		CLR_BIT(TCCR2,COM20);
     a16:	a5 e4       	ldi	r26, 0x45	; 69
     a18:	b0 e0       	ldi	r27, 0x00	; 0
     a1a:	e5 e4       	ldi	r30, 0x45	; 69
     a1c:	f0 e0       	ldi	r31, 0x00	; 0
     a1e:	80 81       	ld	r24, Z
     a20:	8f 7e       	andi	r24, 0xEF	; 239
     a22:	8c 93       	st	X, r24
		CLR_BIT(TCCR2,COM21);
     a24:	a5 e4       	ldi	r26, 0x45	; 69
     a26:	b0 e0       	ldi	r27, 0x00	; 0
     a28:	e5 e4       	ldi	r30, 0x45	; 69
     a2a:	f0 e0       	ldi	r31, 0x00	; 0
     a2c:	80 81       	ld	r24, Z
     a2e:	8f 7d       	andi	r24, 0xDF	; 223
     a30:	8c 93       	st	X, r24
     a32:	2c c0       	rjmp	.+88     	; 0xa8c <TIMER2_OC2Mode+0xc2>
		break;
		case OC2_TOGGLE:
		SET_BIT(TCCR2,COM20);
     a34:	a5 e4       	ldi	r26, 0x45	; 69
     a36:	b0 e0       	ldi	r27, 0x00	; 0
     a38:	e5 e4       	ldi	r30, 0x45	; 69
     a3a:	f0 e0       	ldi	r31, 0x00	; 0
     a3c:	80 81       	ld	r24, Z
     a3e:	80 61       	ori	r24, 0x10	; 16
     a40:	8c 93       	st	X, r24
		CLR_BIT(TCCR2,COM21);
     a42:	a5 e4       	ldi	r26, 0x45	; 69
     a44:	b0 e0       	ldi	r27, 0x00	; 0
     a46:	e5 e4       	ldi	r30, 0x45	; 69
     a48:	f0 e0       	ldi	r31, 0x00	; 0
     a4a:	80 81       	ld	r24, Z
     a4c:	8f 7d       	andi	r24, 0xDF	; 223
     a4e:	8c 93       	st	X, r24
     a50:	1d c0       	rjmp	.+58     	; 0xa8c <TIMER2_OC2Mode+0xc2>
		break;
		case OC2_NON_INVERTING:
		CLR_BIT(TCCR2,COM20);
     a52:	a5 e4       	ldi	r26, 0x45	; 69
     a54:	b0 e0       	ldi	r27, 0x00	; 0
     a56:	e5 e4       	ldi	r30, 0x45	; 69
     a58:	f0 e0       	ldi	r31, 0x00	; 0
     a5a:	80 81       	ld	r24, Z
     a5c:	8f 7e       	andi	r24, 0xEF	; 239
     a5e:	8c 93       	st	X, r24
		SET_BIT(TCCR2,COM21);
     a60:	a5 e4       	ldi	r26, 0x45	; 69
     a62:	b0 e0       	ldi	r27, 0x00	; 0
     a64:	e5 e4       	ldi	r30, 0x45	; 69
     a66:	f0 e0       	ldi	r31, 0x00	; 0
     a68:	80 81       	ld	r24, Z
     a6a:	80 62       	ori	r24, 0x20	; 32
     a6c:	8c 93       	st	X, r24
     a6e:	0e c0       	rjmp	.+28     	; 0xa8c <TIMER2_OC2Mode+0xc2>
		break;
		case OC2_INVERTING:
		SET_BIT(TCCR2,COM20);
     a70:	a5 e4       	ldi	r26, 0x45	; 69
     a72:	b0 e0       	ldi	r27, 0x00	; 0
     a74:	e5 e4       	ldi	r30, 0x45	; 69
     a76:	f0 e0       	ldi	r31, 0x00	; 0
     a78:	80 81       	ld	r24, Z
     a7a:	80 61       	ori	r24, 0x10	; 16
     a7c:	8c 93       	st	X, r24
		SET_BIT(TCCR2,COM21);
     a7e:	a5 e4       	ldi	r26, 0x45	; 69
     a80:	b0 e0       	ldi	r27, 0x00	; 0
     a82:	e5 e4       	ldi	r30, 0x45	; 69
     a84:	f0 e0       	ldi	r31, 0x00	; 0
     a86:	80 81       	ld	r24, Z
     a88:	80 62       	ori	r24, 0x20	; 32
     a8a:	8c 93       	st	X, r24
		break;
	}
}
     a8c:	0f 90       	pop	r0
     a8e:	0f 90       	pop	r0
     a90:	0f 90       	pop	r0
     a92:	cf 91       	pop	r28
     a94:	df 91       	pop	r29
     a96:	08 95       	ret

00000a98 <TMR2_SetDutyCycle>:
void TMR2_SetDutyCycle (u8 copy_u8DutyCycle)
{
     a98:	df 93       	push	r29
     a9a:	cf 93       	push	r28
     a9c:	0f 92       	push	r0
     a9e:	cd b7       	in	r28, 0x3d	; 61
     aa0:	de b7       	in	r29, 0x3e	; 62
     aa2:	89 83       	std	Y+1, r24	; 0x01

	if(copy_u8DutyCycle<=100)
     aa4:	89 81       	ldd	r24, Y+1	; 0x01
     aa6:	85 36       	cpi	r24, 0x65	; 101
     aa8:	d0 f4       	brcc	.+52     	; 0xade <TMR2_SetDutyCycle+0x46>
	{
		OCR2=(((u16) copy_u8DutyCycle *255)/100);
     aaa:	e3 e4       	ldi	r30, 0x43	; 67
     aac:	f0 e0       	ldi	r31, 0x00	; 0
     aae:	89 81       	ldd	r24, Y+1	; 0x01
     ab0:	48 2f       	mov	r20, r24
     ab2:	50 e0       	ldi	r21, 0x00	; 0
     ab4:	ca 01       	movw	r24, r20
     ab6:	9c 01       	movw	r18, r24
     ab8:	22 0f       	add	r18, r18
     aba:	33 1f       	adc	r19, r19
     abc:	c9 01       	movw	r24, r18
     abe:	96 95       	lsr	r25
     ac0:	98 2f       	mov	r25, r24
     ac2:	88 27       	eor	r24, r24
     ac4:	97 95       	ror	r25
     ac6:	87 95       	ror	r24
     ac8:	82 1b       	sub	r24, r18
     aca:	93 0b       	sbc	r25, r19
     acc:	84 0f       	add	r24, r20
     ace:	95 1f       	adc	r25, r21
     ad0:	24 e6       	ldi	r18, 0x64	; 100
     ad2:	30 e0       	ldi	r19, 0x00	; 0
     ad4:	b9 01       	movw	r22, r18
     ad6:	0e 94 0c 16 	call	0x2c18	; 0x2c18 <__udivmodhi4>
     ada:	cb 01       	movw	r24, r22
     adc:	80 83       	st	Z, r24
	}
}
     ade:	0f 90       	pop	r0
     ae0:	cf 91       	pop	r28
     ae2:	df 91       	pop	r29
     ae4:	08 95       	ret

00000ae6 <TIMER1_Init>:
static void (*Timer1_OVF_Fptr)(void)=NULLPTR;
static void (*Timer1_OCA_Fptr)(void)=NULLPTR;
static void (*Timer1_OCB_Fptr)(void)=NULLPTR;
static void (*Timer1_ICU_Fptr)(void)=NULLPTR;
void TIMER1_Init (Timer1Mode_type local_mode,Timer1Scaler_type scaler)
{
     ae6:	df 93       	push	r29
     ae8:	cf 93       	push	r28
     aea:	00 d0       	rcall	.+0      	; 0xaec <TIMER1_Init+0x6>
     aec:	00 d0       	rcall	.+0      	; 0xaee <TIMER1_Init+0x8>
     aee:	cd b7       	in	r28, 0x3d	; 61
     af0:	de b7       	in	r29, 0x3e	; 62
     af2:	89 83       	std	Y+1, r24	; 0x01
     af4:	6a 83       	std	Y+2, r22	; 0x02
	//Select TIMER1 Mode
	switch(local_mode)
     af6:	89 81       	ldd	r24, Y+1	; 0x01
     af8:	28 2f       	mov	r18, r24
     afa:	30 e0       	ldi	r19, 0x00	; 0
     afc:	3c 83       	std	Y+4, r19	; 0x04
     afe:	2b 83       	std	Y+3, r18	; 0x03
     b00:	8b 81       	ldd	r24, Y+3	; 0x03
     b02:	9c 81       	ldd	r25, Y+4	; 0x04
     b04:	82 30       	cpi	r24, 0x02	; 2
     b06:	91 05       	cpc	r25, r1
     b08:	09 f4       	brne	.+2      	; 0xb0c <TIMER1_Init+0x26>
     b0a:	40 c0       	rjmp	.+128    	; 0xb8c <TIMER1_Init+0xa6>
     b0c:	2b 81       	ldd	r18, Y+3	; 0x03
     b0e:	3c 81       	ldd	r19, Y+4	; 0x04
     b10:	23 30       	cpi	r18, 0x03	; 3
     b12:	31 05       	cpc	r19, r1
     b14:	5c f4       	brge	.+22     	; 0xb2c <TIMER1_Init+0x46>
     b16:	8b 81       	ldd	r24, Y+3	; 0x03
     b18:	9c 81       	ldd	r25, Y+4	; 0x04
     b1a:	00 97       	sbiw	r24, 0x00	; 0
     b1c:	d1 f0       	breq	.+52     	; 0xb52 <TIMER1_Init+0x6c>
     b1e:	2b 81       	ldd	r18, Y+3	; 0x03
     b20:	3c 81       	ldd	r19, Y+4	; 0x04
     b22:	21 30       	cpi	r18, 0x01	; 1
     b24:	31 05       	cpc	r19, r1
     b26:	09 f4       	brne	.+2      	; 0xb2a <TIMER1_Init+0x44>
     b28:	a5 c0       	rjmp	.+330    	; 0xc74 <TIMER1_Init+0x18e>
     b2a:	c0 c0       	rjmp	.+384    	; 0xcac <TIMER1_Init+0x1c6>
     b2c:	8b 81       	ldd	r24, Y+3	; 0x03
     b2e:	9c 81       	ldd	r25, Y+4	; 0x04
     b30:	84 30       	cpi	r24, 0x04	; 4
     b32:	91 05       	cpc	r25, r1
     b34:	09 f4       	brne	.+2      	; 0xb38 <TIMER1_Init+0x52>
     b36:	64 c0       	rjmp	.+200    	; 0xc00 <TIMER1_Init+0x11a>
     b38:	2b 81       	ldd	r18, Y+3	; 0x03
     b3a:	3c 81       	ldd	r19, Y+4	; 0x04
     b3c:	24 30       	cpi	r18, 0x04	; 4
     b3e:	31 05       	cpc	r19, r1
     b40:	0c f4       	brge	.+2      	; 0xb44 <TIMER1_Init+0x5e>
     b42:	41 c0       	rjmp	.+130    	; 0xbc6 <TIMER1_Init+0xe0>
     b44:	8b 81       	ldd	r24, Y+3	; 0x03
     b46:	9c 81       	ldd	r25, Y+4	; 0x04
     b48:	85 30       	cpi	r24, 0x05	; 5
     b4a:	91 05       	cpc	r25, r1
     b4c:	09 f4       	brne	.+2      	; 0xb50 <TIMER1_Init+0x6a>
     b4e:	75 c0       	rjmp	.+234    	; 0xc3a <TIMER1_Init+0x154>
     b50:	ad c0       	rjmp	.+346    	; 0xcac <TIMER1_Init+0x1c6>
	{
		case TIMER1_NORMAL_MODE:
		CLR_BIT(TCCR1A,WGM10);
     b52:	af e4       	ldi	r26, 0x4F	; 79
     b54:	b0 e0       	ldi	r27, 0x00	; 0
     b56:	ef e4       	ldi	r30, 0x4F	; 79
     b58:	f0 e0       	ldi	r31, 0x00	; 0
     b5a:	80 81       	ld	r24, Z
     b5c:	8e 7f       	andi	r24, 0xFE	; 254
     b5e:	8c 93       	st	X, r24
		CLR_BIT(TCCR1A,WGM11);
     b60:	af e4       	ldi	r26, 0x4F	; 79
     b62:	b0 e0       	ldi	r27, 0x00	; 0
     b64:	ef e4       	ldi	r30, 0x4F	; 79
     b66:	f0 e0       	ldi	r31, 0x00	; 0
     b68:	80 81       	ld	r24, Z
     b6a:	8d 7f       	andi	r24, 0xFD	; 253
     b6c:	8c 93       	st	X, r24
		CLR_BIT(TCCR1B,WGM12);
     b6e:	ae e4       	ldi	r26, 0x4E	; 78
     b70:	b0 e0       	ldi	r27, 0x00	; 0
     b72:	ee e4       	ldi	r30, 0x4E	; 78
     b74:	f0 e0       	ldi	r31, 0x00	; 0
     b76:	80 81       	ld	r24, Z
     b78:	87 7f       	andi	r24, 0xF7	; 247
     b7a:	8c 93       	st	X, r24
		CLR_BIT(TCCR1B,WGM13);
     b7c:	ae e4       	ldi	r26, 0x4E	; 78
     b7e:	b0 e0       	ldi	r27, 0x00	; 0
     b80:	ee e4       	ldi	r30, 0x4E	; 78
     b82:	f0 e0       	ldi	r31, 0x00	; 0
     b84:	80 81       	ld	r24, Z
     b86:	8f 7e       	andi	r24, 0xEF	; 239
     b88:	8c 93       	st	X, r24
     b8a:	90 c0       	rjmp	.+288    	; 0xcac <TIMER1_Init+0x1c6>
		break;
		case TIMER1_CTC_ICR_TOP_MODE:
		CLR_BIT(TCCR1A,WGM10);
     b8c:	af e4       	ldi	r26, 0x4F	; 79
     b8e:	b0 e0       	ldi	r27, 0x00	; 0
     b90:	ef e4       	ldi	r30, 0x4F	; 79
     b92:	f0 e0       	ldi	r31, 0x00	; 0
     b94:	80 81       	ld	r24, Z
     b96:	8e 7f       	andi	r24, 0xFE	; 254
     b98:	8c 93       	st	X, r24
		CLR_BIT(TCCR1A,WGM11);
     b9a:	af e4       	ldi	r26, 0x4F	; 79
     b9c:	b0 e0       	ldi	r27, 0x00	; 0
     b9e:	ef e4       	ldi	r30, 0x4F	; 79
     ba0:	f0 e0       	ldi	r31, 0x00	; 0
     ba2:	80 81       	ld	r24, Z
     ba4:	8d 7f       	andi	r24, 0xFD	; 253
     ba6:	8c 93       	st	X, r24
		SET_BIT(TCCR1B,WGM12);
     ba8:	ae e4       	ldi	r26, 0x4E	; 78
     baa:	b0 e0       	ldi	r27, 0x00	; 0
     bac:	ee e4       	ldi	r30, 0x4E	; 78
     bae:	f0 e0       	ldi	r31, 0x00	; 0
     bb0:	80 81       	ld	r24, Z
     bb2:	88 60       	ori	r24, 0x08	; 8
     bb4:	8c 93       	st	X, r24
		SET_BIT(TCCR1B,WGM13);
     bb6:	ae e4       	ldi	r26, 0x4E	; 78
     bb8:	b0 e0       	ldi	r27, 0x00	; 0
     bba:	ee e4       	ldi	r30, 0x4E	; 78
     bbc:	f0 e0       	ldi	r31, 0x00	; 0
     bbe:	80 81       	ld	r24, Z
     bc0:	80 61       	ori	r24, 0x10	; 16
     bc2:	8c 93       	st	X, r24
     bc4:	73 c0       	rjmp	.+230    	; 0xcac <TIMER1_Init+0x1c6>
		break;
		case TIMER1_CTC_OCRA_TOP_MODE:
		CLR_BIT(TCCR1A,WGM10);
     bc6:	af e4       	ldi	r26, 0x4F	; 79
     bc8:	b0 e0       	ldi	r27, 0x00	; 0
     bca:	ef e4       	ldi	r30, 0x4F	; 79
     bcc:	f0 e0       	ldi	r31, 0x00	; 0
     bce:	80 81       	ld	r24, Z
     bd0:	8e 7f       	andi	r24, 0xFE	; 254
     bd2:	8c 93       	st	X, r24
		CLR_BIT(TCCR1A,WGM11);
     bd4:	af e4       	ldi	r26, 0x4F	; 79
     bd6:	b0 e0       	ldi	r27, 0x00	; 0
     bd8:	ef e4       	ldi	r30, 0x4F	; 79
     bda:	f0 e0       	ldi	r31, 0x00	; 0
     bdc:	80 81       	ld	r24, Z
     bde:	8d 7f       	andi	r24, 0xFD	; 253
     be0:	8c 93       	st	X, r24
		SET_BIT(TCCR1B,WGM12);
     be2:	ae e4       	ldi	r26, 0x4E	; 78
     be4:	b0 e0       	ldi	r27, 0x00	; 0
     be6:	ee e4       	ldi	r30, 0x4E	; 78
     be8:	f0 e0       	ldi	r31, 0x00	; 0
     bea:	80 81       	ld	r24, Z
     bec:	88 60       	ori	r24, 0x08	; 8
     bee:	8c 93       	st	X, r24
		CLR_BIT(TCCR1B,WGM13);
     bf0:	ae e4       	ldi	r26, 0x4E	; 78
     bf2:	b0 e0       	ldi	r27, 0x00	; 0
     bf4:	ee e4       	ldi	r30, 0x4E	; 78
     bf6:	f0 e0       	ldi	r31, 0x00	; 0
     bf8:	80 81       	ld	r24, Z
     bfa:	8f 7e       	andi	r24, 0xEF	; 239
     bfc:	8c 93       	st	X, r24
     bfe:	56 c0       	rjmp	.+172    	; 0xcac <TIMER1_Init+0x1c6>
		break;
		case TIMER1_FASTPWM_ICR_TOP_MODE:
		CLR_BIT(TCCR1A,WGM10);
     c00:	af e4       	ldi	r26, 0x4F	; 79
     c02:	b0 e0       	ldi	r27, 0x00	; 0
     c04:	ef e4       	ldi	r30, 0x4F	; 79
     c06:	f0 e0       	ldi	r31, 0x00	; 0
     c08:	80 81       	ld	r24, Z
     c0a:	8e 7f       	andi	r24, 0xFE	; 254
     c0c:	8c 93       	st	X, r24
		SET_BIT(TCCR1A,WGM11);
     c0e:	af e4       	ldi	r26, 0x4F	; 79
     c10:	b0 e0       	ldi	r27, 0x00	; 0
     c12:	ef e4       	ldi	r30, 0x4F	; 79
     c14:	f0 e0       	ldi	r31, 0x00	; 0
     c16:	80 81       	ld	r24, Z
     c18:	82 60       	ori	r24, 0x02	; 2
     c1a:	8c 93       	st	X, r24
		SET_BIT(TCCR1B,WGM12);
     c1c:	ae e4       	ldi	r26, 0x4E	; 78
     c1e:	b0 e0       	ldi	r27, 0x00	; 0
     c20:	ee e4       	ldi	r30, 0x4E	; 78
     c22:	f0 e0       	ldi	r31, 0x00	; 0
     c24:	80 81       	ld	r24, Z
     c26:	88 60       	ori	r24, 0x08	; 8
     c28:	8c 93       	st	X, r24
		SET_BIT(TCCR1B,WGM13);
     c2a:	ae e4       	ldi	r26, 0x4E	; 78
     c2c:	b0 e0       	ldi	r27, 0x00	; 0
     c2e:	ee e4       	ldi	r30, 0x4E	; 78
     c30:	f0 e0       	ldi	r31, 0x00	; 0
     c32:	80 81       	ld	r24, Z
     c34:	80 61       	ori	r24, 0x10	; 16
     c36:	8c 93       	st	X, r24
     c38:	39 c0       	rjmp	.+114    	; 0xcac <TIMER1_Init+0x1c6>
		break;
		case TIMER1_FASTPWM_OCRA_TOP_MODE:
		SET_BIT(TCCR1A,WGM10);
     c3a:	af e4       	ldi	r26, 0x4F	; 79
     c3c:	b0 e0       	ldi	r27, 0x00	; 0
     c3e:	ef e4       	ldi	r30, 0x4F	; 79
     c40:	f0 e0       	ldi	r31, 0x00	; 0
     c42:	80 81       	ld	r24, Z
     c44:	81 60       	ori	r24, 0x01	; 1
     c46:	8c 93       	st	X, r24
		SET_BIT(TCCR1A,WGM11);
     c48:	af e4       	ldi	r26, 0x4F	; 79
     c4a:	b0 e0       	ldi	r27, 0x00	; 0
     c4c:	ef e4       	ldi	r30, 0x4F	; 79
     c4e:	f0 e0       	ldi	r31, 0x00	; 0
     c50:	80 81       	ld	r24, Z
     c52:	82 60       	ori	r24, 0x02	; 2
     c54:	8c 93       	st	X, r24
		SET_BIT(TCCR1B,WGM12);
     c56:	ae e4       	ldi	r26, 0x4E	; 78
     c58:	b0 e0       	ldi	r27, 0x00	; 0
     c5a:	ee e4       	ldi	r30, 0x4E	; 78
     c5c:	f0 e0       	ldi	r31, 0x00	; 0
     c5e:	80 81       	ld	r24, Z
     c60:	88 60       	ori	r24, 0x08	; 8
     c62:	8c 93       	st	X, r24
		SET_BIT(TCCR1B,WGM13);
     c64:	ae e4       	ldi	r26, 0x4E	; 78
     c66:	b0 e0       	ldi	r27, 0x00	; 0
     c68:	ee e4       	ldi	r30, 0x4E	; 78
     c6a:	f0 e0       	ldi	r31, 0x00	; 0
     c6c:	80 81       	ld	r24, Z
     c6e:	80 61       	ori	r24, 0x10	; 16
     c70:	8c 93       	st	X, r24
     c72:	1c c0       	rjmp	.+56     	; 0xcac <TIMER1_Init+0x1c6>
		break;
		case TIMER1_NORMAL_8bit_MODE:
		
		SET_BIT(TCCR1A,WGM10);
     c74:	af e4       	ldi	r26, 0x4F	; 79
     c76:	b0 e0       	ldi	r27, 0x00	; 0
     c78:	ef e4       	ldi	r30, 0x4F	; 79
     c7a:	f0 e0       	ldi	r31, 0x00	; 0
     c7c:	80 81       	ld	r24, Z
     c7e:	81 60       	ori	r24, 0x01	; 1
     c80:	8c 93       	st	X, r24
		CLR_BIT(TCCR1A,WGM11);
     c82:	af e4       	ldi	r26, 0x4F	; 79
     c84:	b0 e0       	ldi	r27, 0x00	; 0
     c86:	ef e4       	ldi	r30, 0x4F	; 79
     c88:	f0 e0       	ldi	r31, 0x00	; 0
     c8a:	80 81       	ld	r24, Z
     c8c:	8d 7f       	andi	r24, 0xFD	; 253
     c8e:	8c 93       	st	X, r24
		CLR_BIT(TCCR1B,WGM12);
     c90:	ae e4       	ldi	r26, 0x4E	; 78
     c92:	b0 e0       	ldi	r27, 0x00	; 0
     c94:	ee e4       	ldi	r30, 0x4E	; 78
     c96:	f0 e0       	ldi	r31, 0x00	; 0
     c98:	80 81       	ld	r24, Z
     c9a:	87 7f       	andi	r24, 0xF7	; 247
     c9c:	8c 93       	st	X, r24
		CLR_BIT(TCCR1B,WGM13);
     c9e:	ae e4       	ldi	r26, 0x4E	; 78
     ca0:	b0 e0       	ldi	r27, 0x00	; 0
     ca2:	ee e4       	ldi	r30, 0x4E	; 78
     ca4:	f0 e0       	ldi	r31, 0x00	; 0
     ca6:	80 81       	ld	r24, Z
     ca8:	8f 7e       	andi	r24, 0xEF	; 239
     caa:	8c 93       	st	X, r24
		break;
	}
	TCCR1B&=0xF8;//0b11111000
     cac:	ae e4       	ldi	r26, 0x4E	; 78
     cae:	b0 e0       	ldi	r27, 0x00	; 0
     cb0:	ee e4       	ldi	r30, 0x4E	; 78
     cb2:	f0 e0       	ldi	r31, 0x00	; 0
     cb4:	80 81       	ld	r24, Z
     cb6:	88 7f       	andi	r24, 0xF8	; 248
     cb8:	8c 93       	st	X, r24
	scaler&=0x07;//Filter
     cba:	8a 81       	ldd	r24, Y+2	; 0x02
     cbc:	87 70       	andi	r24, 0x07	; 7
     cbe:	8a 83       	std	Y+2, r24	; 0x02
	TCCR1B|=scaler;
     cc0:	ae e4       	ldi	r26, 0x4E	; 78
     cc2:	b0 e0       	ldi	r27, 0x00	; 0
     cc4:	ee e4       	ldi	r30, 0x4E	; 78
     cc6:	f0 e0       	ldi	r31, 0x00	; 0
     cc8:	90 81       	ld	r25, Z
     cca:	8a 81       	ldd	r24, Y+2	; 0x02
     ccc:	89 2b       	or	r24, r25
     cce:	8c 93       	st	X, r24
}
     cd0:	0f 90       	pop	r0
     cd2:	0f 90       	pop	r0
     cd4:	0f 90       	pop	r0
     cd6:	0f 90       	pop	r0
     cd8:	cf 91       	pop	r28
     cda:	df 91       	pop	r29
     cdc:	08 95       	ret

00000cde <TIMER1_OC1AMode>:
void TIMER1_OC1AMode (OC1A_Mode_type local_mode)
{
     cde:	df 93       	push	r29
     ce0:	cf 93       	push	r28
     ce2:	00 d0       	rcall	.+0      	; 0xce4 <TIMER1_OC1AMode+0x6>
     ce4:	0f 92       	push	r0
     ce6:	cd b7       	in	r28, 0x3d	; 61
     ce8:	de b7       	in	r29, 0x3e	; 62
     cea:	89 83       	std	Y+1, r24	; 0x01
	switch(local_mode)
     cec:	89 81       	ldd	r24, Y+1	; 0x01
     cee:	28 2f       	mov	r18, r24
     cf0:	30 e0       	ldi	r19, 0x00	; 0
     cf2:	3b 83       	std	Y+3, r19	; 0x03
     cf4:	2a 83       	std	Y+2, r18	; 0x02
     cf6:	8a 81       	ldd	r24, Y+2	; 0x02
     cf8:	9b 81       	ldd	r25, Y+3	; 0x03
     cfa:	81 30       	cpi	r24, 0x01	; 1
     cfc:	91 05       	cpc	r25, r1
     cfe:	21 f1       	breq	.+72     	; 0xd48 <TIMER1_OC1AMode+0x6a>
     d00:	2a 81       	ldd	r18, Y+2	; 0x02
     d02:	3b 81       	ldd	r19, Y+3	; 0x03
     d04:	22 30       	cpi	r18, 0x02	; 2
     d06:	31 05       	cpc	r19, r1
     d08:	2c f4       	brge	.+10     	; 0xd14 <TIMER1_OC1AMode+0x36>
     d0a:	8a 81       	ldd	r24, Y+2	; 0x02
     d0c:	9b 81       	ldd	r25, Y+3	; 0x03
     d0e:	00 97       	sbiw	r24, 0x00	; 0
     d10:	61 f0       	breq	.+24     	; 0xd2a <TIMER1_OC1AMode+0x4c>
     d12:	4c c0       	rjmp	.+152    	; 0xdac <TIMER1_OC1AMode+0xce>
     d14:	2a 81       	ldd	r18, Y+2	; 0x02
     d16:	3b 81       	ldd	r19, Y+3	; 0x03
     d18:	22 30       	cpi	r18, 0x02	; 2
     d1a:	31 05       	cpc	r19, r1
     d1c:	51 f1       	breq	.+84     	; 0xd72 <TIMER1_OC1AMode+0x94>
     d1e:	8a 81       	ldd	r24, Y+2	; 0x02
     d20:	9b 81       	ldd	r25, Y+3	; 0x03
     d22:	83 30       	cpi	r24, 0x03	; 3
     d24:	91 05       	cpc	r25, r1
     d26:	a1 f1       	breq	.+104    	; 0xd90 <TIMER1_OC1AMode+0xb2>
     d28:	41 c0       	rjmp	.+130    	; 0xdac <TIMER1_OC1AMode+0xce>
	{
		case OCRA_DISCONNECTED:
		CLR_BIT(TCCR1A,COM1A0);
     d2a:	af e4       	ldi	r26, 0x4F	; 79
     d2c:	b0 e0       	ldi	r27, 0x00	; 0
     d2e:	ef e4       	ldi	r30, 0x4F	; 79
     d30:	f0 e0       	ldi	r31, 0x00	; 0
     d32:	80 81       	ld	r24, Z
     d34:	8f 7b       	andi	r24, 0xBF	; 191
     d36:	8c 93       	st	X, r24
		CLR_BIT(TCCR1A,COM1A1);
     d38:	af e4       	ldi	r26, 0x4F	; 79
     d3a:	b0 e0       	ldi	r27, 0x00	; 0
     d3c:	ef e4       	ldi	r30, 0x4F	; 79
     d3e:	f0 e0       	ldi	r31, 0x00	; 0
     d40:	80 81       	ld	r24, Z
     d42:	8f 77       	andi	r24, 0x7F	; 127
     d44:	8c 93       	st	X, r24
     d46:	32 c0       	rjmp	.+100    	; 0xdac <TIMER1_OC1AMode+0xce>
		break;
		case OCRA_TOGGLE:
		SET_BIT(TCCR1A,COM1A0);
     d48:	af e4       	ldi	r26, 0x4F	; 79
     d4a:	b0 e0       	ldi	r27, 0x00	; 0
     d4c:	ef e4       	ldi	r30, 0x4F	; 79
     d4e:	f0 e0       	ldi	r31, 0x00	; 0
     d50:	80 81       	ld	r24, Z
     d52:	80 64       	ori	r24, 0x40	; 64
     d54:	8c 93       	st	X, r24
		CLR_BIT(TCCR1A,COM1A1);
     d56:	af e4       	ldi	r26, 0x4F	; 79
     d58:	b0 e0       	ldi	r27, 0x00	; 0
     d5a:	ef e4       	ldi	r30, 0x4F	; 79
     d5c:	f0 e0       	ldi	r31, 0x00	; 0
     d5e:	80 81       	ld	r24, Z
     d60:	8f 77       	andi	r24, 0x7F	; 127
     d62:	8c 93       	st	X, r24
		OCR1A=250;
     d64:	ea e4       	ldi	r30, 0x4A	; 74
     d66:	f0 e0       	ldi	r31, 0x00	; 0
     d68:	8a ef       	ldi	r24, 0xFA	; 250
     d6a:	90 e0       	ldi	r25, 0x00	; 0
     d6c:	91 83       	std	Z+1, r25	; 0x01
     d6e:	80 83       	st	Z, r24
     d70:	1d c0       	rjmp	.+58     	; 0xdac <TIMER1_OC1AMode+0xce>
		break;
		case OCRA_NON_INVERTING:
		CLR_BIT(TCCR1A,COM1A0);
     d72:	af e4       	ldi	r26, 0x4F	; 79
     d74:	b0 e0       	ldi	r27, 0x00	; 0
     d76:	ef e4       	ldi	r30, 0x4F	; 79
     d78:	f0 e0       	ldi	r31, 0x00	; 0
     d7a:	80 81       	ld	r24, Z
     d7c:	8f 7b       	andi	r24, 0xBF	; 191
     d7e:	8c 93       	st	X, r24
		SET_BIT(TCCR1A,COM1A1);
     d80:	af e4       	ldi	r26, 0x4F	; 79
     d82:	b0 e0       	ldi	r27, 0x00	; 0
     d84:	ef e4       	ldi	r30, 0x4F	; 79
     d86:	f0 e0       	ldi	r31, 0x00	; 0
     d88:	80 81       	ld	r24, Z
     d8a:	80 68       	ori	r24, 0x80	; 128
     d8c:	8c 93       	st	X, r24
     d8e:	0e c0       	rjmp	.+28     	; 0xdac <TIMER1_OC1AMode+0xce>
		break;
		case OCRA_INVERTING:
		SET_BIT(TCCR1A,COM1A0);
     d90:	af e4       	ldi	r26, 0x4F	; 79
     d92:	b0 e0       	ldi	r27, 0x00	; 0
     d94:	ef e4       	ldi	r30, 0x4F	; 79
     d96:	f0 e0       	ldi	r31, 0x00	; 0
     d98:	80 81       	ld	r24, Z
     d9a:	80 64       	ori	r24, 0x40	; 64
     d9c:	8c 93       	st	X, r24
		SET_BIT(TCCR1A,COM1A1);
     d9e:	af e4       	ldi	r26, 0x4F	; 79
     da0:	b0 e0       	ldi	r27, 0x00	; 0
     da2:	ef e4       	ldi	r30, 0x4F	; 79
     da4:	f0 e0       	ldi	r31, 0x00	; 0
     da6:	80 81       	ld	r24, Z
     da8:	80 68       	ori	r24, 0x80	; 128
     daa:	8c 93       	st	X, r24
		break;
	}
}
     dac:	0f 90       	pop	r0
     dae:	0f 90       	pop	r0
     db0:	0f 90       	pop	r0
     db2:	cf 91       	pop	r28
     db4:	df 91       	pop	r29
     db6:	08 95       	ret

00000db8 <TIMER1_OC1BMode>:
void TIMER1_OC1BMode (OC1B_Mode_type local_mode)
{
     db8:	df 93       	push	r29
     dba:	cf 93       	push	r28
     dbc:	00 d0       	rcall	.+0      	; 0xdbe <TIMER1_OC1BMode+0x6>
     dbe:	0f 92       	push	r0
     dc0:	cd b7       	in	r28, 0x3d	; 61
     dc2:	de b7       	in	r29, 0x3e	; 62
     dc4:	89 83       	std	Y+1, r24	; 0x01
	switch(local_mode)
     dc6:	89 81       	ldd	r24, Y+1	; 0x01
     dc8:	28 2f       	mov	r18, r24
     dca:	30 e0       	ldi	r19, 0x00	; 0
     dcc:	3b 83       	std	Y+3, r19	; 0x03
     dce:	2a 83       	std	Y+2, r18	; 0x02
     dd0:	8a 81       	ldd	r24, Y+2	; 0x02
     dd2:	9b 81       	ldd	r25, Y+3	; 0x03
     dd4:	81 30       	cpi	r24, 0x01	; 1
     dd6:	91 05       	cpc	r25, r1
     dd8:	21 f1       	breq	.+72     	; 0xe22 <TIMER1_OC1BMode+0x6a>
     dda:	2a 81       	ldd	r18, Y+2	; 0x02
     ddc:	3b 81       	ldd	r19, Y+3	; 0x03
     dde:	22 30       	cpi	r18, 0x02	; 2
     de0:	31 05       	cpc	r19, r1
     de2:	2c f4       	brge	.+10     	; 0xdee <TIMER1_OC1BMode+0x36>
     de4:	8a 81       	ldd	r24, Y+2	; 0x02
     de6:	9b 81       	ldd	r25, Y+3	; 0x03
     de8:	00 97       	sbiw	r24, 0x00	; 0
     dea:	61 f0       	breq	.+24     	; 0xe04 <TIMER1_OC1BMode+0x4c>
     dec:	46 c0       	rjmp	.+140    	; 0xe7a <TIMER1_OC1BMode+0xc2>
     dee:	2a 81       	ldd	r18, Y+2	; 0x02
     df0:	3b 81       	ldd	r19, Y+3	; 0x03
     df2:	22 30       	cpi	r18, 0x02	; 2
     df4:	31 05       	cpc	r19, r1
     df6:	21 f1       	breq	.+72     	; 0xe40 <TIMER1_OC1BMode+0x88>
     df8:	8a 81       	ldd	r24, Y+2	; 0x02
     dfa:	9b 81       	ldd	r25, Y+3	; 0x03
     dfc:	83 30       	cpi	r24, 0x03	; 3
     dfe:	91 05       	cpc	r25, r1
     e00:	71 f1       	breq	.+92     	; 0xe5e <TIMER1_OC1BMode+0xa6>
     e02:	3b c0       	rjmp	.+118    	; 0xe7a <TIMER1_OC1BMode+0xc2>
	{
		case OCRB_DISCONNECTED:
		CLR_BIT(TCCR1A,COM1B0);
     e04:	af e4       	ldi	r26, 0x4F	; 79
     e06:	b0 e0       	ldi	r27, 0x00	; 0
     e08:	ef e4       	ldi	r30, 0x4F	; 79
     e0a:	f0 e0       	ldi	r31, 0x00	; 0
     e0c:	80 81       	ld	r24, Z
     e0e:	8f 7e       	andi	r24, 0xEF	; 239
     e10:	8c 93       	st	X, r24
		CLR_BIT(TCCR1A,COM1B1);
     e12:	af e4       	ldi	r26, 0x4F	; 79
     e14:	b0 e0       	ldi	r27, 0x00	; 0
     e16:	ef e4       	ldi	r30, 0x4F	; 79
     e18:	f0 e0       	ldi	r31, 0x00	; 0
     e1a:	80 81       	ld	r24, Z
     e1c:	8f 7d       	andi	r24, 0xDF	; 223
     e1e:	8c 93       	st	X, r24
     e20:	2c c0       	rjmp	.+88     	; 0xe7a <TIMER1_OC1BMode+0xc2>
		break;
		case OCRB_TOGGLE:
		SET_BIT(TCCR1A,COM1B0);
     e22:	af e4       	ldi	r26, 0x4F	; 79
     e24:	b0 e0       	ldi	r27, 0x00	; 0
     e26:	ef e4       	ldi	r30, 0x4F	; 79
     e28:	f0 e0       	ldi	r31, 0x00	; 0
     e2a:	80 81       	ld	r24, Z
     e2c:	80 61       	ori	r24, 0x10	; 16
     e2e:	8c 93       	st	X, r24
		CLR_BIT(TCCR1A,COM1B1);
     e30:	af e4       	ldi	r26, 0x4F	; 79
     e32:	b0 e0       	ldi	r27, 0x00	; 0
     e34:	ef e4       	ldi	r30, 0x4F	; 79
     e36:	f0 e0       	ldi	r31, 0x00	; 0
     e38:	80 81       	ld	r24, Z
     e3a:	8f 7d       	andi	r24, 0xDF	; 223
     e3c:	8c 93       	st	X, r24
     e3e:	1d c0       	rjmp	.+58     	; 0xe7a <TIMER1_OC1BMode+0xc2>
		break;
		case OCRB_NON_INVERTING:
		CLR_BIT(TCCR1A,COM1B0);
     e40:	af e4       	ldi	r26, 0x4F	; 79
     e42:	b0 e0       	ldi	r27, 0x00	; 0
     e44:	ef e4       	ldi	r30, 0x4F	; 79
     e46:	f0 e0       	ldi	r31, 0x00	; 0
     e48:	80 81       	ld	r24, Z
     e4a:	8f 7e       	andi	r24, 0xEF	; 239
     e4c:	8c 93       	st	X, r24
		SET_BIT(TCCR1A,COM1B1);
     e4e:	af e4       	ldi	r26, 0x4F	; 79
     e50:	b0 e0       	ldi	r27, 0x00	; 0
     e52:	ef e4       	ldi	r30, 0x4F	; 79
     e54:	f0 e0       	ldi	r31, 0x00	; 0
     e56:	80 81       	ld	r24, Z
     e58:	80 62       	ori	r24, 0x20	; 32
     e5a:	8c 93       	st	X, r24
     e5c:	0e c0       	rjmp	.+28     	; 0xe7a <TIMER1_OC1BMode+0xc2>
		break;
		case OCRB_INVERTING:
		SET_BIT(TCCR1A,COM1B0);
     e5e:	af e4       	ldi	r26, 0x4F	; 79
     e60:	b0 e0       	ldi	r27, 0x00	; 0
     e62:	ef e4       	ldi	r30, 0x4F	; 79
     e64:	f0 e0       	ldi	r31, 0x00	; 0
     e66:	80 81       	ld	r24, Z
     e68:	80 61       	ori	r24, 0x10	; 16
     e6a:	8c 93       	st	X, r24
		SET_BIT(TCCR1A,COM1B1);
     e6c:	af e4       	ldi	r26, 0x4F	; 79
     e6e:	b0 e0       	ldi	r27, 0x00	; 0
     e70:	ef e4       	ldi	r30, 0x4F	; 79
     e72:	f0 e0       	ldi	r31, 0x00	; 0
     e74:	80 81       	ld	r24, Z
     e76:	80 62       	ori	r24, 0x20	; 32
     e78:	8c 93       	st	X, r24
		break;
	}
}
     e7a:	0f 90       	pop	r0
     e7c:	0f 90       	pop	r0
     e7e:	0f 90       	pop	r0
     e80:	cf 91       	pop	r28
     e82:	df 91       	pop	r29
     e84:	08 95       	ret

00000e86 <TIMER1_ICU_Edge>:
void TIMER1_ICU_Edge(ICU_Edge_type local_edge)
{
     e86:	df 93       	push	r29
     e88:	cf 93       	push	r28
     e8a:	00 d0       	rcall	.+0      	; 0xe8c <TIMER1_ICU_Edge+0x6>
     e8c:	0f 92       	push	r0
     e8e:	cd b7       	in	r28, 0x3d	; 61
     e90:	de b7       	in	r29, 0x3e	; 62
     e92:	89 83       	std	Y+1, r24	; 0x01
	switch(local_edge)
     e94:	89 81       	ldd	r24, Y+1	; 0x01
     e96:	28 2f       	mov	r18, r24
     e98:	30 e0       	ldi	r19, 0x00	; 0
     e9a:	3b 83       	std	Y+3, r19	; 0x03
     e9c:	2a 83       	std	Y+2, r18	; 0x02
     e9e:	8a 81       	ldd	r24, Y+2	; 0x02
     ea0:	9b 81       	ldd	r25, Y+3	; 0x03
     ea2:	00 97       	sbiw	r24, 0x00	; 0
     ea4:	31 f0       	breq	.+12     	; 0xeb2 <TIMER1_ICU_Edge+0x2c>
     ea6:	2a 81       	ldd	r18, Y+2	; 0x02
     ea8:	3b 81       	ldd	r19, Y+3	; 0x03
     eaa:	21 30       	cpi	r18, 0x01	; 1
     eac:	31 05       	cpc	r19, r1
     eae:	49 f0       	breq	.+18     	; 0xec2 <TIMER1_ICU_Edge+0x3c>
     eb0:	0f c0       	rjmp	.+30     	; 0xed0 <TIMER1_ICU_Edge+0x4a>
	{
		case RISING:
		SET_BIT	(TCCR1B,ICES1);
     eb2:	ae e4       	ldi	r26, 0x4E	; 78
     eb4:	b0 e0       	ldi	r27, 0x00	; 0
     eb6:	ee e4       	ldi	r30, 0x4E	; 78
     eb8:	f0 e0       	ldi	r31, 0x00	; 0
     eba:	80 81       	ld	r24, Z
     ebc:	80 64       	ori	r24, 0x40	; 64
     ebe:	8c 93       	st	X, r24
     ec0:	07 c0       	rjmp	.+14     	; 0xed0 <TIMER1_ICU_Edge+0x4a>
		break;
		case FALLING:
		CLR_BIT(TCCR1B,ICES1);
     ec2:	ae e4       	ldi	r26, 0x4E	; 78
     ec4:	b0 e0       	ldi	r27, 0x00	; 0
     ec6:	ee e4       	ldi	r30, 0x4E	; 78
     ec8:	f0 e0       	ldi	r31, 0x00	; 0
     eca:	80 81       	ld	r24, Z
     ecc:	8f 7b       	andi	r24, 0xBF	; 191
     ece:	8c 93       	st	X, r24
		break;
	}
}
     ed0:	0f 90       	pop	r0
     ed2:	0f 90       	pop	r0
     ed4:	0f 90       	pop	r0
     ed6:	cf 91       	pop	r28
     ed8:	df 91       	pop	r29
     eda:	08 95       	ret

00000edc <TIMER1_OVF_Enable>:

void TIMER1_OVF_Enable (void)
{
     edc:	df 93       	push	r29
     ede:	cf 93       	push	r28
     ee0:	cd b7       	in	r28, 0x3d	; 61
     ee2:	de b7       	in	r29, 0x3e	; 62
	SET_BIT	(TIMSK,TOIE1);
     ee4:	a7 e5       	ldi	r26, 0x57	; 87
     ee6:	b0 e0       	ldi	r27, 0x00	; 0
     ee8:	e7 e5       	ldi	r30, 0x57	; 87
     eea:	f0 e0       	ldi	r31, 0x00	; 0
     eec:	80 81       	ld	r24, Z
     eee:	84 60       	ori	r24, 0x04	; 4
     ef0:	8c 93       	st	X, r24
}
     ef2:	cf 91       	pop	r28
     ef4:	df 91       	pop	r29
     ef6:	08 95       	ret

00000ef8 <TIMER1_OVF_Disable>:
void TIMER1_OVF_Disable (void)
{
     ef8:	df 93       	push	r29
     efa:	cf 93       	push	r28
     efc:	cd b7       	in	r28, 0x3d	; 61
     efe:	de b7       	in	r29, 0x3e	; 62
	CLR_BIT(TIMSK,TOIE1);
     f00:	a7 e5       	ldi	r26, 0x57	; 87
     f02:	b0 e0       	ldi	r27, 0x00	; 0
     f04:	e7 e5       	ldi	r30, 0x57	; 87
     f06:	f0 e0       	ldi	r31, 0x00	; 0
     f08:	80 81       	ld	r24, Z
     f0a:	8b 7f       	andi	r24, 0xFB	; 251
     f0c:	8c 93       	st	X, r24
}
     f0e:	cf 91       	pop	r28
     f10:	df 91       	pop	r29
     f12:	08 95       	ret

00000f14 <TIMER1_OC1A_Enable>:

void TIMER1_OC1A_Enable (void)
{
     f14:	df 93       	push	r29
     f16:	cf 93       	push	r28
     f18:	cd b7       	in	r28, 0x3d	; 61
     f1a:	de b7       	in	r29, 0x3e	; 62
	SET_BIT	(TIMSK,OCIE1A);
     f1c:	a7 e5       	ldi	r26, 0x57	; 87
     f1e:	b0 e0       	ldi	r27, 0x00	; 0
     f20:	e7 e5       	ldi	r30, 0x57	; 87
     f22:	f0 e0       	ldi	r31, 0x00	; 0
     f24:	80 81       	ld	r24, Z
     f26:	80 61       	ori	r24, 0x10	; 16
     f28:	8c 93       	st	X, r24
}
     f2a:	cf 91       	pop	r28
     f2c:	df 91       	pop	r29
     f2e:	08 95       	ret

00000f30 <TIMER1_OC1A_Disable>:
void TIMER1_OC1A_Disable (void)
{
     f30:	df 93       	push	r29
     f32:	cf 93       	push	r28
     f34:	cd b7       	in	r28, 0x3d	; 61
     f36:	de b7       	in	r29, 0x3e	; 62
	CLR_BIT(TIMSK,OCIE1A);
     f38:	a7 e5       	ldi	r26, 0x57	; 87
     f3a:	b0 e0       	ldi	r27, 0x00	; 0
     f3c:	e7 e5       	ldi	r30, 0x57	; 87
     f3e:	f0 e0       	ldi	r31, 0x00	; 0
     f40:	80 81       	ld	r24, Z
     f42:	8f 7e       	andi	r24, 0xEF	; 239
     f44:	8c 93       	st	X, r24
}
     f46:	cf 91       	pop	r28
     f48:	df 91       	pop	r29
     f4a:	08 95       	ret

00000f4c <TIMER1_OC1B_Enable>:
void TIMER1_OC1B_Enable (void)
{
     f4c:	df 93       	push	r29
     f4e:	cf 93       	push	r28
     f50:	cd b7       	in	r28, 0x3d	; 61
     f52:	de b7       	in	r29, 0x3e	; 62
	SET_BIT	(TIMSK,OCIE1B);
     f54:	a7 e5       	ldi	r26, 0x57	; 87
     f56:	b0 e0       	ldi	r27, 0x00	; 0
     f58:	e7 e5       	ldi	r30, 0x57	; 87
     f5a:	f0 e0       	ldi	r31, 0x00	; 0
     f5c:	80 81       	ld	r24, Z
     f5e:	88 60       	ori	r24, 0x08	; 8
     f60:	8c 93       	st	X, r24
}
     f62:	cf 91       	pop	r28
     f64:	df 91       	pop	r29
     f66:	08 95       	ret

00000f68 <TIMER1_OC1B_Disable>:
void TIMER1_OC1B_Disable (void)
{
     f68:	df 93       	push	r29
     f6a:	cf 93       	push	r28
     f6c:	cd b7       	in	r28, 0x3d	; 61
     f6e:	de b7       	in	r29, 0x3e	; 62
	CLR_BIT(TIMSK,OCIE1B);
     f70:	a7 e5       	ldi	r26, 0x57	; 87
     f72:	b0 e0       	ldi	r27, 0x00	; 0
     f74:	e7 e5       	ldi	r30, 0x57	; 87
     f76:	f0 e0       	ldi	r31, 0x00	; 0
     f78:	80 81       	ld	r24, Z
     f7a:	87 7f       	andi	r24, 0xF7	; 247
     f7c:	8c 93       	st	X, r24
}
     f7e:	cf 91       	pop	r28
     f80:	df 91       	pop	r29
     f82:	08 95       	ret

00000f84 <TIMER1_ICU_Enable>:

void TIMER1_ICU_Enable (void)
{
     f84:	df 93       	push	r29
     f86:	cf 93       	push	r28
     f88:	cd b7       	in	r28, 0x3d	; 61
     f8a:	de b7       	in	r29, 0x3e	; 62
	SET_BIT	(TIMSK,TICIE1);
     f8c:	a7 e5       	ldi	r26, 0x57	; 87
     f8e:	b0 e0       	ldi	r27, 0x00	; 0
     f90:	e7 e5       	ldi	r30, 0x57	; 87
     f92:	f0 e0       	ldi	r31, 0x00	; 0
     f94:	80 81       	ld	r24, Z
     f96:	80 62       	ori	r24, 0x20	; 32
     f98:	8c 93       	st	X, r24
}
     f9a:	cf 91       	pop	r28
     f9c:	df 91       	pop	r29
     f9e:	08 95       	ret

00000fa0 <TIMER1_ICU_Disable>:
void TIMER1_ICU_Disable (void)
{
     fa0:	df 93       	push	r29
     fa2:	cf 93       	push	r28
     fa4:	cd b7       	in	r28, 0x3d	; 61
     fa6:	de b7       	in	r29, 0x3e	; 62
	CLR_BIT(TIMSK,TICIE1);
     fa8:	a7 e5       	ldi	r26, 0x57	; 87
     faa:	b0 e0       	ldi	r27, 0x00	; 0
     fac:	e7 e5       	ldi	r30, 0x57	; 87
     fae:	f0 e0       	ldi	r31, 0x00	; 0
     fb0:	80 81       	ld	r24, Z
     fb2:	8f 7d       	andi	r24, 0xDF	; 223
     fb4:	8c 93       	st	X, r24
}
     fb6:	cf 91       	pop	r28
     fb8:	df 91       	pop	r29
     fba:	08 95       	ret

00000fbc <TIMER1_OVF_SetCallBack>:

void TIMER1_OVF_SetCallBack (void(*local_fptr)(void))
{
     fbc:	df 93       	push	r29
     fbe:	cf 93       	push	r28
     fc0:	00 d0       	rcall	.+0      	; 0xfc2 <TIMER1_OVF_SetCallBack+0x6>
     fc2:	cd b7       	in	r28, 0x3d	; 61
     fc4:	de b7       	in	r29, 0x3e	; 62
     fc6:	9a 83       	std	Y+2, r25	; 0x02
     fc8:	89 83       	std	Y+1, r24	; 0x01
	local_fptr=Timer1_OVF_Fptr;
     fca:	80 91 9f 02 	lds	r24, 0x029F
     fce:	90 91 a0 02 	lds	r25, 0x02A0
     fd2:	9a 83       	std	Y+2, r25	; 0x02
     fd4:	89 83       	std	Y+1, r24	; 0x01
}
     fd6:	0f 90       	pop	r0
     fd8:	0f 90       	pop	r0
     fda:	cf 91       	pop	r28
     fdc:	df 91       	pop	r29
     fde:	08 95       	ret

00000fe0 <TIMER1_OC1A_SetCallBack>:
void TIMER1_OC1A_SetCallBack (void(*local_fptr)(void))
{
     fe0:	df 93       	push	r29
     fe2:	cf 93       	push	r28
     fe4:	00 d0       	rcall	.+0      	; 0xfe6 <TIMER1_OC1A_SetCallBack+0x6>
     fe6:	cd b7       	in	r28, 0x3d	; 61
     fe8:	de b7       	in	r29, 0x3e	; 62
     fea:	9a 83       	std	Y+2, r25	; 0x02
     fec:	89 83       	std	Y+1, r24	; 0x01
	Timer1_OCA_Fptr=local_fptr;
     fee:	89 81       	ldd	r24, Y+1	; 0x01
     ff0:	9a 81       	ldd	r25, Y+2	; 0x02
     ff2:	90 93 a2 02 	sts	0x02A2, r25
     ff6:	80 93 a1 02 	sts	0x02A1, r24
}
     ffa:	0f 90       	pop	r0
     ffc:	0f 90       	pop	r0
     ffe:	cf 91       	pop	r28
    1000:	df 91       	pop	r29
    1002:	08 95       	ret

00001004 <TIMER1_OC1B_SetCallBack>:
void TIMER1_OC1B_SetCallBack (void(*local_fptr)(void))
{
    1004:	df 93       	push	r29
    1006:	cf 93       	push	r28
    1008:	00 d0       	rcall	.+0      	; 0x100a <TIMER1_OC1B_SetCallBack+0x6>
    100a:	cd b7       	in	r28, 0x3d	; 61
    100c:	de b7       	in	r29, 0x3e	; 62
    100e:	9a 83       	std	Y+2, r25	; 0x02
    1010:	89 83       	std	Y+1, r24	; 0x01
	local_fptr=Timer1_OCB_Fptr;
    1012:	80 91 a3 02 	lds	r24, 0x02A3
    1016:	90 91 a4 02 	lds	r25, 0x02A4
    101a:	9a 83       	std	Y+2, r25	; 0x02
    101c:	89 83       	std	Y+1, r24	; 0x01
}
    101e:	0f 90       	pop	r0
    1020:	0f 90       	pop	r0
    1022:	cf 91       	pop	r28
    1024:	df 91       	pop	r29
    1026:	08 95       	ret

00001028 <TIMER1_ICU_SetCallBack>:
void TIMER1_ICU_SetCallBack (void(*local_fptr)(void))
{
    1028:	df 93       	push	r29
    102a:	cf 93       	push	r28
    102c:	00 d0       	rcall	.+0      	; 0x102e <TIMER1_ICU_SetCallBack+0x6>
    102e:	cd b7       	in	r28, 0x3d	; 61
    1030:	de b7       	in	r29, 0x3e	; 62
    1032:	9a 83       	std	Y+2, r25	; 0x02
    1034:	89 83       	std	Y+1, r24	; 0x01
	local_fptr=Timer1_ICU_Fptr;
    1036:	80 91 a5 02 	lds	r24, 0x02A5
    103a:	90 91 a6 02 	lds	r25, 0x02A6
    103e:	9a 83       	std	Y+2, r25	; 0x02
    1040:	89 83       	std	Y+1, r24	; 0x01
}
    1042:	0f 90       	pop	r0
    1044:	0f 90       	pop	r0
    1046:	cf 91       	pop	r28
    1048:	df 91       	pop	r29
    104a:	08 95       	ret

0000104c <__vector_14>:
ISR(TIMER1_OVF_vect)
{
    104c:	1f 92       	push	r1
    104e:	0f 92       	push	r0
    1050:	0f b6       	in	r0, 0x3f	; 63
    1052:	0f 92       	push	r0
    1054:	00 90 5b 00 	lds	r0, 0x005B
    1058:	0f 92       	push	r0
    105a:	11 24       	eor	r1, r1
    105c:	2f 93       	push	r18
    105e:	3f 93       	push	r19
    1060:	4f 93       	push	r20
    1062:	5f 93       	push	r21
    1064:	6f 93       	push	r22
    1066:	7f 93       	push	r23
    1068:	8f 93       	push	r24
    106a:	9f 93       	push	r25
    106c:	af 93       	push	r26
    106e:	bf 93       	push	r27
    1070:	ef 93       	push	r30
    1072:	ff 93       	push	r31
    1074:	df 93       	push	r29
    1076:	cf 93       	push	r28
    1078:	cd b7       	in	r28, 0x3d	; 61
    107a:	de b7       	in	r29, 0x3e	; 62
	
	if (Timer1_OVF_Fptr!=NULLPTR)
    107c:	80 91 9f 02 	lds	r24, 0x029F
    1080:	90 91 a0 02 	lds	r25, 0x02A0
    1084:	00 97       	sbiw	r24, 0x00	; 0
    1086:	29 f0       	breq	.+10     	; 0x1092 <__vector_14+0x46>
	{
		
		Timer1_OVF_Fptr();
    1088:	e0 91 9f 02 	lds	r30, 0x029F
    108c:	f0 91 a0 02 	lds	r31, 0x02A0
    1090:	09 95       	icall
	}
}
    1092:	cf 91       	pop	r28
    1094:	df 91       	pop	r29
    1096:	ff 91       	pop	r31
    1098:	ef 91       	pop	r30
    109a:	bf 91       	pop	r27
    109c:	af 91       	pop	r26
    109e:	9f 91       	pop	r25
    10a0:	8f 91       	pop	r24
    10a2:	7f 91       	pop	r23
    10a4:	6f 91       	pop	r22
    10a6:	5f 91       	pop	r21
    10a8:	4f 91       	pop	r20
    10aa:	3f 91       	pop	r19
    10ac:	2f 91       	pop	r18
    10ae:	0f 90       	pop	r0
    10b0:	00 92 5b 00 	sts	0x005B, r0
    10b4:	0f 90       	pop	r0
    10b6:	0f be       	out	0x3f, r0	; 63
    10b8:	0f 90       	pop	r0
    10ba:	1f 90       	pop	r1
    10bc:	18 95       	reti

000010be <__vector_13>:
ISR(TIMER1_OCB_vect)
{
    10be:	1f 92       	push	r1
    10c0:	0f 92       	push	r0
    10c2:	0f b6       	in	r0, 0x3f	; 63
    10c4:	0f 92       	push	r0
    10c6:	00 90 5b 00 	lds	r0, 0x005B
    10ca:	0f 92       	push	r0
    10cc:	11 24       	eor	r1, r1
    10ce:	2f 93       	push	r18
    10d0:	3f 93       	push	r19
    10d2:	4f 93       	push	r20
    10d4:	5f 93       	push	r21
    10d6:	6f 93       	push	r22
    10d8:	7f 93       	push	r23
    10da:	8f 93       	push	r24
    10dc:	9f 93       	push	r25
    10de:	af 93       	push	r26
    10e0:	bf 93       	push	r27
    10e2:	ef 93       	push	r30
    10e4:	ff 93       	push	r31
    10e6:	df 93       	push	r29
    10e8:	cf 93       	push	r28
    10ea:	cd b7       	in	r28, 0x3d	; 61
    10ec:	de b7       	in	r29, 0x3e	; 62
	if (Timer1_OCB_Fptr!=NULLPTR)
    10ee:	80 91 a3 02 	lds	r24, 0x02A3
    10f2:	90 91 a4 02 	lds	r25, 0x02A4
    10f6:	00 97       	sbiw	r24, 0x00	; 0
    10f8:	29 f0       	breq	.+10     	; 0x1104 <__stack+0x5>
	{
		Timer1_OCB_Fptr();
    10fa:	e0 91 a3 02 	lds	r30, 0x02A3
    10fe:	f0 91 a4 02 	lds	r31, 0x02A4
    1102:	09 95       	icall
	}
}
    1104:	cf 91       	pop	r28
    1106:	df 91       	pop	r29
    1108:	ff 91       	pop	r31
    110a:	ef 91       	pop	r30
    110c:	bf 91       	pop	r27
    110e:	af 91       	pop	r26
    1110:	9f 91       	pop	r25
    1112:	8f 91       	pop	r24
    1114:	7f 91       	pop	r23
    1116:	6f 91       	pop	r22
    1118:	5f 91       	pop	r21
    111a:	4f 91       	pop	r20
    111c:	3f 91       	pop	r19
    111e:	2f 91       	pop	r18
    1120:	0f 90       	pop	r0
    1122:	00 92 5b 00 	sts	0x005B, r0
    1126:	0f 90       	pop	r0
    1128:	0f be       	out	0x3f, r0	; 63
    112a:	0f 90       	pop	r0
    112c:	1f 90       	pop	r1
    112e:	18 95       	reti

00001130 <__vector_12>:
ISR(TIMER1_OCA_vect)
{
    1130:	1f 92       	push	r1
    1132:	0f 92       	push	r0
    1134:	0f b6       	in	r0, 0x3f	; 63
    1136:	0f 92       	push	r0
    1138:	00 90 5b 00 	lds	r0, 0x005B
    113c:	0f 92       	push	r0
    113e:	11 24       	eor	r1, r1
    1140:	2f 93       	push	r18
    1142:	3f 93       	push	r19
    1144:	4f 93       	push	r20
    1146:	5f 93       	push	r21
    1148:	6f 93       	push	r22
    114a:	7f 93       	push	r23
    114c:	8f 93       	push	r24
    114e:	9f 93       	push	r25
    1150:	af 93       	push	r26
    1152:	bf 93       	push	r27
    1154:	ef 93       	push	r30
    1156:	ff 93       	push	r31
    1158:	df 93       	push	r29
    115a:	cf 93       	push	r28
    115c:	cd b7       	in	r28, 0x3d	; 61
    115e:	de b7       	in	r29, 0x3e	; 62
	if (Timer1_OCA_Fptr!=NULLPTR)
    1160:	80 91 a1 02 	lds	r24, 0x02A1
    1164:	90 91 a2 02 	lds	r25, 0x02A2
    1168:	00 97       	sbiw	r24, 0x00	; 0
    116a:	29 f0       	breq	.+10     	; 0x1176 <__vector_12+0x46>
	{
		Timer1_OCA_Fptr();
    116c:	e0 91 a1 02 	lds	r30, 0x02A1
    1170:	f0 91 a2 02 	lds	r31, 0x02A2
    1174:	09 95       	icall
	}
}
    1176:	cf 91       	pop	r28
    1178:	df 91       	pop	r29
    117a:	ff 91       	pop	r31
    117c:	ef 91       	pop	r30
    117e:	bf 91       	pop	r27
    1180:	af 91       	pop	r26
    1182:	9f 91       	pop	r25
    1184:	8f 91       	pop	r24
    1186:	7f 91       	pop	r23
    1188:	6f 91       	pop	r22
    118a:	5f 91       	pop	r21
    118c:	4f 91       	pop	r20
    118e:	3f 91       	pop	r19
    1190:	2f 91       	pop	r18
    1192:	0f 90       	pop	r0
    1194:	00 92 5b 00 	sts	0x005B, r0
    1198:	0f 90       	pop	r0
    119a:	0f be       	out	0x3f, r0	; 63
    119c:	0f 90       	pop	r0
    119e:	1f 90       	pop	r1
    11a0:	18 95       	reti

000011a2 <TIMER1_SetStartTime>:
// 	{
// 		Timer1_ICU_Fptr();
// 	}

void TIMER1_SetStartTime (u8 TIME)
{
    11a2:	df 93       	push	r29
    11a4:	cf 93       	push	r28
    11a6:	0f 92       	push	r0
    11a8:	cd b7       	in	r28, 0x3d	; 61
    11aa:	de b7       	in	r29, 0x3e	; 62
    11ac:	89 83       	std	Y+1, r24	; 0x01
	TCNT1=TIME;
    11ae:	ec e4       	ldi	r30, 0x4C	; 76
    11b0:	f0 e0       	ldi	r31, 0x00	; 0
    11b2:	89 81       	ldd	r24, Y+1	; 0x01
    11b4:	88 2f       	mov	r24, r24
    11b6:	90 e0       	ldi	r25, 0x00	; 0
    11b8:	91 83       	std	Z+1, r25	; 0x01
    11ba:	80 83       	st	Z, r24
}
    11bc:	0f 90       	pop	r0
    11be:	cf 91       	pop	r28
    11c0:	df 91       	pop	r29
    11c2:	08 95       	ret

000011c4 <SPI_MasterCan_Init>:
#include "../../MCAL/SPI/SPI_Private.h"
#include "../../MCAL/SPI/SPI_Cfg.h"
static void (*Global_Ptf)(void)=NULLPTR;
static u8 *SPI_GlOBAL_DATA=NULLPTR;
void SPI_MasterCan_Init (void)
{
    11c4:	df 93       	push	r29
    11c6:	cf 93       	push	r28
    11c8:	cd b7       	in	r28, 0x3d	; 61
    11ca:	de b7       	in	r29, 0x3e	; 62
	/*ENABLE SPI */
	SPI_REGS->SPCR.BIT.SPE=HIGH;
    11cc:	ed e2       	ldi	r30, 0x2D	; 45
    11ce:	f0 e0       	ldi	r31, 0x00	; 0
    11d0:	80 81       	ld	r24, Z
    11d2:	80 64       	ori	r24, 0x40	; 64
    11d4:	80 83       	st	Z, r24
	/*CHOICE MSB FIRST */
	SPI_REGS->SPCR.BIT.DORD=LOW;
    11d6:	ed e2       	ldi	r30, 0x2D	; 45
    11d8:	f0 e0       	ldi	r31, 0x00	; 0
    11da:	80 81       	ld	r24, Z
    11dc:	8f 7d       	andi	r24, 0xDF	; 223
    11de:	80 83       	st	Z, r24
	/*MASTER MODE*/
	SPI_REGS->SPCR.BIT.MSTR=HIGH;
    11e0:	ed e2       	ldi	r30, 0x2D	; 45
    11e2:	f0 e0       	ldi	r31, 0x00	; 0
    11e4:	80 81       	ld	r24, Z
    11e6:	80 61       	ori	r24, 0x10	; 16
    11e8:	80 83       	st	Z, r24
	/* CHOICE CLOCK POLARITY AND CLOCK PHASE*/
	SPI_REGS->SPCR.BIT.CPOL=LOW;  //leading rising
    11ea:	ed e2       	ldi	r30, 0x2D	; 45
    11ec:	f0 e0       	ldi	r31, 0x00	; 0
    11ee:	80 81       	ld	r24, Z
    11f0:	87 7f       	andi	r24, 0xF7	; 247
    11f2:	80 83       	st	Z, r24
	SPI_REGS->SPCR.BIT.CPHA=LOW; //sampling rising
    11f4:	ed e2       	ldi	r30, 0x2D	; 45
    11f6:	f0 e0       	ldi	r31, 0x00	; 0
    11f8:	80 81       	ld	r24, Z
    11fa:	8b 7f       	andi	r24, 0xFB	; 251
    11fc:	80 83       	st	Z, r24
	/*CHCOICE CLOCK PRESCALLER FCPU/16 */
	SPI_REGS->SPCR.BIT.SPR0=HIGH;
    11fe:	ed e2       	ldi	r30, 0x2D	; 45
    1200:	f0 e0       	ldi	r31, 0x00	; 0
    1202:	80 81       	ld	r24, Z
    1204:	81 60       	ori	r24, 0x01	; 1
    1206:	80 83       	st	Z, r24
	SPI_REGS->SPCR.BIT.SPR1=LOW;
    1208:	ed e2       	ldi	r30, 0x2D	; 45
    120a:	f0 e0       	ldi	r31, 0x00	; 0
    120c:	80 81       	ld	r24, Z
    120e:	8d 7f       	andi	r24, 0xFD	; 253
    1210:	80 83       	st	Z, r24
	SPI_REGS->SPSR.BIT.SPI2X=LOW;
    1212:	ed e2       	ldi	r30, 0x2D	; 45
    1214:	f0 e0       	ldi	r31, 0x00	; 0
    1216:	81 81       	ldd	r24, Z+1	; 0x01
    1218:	8e 7f       	andi	r24, 0xFE	; 254
    121a:	81 83       	std	Z+1, r24	; 0x01
	
	//select pin ss ->>>high
}
    121c:	cf 91       	pop	r28
    121e:	df 91       	pop	r29
    1220:	08 95       	ret

00001222 <SPI_SlaveCan_Init>:
void SPI_SlaveCan_Init (void)
{
    1222:	df 93       	push	r29
    1224:	cf 93       	push	r28
    1226:	cd b7       	in	r28, 0x3d	; 61
    1228:	de b7       	in	r29, 0x3e	; 62
	/*ENABLE SPI */
	SPI_REGS->SPCR.BIT.SPE=HIGH;
    122a:	ed e2       	ldi	r30, 0x2D	; 45
    122c:	f0 e0       	ldi	r31, 0x00	; 0
    122e:	80 81       	ld	r24, Z
    1230:	80 64       	ori	r24, 0x40	; 64
    1232:	80 83       	st	Z, r24
	/*CHOICE MSB FIRST */
	SPI_REGS->SPCR.BIT.DORD=LOW;
    1234:	ed e2       	ldi	r30, 0x2D	; 45
    1236:	f0 e0       	ldi	r31, 0x00	; 0
    1238:	80 81       	ld	r24, Z
    123a:	8f 7d       	andi	r24, 0xDF	; 223
    123c:	80 83       	st	Z, r24
	/*MASTER MODE*/
	SPI_REGS->SPCR.BIT.MSTR=HIGH;
    123e:	ed e2       	ldi	r30, 0x2D	; 45
    1240:	f0 e0       	ldi	r31, 0x00	; 0
    1242:	80 81       	ld	r24, Z
    1244:	80 61       	ori	r24, 0x10	; 16
    1246:	80 83       	st	Z, r24
	/* CHOICE CLOCK POLARITY AND CLOCK PHASE*/
	SPI_REGS->SPCR.BIT.CPOL=LOW;  //leading rising
    1248:	ed e2       	ldi	r30, 0x2D	; 45
    124a:	f0 e0       	ldi	r31, 0x00	; 0
    124c:	80 81       	ld	r24, Z
    124e:	87 7f       	andi	r24, 0xF7	; 247
    1250:	80 83       	st	Z, r24
	SPI_REGS->SPCR.BIT.CPHA=LOW; //sampling rising
    1252:	ed e2       	ldi	r30, 0x2D	; 45
    1254:	f0 e0       	ldi	r31, 0x00	; 0
    1256:	80 81       	ld	r24, Z
    1258:	8b 7f       	andi	r24, 0xFB	; 251
    125a:	80 83       	st	Z, r24
	/*CHCOICE CLOCK PRESCALLER FCPU/16 */
	SPI_REGS->SPCR.BIT.SPR0=HIGH;
    125c:	ed e2       	ldi	r30, 0x2D	; 45
    125e:	f0 e0       	ldi	r31, 0x00	; 0
    1260:	80 81       	ld	r24, Z
    1262:	81 60       	ori	r24, 0x01	; 1
    1264:	80 83       	st	Z, r24
	SPI_REGS->SPCR.BIT.SPR1=LOW;
    1266:	ed e2       	ldi	r30, 0x2D	; 45
    1268:	f0 e0       	ldi	r31, 0x00	; 0
    126a:	80 81       	ld	r24, Z
    126c:	8d 7f       	andi	r24, 0xFD	; 253
    126e:	80 83       	st	Z, r24
	SPI_REGS->SPSR.BIT.SPI2X=LOW;
    1270:	ed e2       	ldi	r30, 0x2D	; 45
    1272:	f0 e0       	ldi	r31, 0x00	; 0
    1274:	81 81       	ldd	r24, Z+1	; 0x01
    1276:	8e 7f       	andi	r24, 0xFE	; 254
    1278:	81 83       	std	Z+1, r24	; 0x01
}
    127a:	cf 91       	pop	r28
    127c:	df 91       	pop	r29
    127e:	08 95       	ret

00001280 <SPI_MasterTransmit>:
u8 SPI_MasterTransmit (u8 data)
{
    1280:	df 93       	push	r29
    1282:	cf 93       	push	r28
    1284:	00 d0       	rcall	.+0      	; 0x1286 <SPI_MasterTransmit+0x6>
    1286:	cd b7       	in	r28, 0x3d	; 61
    1288:	de b7       	in	r29, 0x3e	; 62
    128a:	8a 83       	std	Y+2, r24	; 0x02
	u8 dataRead=0;
    128c:	19 82       	std	Y+1, r1	; 0x01
	SPI_REGS->SPDR.R=data;
    128e:	ed e2       	ldi	r30, 0x2D	; 45
    1290:	f0 e0       	ldi	r31, 0x00	; 0
    1292:	8a 81       	ldd	r24, Y+2	; 0x02
    1294:	82 83       	std	Z+2, r24	; 0x02
	while(SPI_REGS->SPSR.BIT.SPIF==LOW);
    1296:	ed e2       	ldi	r30, 0x2D	; 45
    1298:	f0 e0       	ldi	r31, 0x00	; 0
    129a:	81 81       	ldd	r24, Z+1	; 0x01
    129c:	80 78       	andi	r24, 0x80	; 128
    129e:	88 23       	and	r24, r24
    12a0:	d1 f3       	breq	.-12     	; 0x1296 <SPI_MasterTransmit+0x16>
	dataRead=SPI_REGS->SPDR.R;
    12a2:	ed e2       	ldi	r30, 0x2D	; 45
    12a4:	f0 e0       	ldi	r31, 0x00	; 0
    12a6:	82 81       	ldd	r24, Z+2	; 0x02
    12a8:	89 83       	std	Y+1, r24	; 0x01
	return dataRead;
    12aa:	89 81       	ldd	r24, Y+1	; 0x01
}
    12ac:	0f 90       	pop	r0
    12ae:	0f 90       	pop	r0
    12b0:	cf 91       	pop	r28
    12b2:	df 91       	pop	r29
    12b4:	08 95       	ret

000012b6 <SPI_Init>:
/*spi */
void SPI_Init(void)
{
    12b6:	df 93       	push	r29
    12b8:	cf 93       	push	r28
    12ba:	cd b7       	in	r28, 0x3d	; 61
    12bc:	de b7       	in	r29, 0x3e	; 62
	#if SPI_MODE == SPI_MASTER
	/*MASTER MODE*/
	SPI_REGS->SPCR.BIT.MSTR=HIGH;
    12be:	ed e2       	ldi	r30, 0x2D	; 45
    12c0:	f0 e0       	ldi	r31, 0x00	; 0
    12c2:	80 81       	ld	r24, Z
    12c4:	80 61       	ori	r24, 0x10	; 16
    12c6:	80 83       	st	Z, r24
	/*CHCOICE CLOCK PRESCALLER FCPU/16 */
	SPI_REGS->SPCR.BIT.SPR0=HIGH;
    12c8:	ed e2       	ldi	r30, 0x2D	; 45
    12ca:	f0 e0       	ldi	r31, 0x00	; 0
    12cc:	80 81       	ld	r24, Z
    12ce:	81 60       	ori	r24, 0x01	; 1
    12d0:	80 83       	st	Z, r24
	SPI_REGS->SPCR.BIT.SPR1=LOW;
    12d2:	ed e2       	ldi	r30, 0x2D	; 45
    12d4:	f0 e0       	ldi	r31, 0x00	; 0
    12d6:	80 81       	ld	r24, Z
    12d8:	8d 7f       	andi	r24, 0xFD	; 253
    12da:	80 83       	st	Z, r24
	SPI_REGS->SPSR.BIT.SPI2X=LOW;
    12dc:	ed e2       	ldi	r30, 0x2D	; 45
    12de:	f0 e0       	ldi	r31, 0x00	; 0
    12e0:	81 81       	ldd	r24, Z+1	; 0x01
    12e2:	8e 7f       	andi	r24, 0xFE	; 254
    12e4:	81 83       	std	Z+1, r24	; 0x01
	#elif SPI_MODE == SPI_SLAVE
	/*SALVE MODE*/
	SPI_REGS->SPCR.BIT.MSTR=LOW;
	#endif
	/* CHOICE CLOCK POLARITY AND CLOCK PHASE*/
	SPI_REGS->SPCR.BIT.CPOL=HIGH;
    12e6:	ed e2       	ldi	r30, 0x2D	; 45
    12e8:	f0 e0       	ldi	r31, 0x00	; 0
    12ea:	80 81       	ld	r24, Z
    12ec:	88 60       	ori	r24, 0x08	; 8
    12ee:	80 83       	st	Z, r24
	SPI_REGS->SPCR.BIT.CPHA=HIGH;
    12f0:	ed e2       	ldi	r30, 0x2D	; 45
    12f2:	f0 e0       	ldi	r31, 0x00	; 0
    12f4:	80 81       	ld	r24, Z
    12f6:	84 60       	ori	r24, 0x04	; 4
    12f8:	80 83       	st	Z, r24
	/*CHOICE LSB FIRST */
	SPI_REGS->SPCR.BIT.DORD=HIGH;
    12fa:	ed e2       	ldi	r30, 0x2D	; 45
    12fc:	f0 e0       	ldi	r31, 0x00	; 0
    12fe:	80 81       	ld	r24, Z
    1300:	80 62       	ori	r24, 0x20	; 32
    1302:	80 83       	st	Z, r24
	/*ENABLE SPI */
	SPI_REGS->SPCR.BIT.SPE=HIGH;
    1304:	ed e2       	ldi	r30, 0x2D	; 45
    1306:	f0 e0       	ldi	r31, 0x00	; 0
    1308:	80 81       	ld	r24, Z
    130a:	80 64       	ori	r24, 0x40	; 64
    130c:	80 83       	st	Z, r24
}
    130e:	cf 91       	pop	r28
    1310:	df 91       	pop	r29
    1312:	08 95       	ret

00001314 <SPI_voidTransmateASYNC>:

void SPI_voidTransmateASYNC(void (*SPI_Ptf)(void),u8 data,u8 *rx_data)
{
    1314:	df 93       	push	r29
    1316:	cf 93       	push	r28
    1318:	00 d0       	rcall	.+0      	; 0x131a <SPI_voidTransmateASYNC+0x6>
    131a:	00 d0       	rcall	.+0      	; 0x131c <SPI_voidTransmateASYNC+0x8>
    131c:	0f 92       	push	r0
    131e:	cd b7       	in	r28, 0x3d	; 61
    1320:	de b7       	in	r29, 0x3e	; 62
    1322:	9a 83       	std	Y+2, r25	; 0x02
    1324:	89 83       	std	Y+1, r24	; 0x01
    1326:	6b 83       	std	Y+3, r22	; 0x03
    1328:	5d 83       	std	Y+5, r21	; 0x05
    132a:	4c 83       	std	Y+4, r20	; 0x04
	SPI_REGS->SPCR.BIT.SPIE=HIGH;
    132c:	ed e2       	ldi	r30, 0x2D	; 45
    132e:	f0 e0       	ldi	r31, 0x00	; 0
    1330:	80 81       	ld	r24, Z
    1332:	80 68       	ori	r24, 0x80	; 128
    1334:	80 83       	st	Z, r24
	/*CHEIK NULL*/
	Global_Ptf=SPI_Ptf;
    1336:	89 81       	ldd	r24, Y+1	; 0x01
    1338:	9a 81       	ldd	r25, Y+2	; 0x02
    133a:	90 93 a8 02 	sts	0x02A8, r25
    133e:	80 93 a7 02 	sts	0x02A7, r24
	SPI_GlOBAL_DATA=rx_data;
    1342:	8c 81       	ldd	r24, Y+4	; 0x04
    1344:	9d 81       	ldd	r25, Y+5	; 0x05
    1346:	90 93 aa 02 	sts	0x02AA, r25
    134a:	80 93 a9 02 	sts	0x02A9, r24
	SPI_REGS->SPDR.R=data;
    134e:	ed e2       	ldi	r30, 0x2D	; 45
    1350:	f0 e0       	ldi	r31, 0x00	; 0
    1352:	8b 81       	ldd	r24, Y+3	; 0x03
    1354:	82 83       	std	Z+2, r24	; 0x02
}
    1356:	0f 90       	pop	r0
    1358:	0f 90       	pop	r0
    135a:	0f 90       	pop	r0
    135c:	0f 90       	pop	r0
    135e:	0f 90       	pop	r0
    1360:	cf 91       	pop	r28
    1362:	df 91       	pop	r29
    1364:	08 95       	ret

00001366 <SPI_Transieve>:

u8 SPI_Transieve(u8 Copy_u8_dat)
{
    1366:	df 93       	push	r29
    1368:	cf 93       	push	r28
    136a:	0f 92       	push	r0
    136c:	cd b7       	in	r28, 0x3d	; 61
    136e:	de b7       	in	r29, 0x3e	; 62
    1370:	89 83       	std	Y+1, r24	; 0x01
	//ss-->0
	while(SPI_REGS->SPSR.BIT.WCOL==HIGH);
    1372:	ed e2       	ldi	r30, 0x2D	; 45
    1374:	f0 e0       	ldi	r31, 0x00	; 0
    1376:	81 81       	ldd	r24, Z+1	; 0x01
    1378:	80 74       	andi	r24, 0x40	; 64
    137a:	88 23       	and	r24, r24
    137c:	d1 f7       	brne	.-12     	; 0x1372 <SPI_Transieve+0xc>
	SPI_REGS->SPDR.R=Copy_u8_dat;
    137e:	ed e2       	ldi	r30, 0x2D	; 45
    1380:	f0 e0       	ldi	r31, 0x00	; 0
    1382:	89 81       	ldd	r24, Y+1	; 0x01
    1384:	82 83       	std	Z+2, r24	; 0x02
	while(SPI_REGS->SPSR.BIT.SPIF==LOW);
    1386:	ed e2       	ldi	r30, 0x2D	; 45
    1388:	f0 e0       	ldi	r31, 0x00	; 0
    138a:	81 81       	ldd	r24, Z+1	; 0x01
    138c:	80 78       	andi	r24, 0x80	; 128
    138e:	88 23       	and	r24, r24
    1390:	d1 f3       	breq	.-12     	; 0x1386 <SPI_Transieve+0x20>
	return SPI_REGS->SPDR.R;
    1392:	ed e2       	ldi	r30, 0x2D	; 45
    1394:	f0 e0       	ldi	r31, 0x00	; 0
    1396:	82 81       	ldd	r24, Z+2	; 0x02
	//ss-->1
	
}
    1398:	0f 90       	pop	r0
    139a:	cf 91       	pop	r28
    139c:	df 91       	pop	r29
    139e:	08 95       	ret

000013a0 <__vector_17>:
void __vector_17(void)    __attribute__((signal));
void __vector_17(void)
{
    13a0:	1f 92       	push	r1
    13a2:	0f 92       	push	r0
    13a4:	0f b6       	in	r0, 0x3f	; 63
    13a6:	0f 92       	push	r0
    13a8:	00 90 5b 00 	lds	r0, 0x005B
    13ac:	0f 92       	push	r0
    13ae:	11 24       	eor	r1, r1
    13b0:	2f 93       	push	r18
    13b2:	3f 93       	push	r19
    13b4:	4f 93       	push	r20
    13b6:	5f 93       	push	r21
    13b8:	6f 93       	push	r22
    13ba:	7f 93       	push	r23
    13bc:	8f 93       	push	r24
    13be:	9f 93       	push	r25
    13c0:	af 93       	push	r26
    13c2:	bf 93       	push	r27
    13c4:	ef 93       	push	r30
    13c6:	ff 93       	push	r31
    13c8:	df 93       	push	r29
    13ca:	cf 93       	push	r28
    13cc:	cd b7       	in	r28, 0x3d	; 61
    13ce:	de b7       	in	r29, 0x3e	; 62
	Global_Ptf();
    13d0:	e0 91 a7 02 	lds	r30, 0x02A7
    13d4:	f0 91 a8 02 	lds	r31, 0x02A8
    13d8:	09 95       	icall
	*SPI_GlOBAL_DATA=SPI_REGS->SPDR.R;
    13da:	a0 91 a9 02 	lds	r26, 0x02A9
    13de:	b0 91 aa 02 	lds	r27, 0x02AA
    13e2:	ed e2       	ldi	r30, 0x2D	; 45
    13e4:	f0 e0       	ldi	r31, 0x00	; 0
    13e6:	82 81       	ldd	r24, Z+2	; 0x02
    13e8:	8c 93       	st	X, r24
}
    13ea:	cf 91       	pop	r28
    13ec:	df 91       	pop	r29
    13ee:	ff 91       	pop	r31
    13f0:	ef 91       	pop	r30
    13f2:	bf 91       	pop	r27
    13f4:	af 91       	pop	r26
    13f6:	9f 91       	pop	r25
    13f8:	8f 91       	pop	r24
    13fa:	7f 91       	pop	r23
    13fc:	6f 91       	pop	r22
    13fe:	5f 91       	pop	r21
    1400:	4f 91       	pop	r20
    1402:	3f 91       	pop	r19
    1404:	2f 91       	pop	r18
    1406:	0f 90       	pop	r0
    1408:	00 92 5b 00 	sts	0x005B, r0
    140c:	0f 90       	pop	r0
    140e:	0f be       	out	0x3f, r0	; 63
    1410:	0f 90       	pop	r0
    1412:	1f 90       	pop	r1
    1414:	18 95       	reti

00001416 <Port_Init>:
#include "MemMap128.h"
#include "../../MCAL/PORT/Port.h"
#include "../../MCAL/PORT/Port_Cfg.h"
extern Pin_CfgType PinCfgs[];					   
void Port_Init (void)
{
    1416:	df 93       	push	r29
    1418:	cf 93       	push	r28
    141a:	00 d0       	rcall	.+0      	; 0x141c <Port_Init+0x6>
    141c:	0f 92       	push	r0
    141e:	cd b7       	in	r28, 0x3d	; 61
    1420:	de b7       	in	r29, 0x3e	; 62
	u8 i=0;
    1422:	19 82       	std	Y+1, r1	; 0x01
	for (i=0;i<64;i++)
    1424:	19 82       	std	Y+1, r1	; 0x01
    1426:	77 c3       	rjmp	.+1774   	; 0x1b16 <Port_Init+0x700>
	{
		switch (PinCfgs[i].Port)
    1428:	89 81       	ldd	r24, Y+1	; 0x01
    142a:	28 2f       	mov	r18, r24
    142c:	30 e0       	ldi	r19, 0x00	; 0
    142e:	c9 01       	movw	r24, r18
    1430:	88 0f       	add	r24, r24
    1432:	99 1f       	adc	r25, r25
    1434:	82 0f       	add	r24, r18
    1436:	93 1f       	adc	r25, r19
    1438:	fc 01       	movw	r30, r24
    143a:	ec 5f       	subi	r30, 0xFC	; 252
    143c:	fd 4f       	sbci	r31, 0xFD	; 253
    143e:	80 81       	ld	r24, Z
    1440:	28 2f       	mov	r18, r24
    1442:	30 e0       	ldi	r19, 0x00	; 0
    1444:	3b 83       	std	Y+3, r19	; 0x03
    1446:	2a 83       	std	Y+2, r18	; 0x02
    1448:	8a 81       	ldd	r24, Y+2	; 0x02
    144a:	9b 81       	ldd	r25, Y+3	; 0x03
    144c:	82 30       	cpi	r24, 0x02	; 2
    144e:	91 05       	cpc	r25, r1
    1450:	09 f4       	brne	.+2      	; 0x1454 <Port_Init+0x3e>
    1452:	6b c1       	rjmp	.+726    	; 0x172a <Port_Init+0x314>
    1454:	2a 81       	ldd	r18, Y+2	; 0x02
    1456:	3b 81       	ldd	r19, Y+3	; 0x03
    1458:	23 30       	cpi	r18, 0x03	; 3
    145a:	31 05       	cpc	r19, r1
    145c:	5c f4       	brge	.+22     	; 0x1474 <Port_Init+0x5e>
    145e:	8a 81       	ldd	r24, Y+2	; 0x02
    1460:	9b 81       	ldd	r25, Y+3	; 0x03
    1462:	00 97       	sbiw	r24, 0x00	; 0
    1464:	a1 f0       	breq	.+40     	; 0x148e <Port_Init+0x78>
    1466:	2a 81       	ldd	r18, Y+2	; 0x02
    1468:	3b 81       	ldd	r19, Y+3	; 0x03
    146a:	21 30       	cpi	r18, 0x01	; 1
    146c:	31 05       	cpc	r19, r1
    146e:	09 f4       	brne	.+2      	; 0x1472 <Port_Init+0x5c>
    1470:	b5 c0       	rjmp	.+362    	; 0x15dc <Port_Init+0x1c6>
    1472:	4e c3       	rjmp	.+1692   	; 0x1b10 <Port_Init+0x6fa>
    1474:	8a 81       	ldd	r24, Y+2	; 0x02
    1476:	9b 81       	ldd	r25, Y+3	; 0x03
    1478:	83 30       	cpi	r24, 0x03	; 3
    147a:	91 05       	cpc	r25, r1
    147c:	09 f4       	brne	.+2      	; 0x1480 <Port_Init+0x6a>
    147e:	fc c1       	rjmp	.+1016   	; 0x1878 <Port_Init+0x462>
    1480:	2a 81       	ldd	r18, Y+2	; 0x02
    1482:	3b 81       	ldd	r19, Y+3	; 0x03
    1484:	24 30       	cpi	r18, 0x04	; 4
    1486:	31 05       	cpc	r19, r1
    1488:	09 f4       	brne	.+2      	; 0x148c <Port_Init+0x76>
    148a:	9d c2       	rjmp	.+1338   	; 0x19c6 <Port_Init+0x5b0>
    148c:	41 c3       	rjmp	.+1666   	; 0x1b10 <Port_Init+0x6fa>
		{
			case Dio_PORTA:
			if (PinCfgs[i].Dir==Dio_OUTPUT)
    148e:	89 81       	ldd	r24, Y+1	; 0x01
    1490:	28 2f       	mov	r18, r24
    1492:	30 e0       	ldi	r19, 0x00	; 0
    1494:	c9 01       	movw	r24, r18
    1496:	88 0f       	add	r24, r24
    1498:	99 1f       	adc	r25, r25
    149a:	82 0f       	add	r24, r18
    149c:	93 1f       	adc	r25, r19
    149e:	fc 01       	movw	r30, r24
    14a0:	ea 5f       	subi	r30, 0xFA	; 250
    14a2:	fd 4f       	sbci	r31, 0xFD	; 253
    14a4:	80 81       	ld	r24, Z
    14a6:	88 23       	and	r24, r24
    14a8:	f9 f4       	brne	.+62     	; 0x14e8 <Port_Init+0xd2>
			{
				SET_BIT(DDRA,PinCfgs[i].Pin);		
    14aa:	aa e3       	ldi	r26, 0x3A	; 58
    14ac:	b0 e0       	ldi	r27, 0x00	; 0
    14ae:	ea e3       	ldi	r30, 0x3A	; 58
    14b0:	f0 e0       	ldi	r31, 0x00	; 0
    14b2:	80 81       	ld	r24, Z
    14b4:	48 2f       	mov	r20, r24
    14b6:	89 81       	ldd	r24, Y+1	; 0x01
    14b8:	28 2f       	mov	r18, r24
    14ba:	30 e0       	ldi	r19, 0x00	; 0
    14bc:	c9 01       	movw	r24, r18
    14be:	88 0f       	add	r24, r24
    14c0:	99 1f       	adc	r25, r25
    14c2:	82 0f       	add	r24, r18
    14c4:	93 1f       	adc	r25, r19
    14c6:	fc 01       	movw	r30, r24
    14c8:	eb 5f       	subi	r30, 0xFB	; 251
    14ca:	fd 4f       	sbci	r31, 0xFD	; 253
    14cc:	80 81       	ld	r24, Z
    14ce:	28 2f       	mov	r18, r24
    14d0:	30 e0       	ldi	r19, 0x00	; 0
    14d2:	81 e0       	ldi	r24, 0x01	; 1
    14d4:	90 e0       	ldi	r25, 0x00	; 0
    14d6:	02 2e       	mov	r0, r18
    14d8:	02 c0       	rjmp	.+4      	; 0x14de <Port_Init+0xc8>
    14da:	88 0f       	add	r24, r24
    14dc:	99 1f       	adc	r25, r25
    14de:	0a 94       	dec	r0
    14e0:	e2 f7       	brpl	.-8      	; 0x14da <Port_Init+0xc4>
    14e2:	84 2b       	or	r24, r20
    14e4:	8c 93       	st	X, r24
    14e6:	14 c3       	rjmp	.+1576   	; 0x1b10 <Port_Init+0x6fa>
			}
			else if (PinCfgs[i].Dir==Dio_INPUT)
    14e8:	89 81       	ldd	r24, Y+1	; 0x01
    14ea:	28 2f       	mov	r18, r24
    14ec:	30 e0       	ldi	r19, 0x00	; 0
    14ee:	c9 01       	movw	r24, r18
    14f0:	88 0f       	add	r24, r24
    14f2:	99 1f       	adc	r25, r25
    14f4:	82 0f       	add	r24, r18
    14f6:	93 1f       	adc	r25, r19
    14f8:	fc 01       	movw	r30, r24
    14fa:	ea 5f       	subi	r30, 0xFA	; 250
    14fc:	fd 4f       	sbci	r31, 0xFD	; 253
    14fe:	80 81       	ld	r24, Z
    1500:	81 30       	cpi	r24, 0x01	; 1
    1502:	01 f5       	brne	.+64     	; 0x1544 <Port_Init+0x12e>
			{
				CLR_BIT(DDRA,PinCfgs[i].Pin);
    1504:	aa e3       	ldi	r26, 0x3A	; 58
    1506:	b0 e0       	ldi	r27, 0x00	; 0
    1508:	ea e3       	ldi	r30, 0x3A	; 58
    150a:	f0 e0       	ldi	r31, 0x00	; 0
    150c:	80 81       	ld	r24, Z
    150e:	48 2f       	mov	r20, r24
    1510:	89 81       	ldd	r24, Y+1	; 0x01
    1512:	28 2f       	mov	r18, r24
    1514:	30 e0       	ldi	r19, 0x00	; 0
    1516:	c9 01       	movw	r24, r18
    1518:	88 0f       	add	r24, r24
    151a:	99 1f       	adc	r25, r25
    151c:	82 0f       	add	r24, r18
    151e:	93 1f       	adc	r25, r19
    1520:	fc 01       	movw	r30, r24
    1522:	eb 5f       	subi	r30, 0xFB	; 251
    1524:	fd 4f       	sbci	r31, 0xFD	; 253
    1526:	80 81       	ld	r24, Z
    1528:	28 2f       	mov	r18, r24
    152a:	30 e0       	ldi	r19, 0x00	; 0
    152c:	81 e0       	ldi	r24, 0x01	; 1
    152e:	90 e0       	ldi	r25, 0x00	; 0
    1530:	02 2e       	mov	r0, r18
    1532:	02 c0       	rjmp	.+4      	; 0x1538 <Port_Init+0x122>
    1534:	88 0f       	add	r24, r24
    1536:	99 1f       	adc	r25, r25
    1538:	0a 94       	dec	r0
    153a:	e2 f7       	brpl	.-8      	; 0x1534 <Port_Init+0x11e>
    153c:	80 95       	com	r24
    153e:	84 23       	and	r24, r20
    1540:	8c 93       	st	X, r24
    1542:	e6 c2       	rjmp	.+1484   	; 0x1b10 <Port_Init+0x6fa>
			}
			else if (PinCfgs[i].Dir==Dio_INPULL)
    1544:	89 81       	ldd	r24, Y+1	; 0x01
    1546:	28 2f       	mov	r18, r24
    1548:	30 e0       	ldi	r19, 0x00	; 0
    154a:	c9 01       	movw	r24, r18
    154c:	88 0f       	add	r24, r24
    154e:	99 1f       	adc	r25, r25
    1550:	82 0f       	add	r24, r18
    1552:	93 1f       	adc	r25, r19
    1554:	fc 01       	movw	r30, r24
    1556:	ea 5f       	subi	r30, 0xFA	; 250
    1558:	fd 4f       	sbci	r31, 0xFD	; 253
    155a:	80 81       	ld	r24, Z
    155c:	82 30       	cpi	r24, 0x02	; 2
    155e:	09 f0       	breq	.+2      	; 0x1562 <Port_Init+0x14c>
    1560:	d7 c2       	rjmp	.+1454   	; 0x1b10 <Port_Init+0x6fa>
			{
				CLR_BIT(DDRA,PinCfgs[i].Pin);
    1562:	aa e3       	ldi	r26, 0x3A	; 58
    1564:	b0 e0       	ldi	r27, 0x00	; 0
    1566:	ea e3       	ldi	r30, 0x3A	; 58
    1568:	f0 e0       	ldi	r31, 0x00	; 0
    156a:	80 81       	ld	r24, Z
    156c:	48 2f       	mov	r20, r24
    156e:	89 81       	ldd	r24, Y+1	; 0x01
    1570:	28 2f       	mov	r18, r24
    1572:	30 e0       	ldi	r19, 0x00	; 0
    1574:	c9 01       	movw	r24, r18
    1576:	88 0f       	add	r24, r24
    1578:	99 1f       	adc	r25, r25
    157a:	82 0f       	add	r24, r18
    157c:	93 1f       	adc	r25, r19
    157e:	fc 01       	movw	r30, r24
    1580:	eb 5f       	subi	r30, 0xFB	; 251
    1582:	fd 4f       	sbci	r31, 0xFD	; 253
    1584:	80 81       	ld	r24, Z
    1586:	28 2f       	mov	r18, r24
    1588:	30 e0       	ldi	r19, 0x00	; 0
    158a:	81 e0       	ldi	r24, 0x01	; 1
    158c:	90 e0       	ldi	r25, 0x00	; 0
    158e:	02 c0       	rjmp	.+4      	; 0x1594 <Port_Init+0x17e>
    1590:	88 0f       	add	r24, r24
    1592:	99 1f       	adc	r25, r25
    1594:	2a 95       	dec	r18
    1596:	e2 f7       	brpl	.-8      	; 0x1590 <Port_Init+0x17a>
    1598:	80 95       	com	r24
    159a:	84 23       	and	r24, r20
    159c:	8c 93       	st	X, r24
				SET_BIT(PORTA,PinCfgs[i].Pin);
    159e:	ab e3       	ldi	r26, 0x3B	; 59
    15a0:	b0 e0       	ldi	r27, 0x00	; 0
    15a2:	eb e3       	ldi	r30, 0x3B	; 59
    15a4:	f0 e0       	ldi	r31, 0x00	; 0
    15a6:	80 81       	ld	r24, Z
    15a8:	48 2f       	mov	r20, r24
    15aa:	89 81       	ldd	r24, Y+1	; 0x01
    15ac:	28 2f       	mov	r18, r24
    15ae:	30 e0       	ldi	r19, 0x00	; 0
    15b0:	c9 01       	movw	r24, r18
    15b2:	88 0f       	add	r24, r24
    15b4:	99 1f       	adc	r25, r25
    15b6:	82 0f       	add	r24, r18
    15b8:	93 1f       	adc	r25, r19
    15ba:	fc 01       	movw	r30, r24
    15bc:	eb 5f       	subi	r30, 0xFB	; 251
    15be:	fd 4f       	sbci	r31, 0xFD	; 253
    15c0:	80 81       	ld	r24, Z
    15c2:	28 2f       	mov	r18, r24
    15c4:	30 e0       	ldi	r19, 0x00	; 0
    15c6:	81 e0       	ldi	r24, 0x01	; 1
    15c8:	90 e0       	ldi	r25, 0x00	; 0
    15ca:	02 2e       	mov	r0, r18
    15cc:	02 c0       	rjmp	.+4      	; 0x15d2 <Port_Init+0x1bc>
    15ce:	88 0f       	add	r24, r24
    15d0:	99 1f       	adc	r25, r25
    15d2:	0a 94       	dec	r0
    15d4:	e2 f7       	brpl	.-8      	; 0x15ce <Port_Init+0x1b8>
    15d6:	84 2b       	or	r24, r20
    15d8:	8c 93       	st	X, r24
    15da:	9a c2       	rjmp	.+1332   	; 0x1b10 <Port_Init+0x6fa>
			}
			break;
			case Dio_PORTB:
			if (PinCfgs[i].Dir==Dio_OUTPUT)
    15dc:	89 81       	ldd	r24, Y+1	; 0x01
    15de:	28 2f       	mov	r18, r24
    15e0:	30 e0       	ldi	r19, 0x00	; 0
    15e2:	c9 01       	movw	r24, r18
    15e4:	88 0f       	add	r24, r24
    15e6:	99 1f       	adc	r25, r25
    15e8:	82 0f       	add	r24, r18
    15ea:	93 1f       	adc	r25, r19
    15ec:	fc 01       	movw	r30, r24
    15ee:	ea 5f       	subi	r30, 0xFA	; 250
    15f0:	fd 4f       	sbci	r31, 0xFD	; 253
    15f2:	80 81       	ld	r24, Z
    15f4:	88 23       	and	r24, r24
    15f6:	f9 f4       	brne	.+62     	; 0x1636 <Port_Init+0x220>
			{
				SET_BIT(DDRB,PinCfgs[i].Pin);
    15f8:	a7 e3       	ldi	r26, 0x37	; 55
    15fa:	b0 e0       	ldi	r27, 0x00	; 0
    15fc:	e7 e3       	ldi	r30, 0x37	; 55
    15fe:	f0 e0       	ldi	r31, 0x00	; 0
    1600:	80 81       	ld	r24, Z
    1602:	48 2f       	mov	r20, r24
    1604:	89 81       	ldd	r24, Y+1	; 0x01
    1606:	28 2f       	mov	r18, r24
    1608:	30 e0       	ldi	r19, 0x00	; 0
    160a:	c9 01       	movw	r24, r18
    160c:	88 0f       	add	r24, r24
    160e:	99 1f       	adc	r25, r25
    1610:	82 0f       	add	r24, r18
    1612:	93 1f       	adc	r25, r19
    1614:	fc 01       	movw	r30, r24
    1616:	eb 5f       	subi	r30, 0xFB	; 251
    1618:	fd 4f       	sbci	r31, 0xFD	; 253
    161a:	80 81       	ld	r24, Z
    161c:	28 2f       	mov	r18, r24
    161e:	30 e0       	ldi	r19, 0x00	; 0
    1620:	81 e0       	ldi	r24, 0x01	; 1
    1622:	90 e0       	ldi	r25, 0x00	; 0
    1624:	02 2e       	mov	r0, r18
    1626:	02 c0       	rjmp	.+4      	; 0x162c <Port_Init+0x216>
    1628:	88 0f       	add	r24, r24
    162a:	99 1f       	adc	r25, r25
    162c:	0a 94       	dec	r0
    162e:	e2 f7       	brpl	.-8      	; 0x1628 <Port_Init+0x212>
    1630:	84 2b       	or	r24, r20
    1632:	8c 93       	st	X, r24
    1634:	6d c2       	rjmp	.+1242   	; 0x1b10 <Port_Init+0x6fa>
			}
			else if (PinCfgs[i].Dir==Dio_INPUT)
    1636:	89 81       	ldd	r24, Y+1	; 0x01
    1638:	28 2f       	mov	r18, r24
    163a:	30 e0       	ldi	r19, 0x00	; 0
    163c:	c9 01       	movw	r24, r18
    163e:	88 0f       	add	r24, r24
    1640:	99 1f       	adc	r25, r25
    1642:	82 0f       	add	r24, r18
    1644:	93 1f       	adc	r25, r19
    1646:	fc 01       	movw	r30, r24
    1648:	ea 5f       	subi	r30, 0xFA	; 250
    164a:	fd 4f       	sbci	r31, 0xFD	; 253
    164c:	80 81       	ld	r24, Z
    164e:	81 30       	cpi	r24, 0x01	; 1
    1650:	01 f5       	brne	.+64     	; 0x1692 <Port_Init+0x27c>
			{
				CLR_BIT(DDRB,PinCfgs[i].Pin);
    1652:	a7 e3       	ldi	r26, 0x37	; 55
    1654:	b0 e0       	ldi	r27, 0x00	; 0
    1656:	e7 e3       	ldi	r30, 0x37	; 55
    1658:	f0 e0       	ldi	r31, 0x00	; 0
    165a:	80 81       	ld	r24, Z
    165c:	48 2f       	mov	r20, r24
    165e:	89 81       	ldd	r24, Y+1	; 0x01
    1660:	28 2f       	mov	r18, r24
    1662:	30 e0       	ldi	r19, 0x00	; 0
    1664:	c9 01       	movw	r24, r18
    1666:	88 0f       	add	r24, r24
    1668:	99 1f       	adc	r25, r25
    166a:	82 0f       	add	r24, r18
    166c:	93 1f       	adc	r25, r19
    166e:	fc 01       	movw	r30, r24
    1670:	eb 5f       	subi	r30, 0xFB	; 251
    1672:	fd 4f       	sbci	r31, 0xFD	; 253
    1674:	80 81       	ld	r24, Z
    1676:	28 2f       	mov	r18, r24
    1678:	30 e0       	ldi	r19, 0x00	; 0
    167a:	81 e0       	ldi	r24, 0x01	; 1
    167c:	90 e0       	ldi	r25, 0x00	; 0
    167e:	02 2e       	mov	r0, r18
    1680:	02 c0       	rjmp	.+4      	; 0x1686 <Port_Init+0x270>
    1682:	88 0f       	add	r24, r24
    1684:	99 1f       	adc	r25, r25
    1686:	0a 94       	dec	r0
    1688:	e2 f7       	brpl	.-8      	; 0x1682 <Port_Init+0x26c>
    168a:	80 95       	com	r24
    168c:	84 23       	and	r24, r20
    168e:	8c 93       	st	X, r24
    1690:	3f c2       	rjmp	.+1150   	; 0x1b10 <Port_Init+0x6fa>
			}
			else if (PinCfgs[i].Dir==Dio_INPULL)
    1692:	89 81       	ldd	r24, Y+1	; 0x01
    1694:	28 2f       	mov	r18, r24
    1696:	30 e0       	ldi	r19, 0x00	; 0
    1698:	c9 01       	movw	r24, r18
    169a:	88 0f       	add	r24, r24
    169c:	99 1f       	adc	r25, r25
    169e:	82 0f       	add	r24, r18
    16a0:	93 1f       	adc	r25, r19
    16a2:	fc 01       	movw	r30, r24
    16a4:	ea 5f       	subi	r30, 0xFA	; 250
    16a6:	fd 4f       	sbci	r31, 0xFD	; 253
    16a8:	80 81       	ld	r24, Z
    16aa:	82 30       	cpi	r24, 0x02	; 2
    16ac:	09 f0       	breq	.+2      	; 0x16b0 <Port_Init+0x29a>
    16ae:	30 c2       	rjmp	.+1120   	; 0x1b10 <Port_Init+0x6fa>
			{
				CLR_BIT(DDRB,PinCfgs[i].Pin);
    16b0:	a7 e3       	ldi	r26, 0x37	; 55
    16b2:	b0 e0       	ldi	r27, 0x00	; 0
    16b4:	e7 e3       	ldi	r30, 0x37	; 55
    16b6:	f0 e0       	ldi	r31, 0x00	; 0
    16b8:	80 81       	ld	r24, Z
    16ba:	48 2f       	mov	r20, r24
    16bc:	89 81       	ldd	r24, Y+1	; 0x01
    16be:	28 2f       	mov	r18, r24
    16c0:	30 e0       	ldi	r19, 0x00	; 0
    16c2:	c9 01       	movw	r24, r18
    16c4:	88 0f       	add	r24, r24
    16c6:	99 1f       	adc	r25, r25
    16c8:	82 0f       	add	r24, r18
    16ca:	93 1f       	adc	r25, r19
    16cc:	fc 01       	movw	r30, r24
    16ce:	eb 5f       	subi	r30, 0xFB	; 251
    16d0:	fd 4f       	sbci	r31, 0xFD	; 253
    16d2:	80 81       	ld	r24, Z
    16d4:	28 2f       	mov	r18, r24
    16d6:	30 e0       	ldi	r19, 0x00	; 0
    16d8:	81 e0       	ldi	r24, 0x01	; 1
    16da:	90 e0       	ldi	r25, 0x00	; 0
    16dc:	02 c0       	rjmp	.+4      	; 0x16e2 <Port_Init+0x2cc>
    16de:	88 0f       	add	r24, r24
    16e0:	99 1f       	adc	r25, r25
    16e2:	2a 95       	dec	r18
    16e4:	e2 f7       	brpl	.-8      	; 0x16de <Port_Init+0x2c8>
    16e6:	80 95       	com	r24
    16e8:	84 23       	and	r24, r20
    16ea:	8c 93       	st	X, r24
				SET_BIT(PORTB,PinCfgs[i].Pin);
    16ec:	a8 e3       	ldi	r26, 0x38	; 56
    16ee:	b0 e0       	ldi	r27, 0x00	; 0
    16f0:	e8 e3       	ldi	r30, 0x38	; 56
    16f2:	f0 e0       	ldi	r31, 0x00	; 0
    16f4:	80 81       	ld	r24, Z
    16f6:	48 2f       	mov	r20, r24
    16f8:	89 81       	ldd	r24, Y+1	; 0x01
    16fa:	28 2f       	mov	r18, r24
    16fc:	30 e0       	ldi	r19, 0x00	; 0
    16fe:	c9 01       	movw	r24, r18
    1700:	88 0f       	add	r24, r24
    1702:	99 1f       	adc	r25, r25
    1704:	82 0f       	add	r24, r18
    1706:	93 1f       	adc	r25, r19
    1708:	fc 01       	movw	r30, r24
    170a:	eb 5f       	subi	r30, 0xFB	; 251
    170c:	fd 4f       	sbci	r31, 0xFD	; 253
    170e:	80 81       	ld	r24, Z
    1710:	28 2f       	mov	r18, r24
    1712:	30 e0       	ldi	r19, 0x00	; 0
    1714:	81 e0       	ldi	r24, 0x01	; 1
    1716:	90 e0       	ldi	r25, 0x00	; 0
    1718:	02 2e       	mov	r0, r18
    171a:	02 c0       	rjmp	.+4      	; 0x1720 <Port_Init+0x30a>
    171c:	88 0f       	add	r24, r24
    171e:	99 1f       	adc	r25, r25
    1720:	0a 94       	dec	r0
    1722:	e2 f7       	brpl	.-8      	; 0x171c <Port_Init+0x306>
    1724:	84 2b       	or	r24, r20
    1726:	8c 93       	st	X, r24
    1728:	f3 c1       	rjmp	.+998    	; 0x1b10 <Port_Init+0x6fa>
			}
			break;
				case Dio_PORTC:
				if (PinCfgs[i].Dir==Dio_OUTPUT)
    172a:	89 81       	ldd	r24, Y+1	; 0x01
    172c:	28 2f       	mov	r18, r24
    172e:	30 e0       	ldi	r19, 0x00	; 0
    1730:	c9 01       	movw	r24, r18
    1732:	88 0f       	add	r24, r24
    1734:	99 1f       	adc	r25, r25
    1736:	82 0f       	add	r24, r18
    1738:	93 1f       	adc	r25, r19
    173a:	fc 01       	movw	r30, r24
    173c:	ea 5f       	subi	r30, 0xFA	; 250
    173e:	fd 4f       	sbci	r31, 0xFD	; 253
    1740:	80 81       	ld	r24, Z
    1742:	88 23       	and	r24, r24
    1744:	f9 f4       	brne	.+62     	; 0x1784 <Port_Init+0x36e>
				{
					SET_BIT(DDRC,PinCfgs[i].Pin);
    1746:	a4 e3       	ldi	r26, 0x34	; 52
    1748:	b0 e0       	ldi	r27, 0x00	; 0
    174a:	e4 e3       	ldi	r30, 0x34	; 52
    174c:	f0 e0       	ldi	r31, 0x00	; 0
    174e:	80 81       	ld	r24, Z
    1750:	48 2f       	mov	r20, r24
    1752:	89 81       	ldd	r24, Y+1	; 0x01
    1754:	28 2f       	mov	r18, r24
    1756:	30 e0       	ldi	r19, 0x00	; 0
    1758:	c9 01       	movw	r24, r18
    175a:	88 0f       	add	r24, r24
    175c:	99 1f       	adc	r25, r25
    175e:	82 0f       	add	r24, r18
    1760:	93 1f       	adc	r25, r19
    1762:	fc 01       	movw	r30, r24
    1764:	eb 5f       	subi	r30, 0xFB	; 251
    1766:	fd 4f       	sbci	r31, 0xFD	; 253
    1768:	80 81       	ld	r24, Z
    176a:	28 2f       	mov	r18, r24
    176c:	30 e0       	ldi	r19, 0x00	; 0
    176e:	81 e0       	ldi	r24, 0x01	; 1
    1770:	90 e0       	ldi	r25, 0x00	; 0
    1772:	02 2e       	mov	r0, r18
    1774:	02 c0       	rjmp	.+4      	; 0x177a <Port_Init+0x364>
    1776:	88 0f       	add	r24, r24
    1778:	99 1f       	adc	r25, r25
    177a:	0a 94       	dec	r0
    177c:	e2 f7       	brpl	.-8      	; 0x1776 <Port_Init+0x360>
    177e:	84 2b       	or	r24, r20
    1780:	8c 93       	st	X, r24
    1782:	c6 c1       	rjmp	.+908    	; 0x1b10 <Port_Init+0x6fa>
				}
				else if (PinCfgs[i].Dir==Dio_INPUT)
    1784:	89 81       	ldd	r24, Y+1	; 0x01
    1786:	28 2f       	mov	r18, r24
    1788:	30 e0       	ldi	r19, 0x00	; 0
    178a:	c9 01       	movw	r24, r18
    178c:	88 0f       	add	r24, r24
    178e:	99 1f       	adc	r25, r25
    1790:	82 0f       	add	r24, r18
    1792:	93 1f       	adc	r25, r19
    1794:	fc 01       	movw	r30, r24
    1796:	ea 5f       	subi	r30, 0xFA	; 250
    1798:	fd 4f       	sbci	r31, 0xFD	; 253
    179a:	80 81       	ld	r24, Z
    179c:	81 30       	cpi	r24, 0x01	; 1
    179e:	01 f5       	brne	.+64     	; 0x17e0 <Port_Init+0x3ca>
				{
					CLR_BIT(DDRC,PinCfgs[i].Pin);
    17a0:	a4 e3       	ldi	r26, 0x34	; 52
    17a2:	b0 e0       	ldi	r27, 0x00	; 0
    17a4:	e4 e3       	ldi	r30, 0x34	; 52
    17a6:	f0 e0       	ldi	r31, 0x00	; 0
    17a8:	80 81       	ld	r24, Z
    17aa:	48 2f       	mov	r20, r24
    17ac:	89 81       	ldd	r24, Y+1	; 0x01
    17ae:	28 2f       	mov	r18, r24
    17b0:	30 e0       	ldi	r19, 0x00	; 0
    17b2:	c9 01       	movw	r24, r18
    17b4:	88 0f       	add	r24, r24
    17b6:	99 1f       	adc	r25, r25
    17b8:	82 0f       	add	r24, r18
    17ba:	93 1f       	adc	r25, r19
    17bc:	fc 01       	movw	r30, r24
    17be:	eb 5f       	subi	r30, 0xFB	; 251
    17c0:	fd 4f       	sbci	r31, 0xFD	; 253
    17c2:	80 81       	ld	r24, Z
    17c4:	28 2f       	mov	r18, r24
    17c6:	30 e0       	ldi	r19, 0x00	; 0
    17c8:	81 e0       	ldi	r24, 0x01	; 1
    17ca:	90 e0       	ldi	r25, 0x00	; 0
    17cc:	02 2e       	mov	r0, r18
    17ce:	02 c0       	rjmp	.+4      	; 0x17d4 <Port_Init+0x3be>
    17d0:	88 0f       	add	r24, r24
    17d2:	99 1f       	adc	r25, r25
    17d4:	0a 94       	dec	r0
    17d6:	e2 f7       	brpl	.-8      	; 0x17d0 <Port_Init+0x3ba>
    17d8:	80 95       	com	r24
    17da:	84 23       	and	r24, r20
    17dc:	8c 93       	st	X, r24
    17de:	98 c1       	rjmp	.+816    	; 0x1b10 <Port_Init+0x6fa>
				}
				else if (PinCfgs[i].Dir==Dio_INPULL)
    17e0:	89 81       	ldd	r24, Y+1	; 0x01
    17e2:	28 2f       	mov	r18, r24
    17e4:	30 e0       	ldi	r19, 0x00	; 0
    17e6:	c9 01       	movw	r24, r18
    17e8:	88 0f       	add	r24, r24
    17ea:	99 1f       	adc	r25, r25
    17ec:	82 0f       	add	r24, r18
    17ee:	93 1f       	adc	r25, r19
    17f0:	fc 01       	movw	r30, r24
    17f2:	ea 5f       	subi	r30, 0xFA	; 250
    17f4:	fd 4f       	sbci	r31, 0xFD	; 253
    17f6:	80 81       	ld	r24, Z
    17f8:	82 30       	cpi	r24, 0x02	; 2
    17fa:	09 f0       	breq	.+2      	; 0x17fe <Port_Init+0x3e8>
    17fc:	89 c1       	rjmp	.+786    	; 0x1b10 <Port_Init+0x6fa>
				{
					CLR_BIT(DDRC,PinCfgs[i].Pin);
    17fe:	a4 e3       	ldi	r26, 0x34	; 52
    1800:	b0 e0       	ldi	r27, 0x00	; 0
    1802:	e4 e3       	ldi	r30, 0x34	; 52
    1804:	f0 e0       	ldi	r31, 0x00	; 0
    1806:	80 81       	ld	r24, Z
    1808:	48 2f       	mov	r20, r24
    180a:	89 81       	ldd	r24, Y+1	; 0x01
    180c:	28 2f       	mov	r18, r24
    180e:	30 e0       	ldi	r19, 0x00	; 0
    1810:	c9 01       	movw	r24, r18
    1812:	88 0f       	add	r24, r24
    1814:	99 1f       	adc	r25, r25
    1816:	82 0f       	add	r24, r18
    1818:	93 1f       	adc	r25, r19
    181a:	fc 01       	movw	r30, r24
    181c:	eb 5f       	subi	r30, 0xFB	; 251
    181e:	fd 4f       	sbci	r31, 0xFD	; 253
    1820:	80 81       	ld	r24, Z
    1822:	28 2f       	mov	r18, r24
    1824:	30 e0       	ldi	r19, 0x00	; 0
    1826:	81 e0       	ldi	r24, 0x01	; 1
    1828:	90 e0       	ldi	r25, 0x00	; 0
    182a:	02 c0       	rjmp	.+4      	; 0x1830 <Port_Init+0x41a>
    182c:	88 0f       	add	r24, r24
    182e:	99 1f       	adc	r25, r25
    1830:	2a 95       	dec	r18
    1832:	e2 f7       	brpl	.-8      	; 0x182c <Port_Init+0x416>
    1834:	80 95       	com	r24
    1836:	84 23       	and	r24, r20
    1838:	8c 93       	st	X, r24
					SET_BIT(PORTC,PinCfgs[i].Pin);
    183a:	a5 e3       	ldi	r26, 0x35	; 53
    183c:	b0 e0       	ldi	r27, 0x00	; 0
    183e:	e5 e3       	ldi	r30, 0x35	; 53
    1840:	f0 e0       	ldi	r31, 0x00	; 0
    1842:	80 81       	ld	r24, Z
    1844:	48 2f       	mov	r20, r24
    1846:	89 81       	ldd	r24, Y+1	; 0x01
    1848:	28 2f       	mov	r18, r24
    184a:	30 e0       	ldi	r19, 0x00	; 0
    184c:	c9 01       	movw	r24, r18
    184e:	88 0f       	add	r24, r24
    1850:	99 1f       	adc	r25, r25
    1852:	82 0f       	add	r24, r18
    1854:	93 1f       	adc	r25, r19
    1856:	fc 01       	movw	r30, r24
    1858:	eb 5f       	subi	r30, 0xFB	; 251
    185a:	fd 4f       	sbci	r31, 0xFD	; 253
    185c:	80 81       	ld	r24, Z
    185e:	28 2f       	mov	r18, r24
    1860:	30 e0       	ldi	r19, 0x00	; 0
    1862:	81 e0       	ldi	r24, 0x01	; 1
    1864:	90 e0       	ldi	r25, 0x00	; 0
    1866:	02 2e       	mov	r0, r18
    1868:	02 c0       	rjmp	.+4      	; 0x186e <Port_Init+0x458>
    186a:	88 0f       	add	r24, r24
    186c:	99 1f       	adc	r25, r25
    186e:	0a 94       	dec	r0
    1870:	e2 f7       	brpl	.-8      	; 0x186a <Port_Init+0x454>
    1872:	84 2b       	or	r24, r20
    1874:	8c 93       	st	X, r24
    1876:	4c c1       	rjmp	.+664    	; 0x1b10 <Port_Init+0x6fa>
				}
				break;
					case Dio_PORTD:
					if (PinCfgs[i].Dir==Dio_OUTPUT)
    1878:	89 81       	ldd	r24, Y+1	; 0x01
    187a:	28 2f       	mov	r18, r24
    187c:	30 e0       	ldi	r19, 0x00	; 0
    187e:	c9 01       	movw	r24, r18
    1880:	88 0f       	add	r24, r24
    1882:	99 1f       	adc	r25, r25
    1884:	82 0f       	add	r24, r18
    1886:	93 1f       	adc	r25, r19
    1888:	fc 01       	movw	r30, r24
    188a:	ea 5f       	subi	r30, 0xFA	; 250
    188c:	fd 4f       	sbci	r31, 0xFD	; 253
    188e:	80 81       	ld	r24, Z
    1890:	88 23       	and	r24, r24
    1892:	f9 f4       	brne	.+62     	; 0x18d2 <Port_Init+0x4bc>
					{
						SET_BIT(DDRD,PinCfgs[i].Pin);
    1894:	a1 e3       	ldi	r26, 0x31	; 49
    1896:	b0 e0       	ldi	r27, 0x00	; 0
    1898:	e1 e3       	ldi	r30, 0x31	; 49
    189a:	f0 e0       	ldi	r31, 0x00	; 0
    189c:	80 81       	ld	r24, Z
    189e:	48 2f       	mov	r20, r24
    18a0:	89 81       	ldd	r24, Y+1	; 0x01
    18a2:	28 2f       	mov	r18, r24
    18a4:	30 e0       	ldi	r19, 0x00	; 0
    18a6:	c9 01       	movw	r24, r18
    18a8:	88 0f       	add	r24, r24
    18aa:	99 1f       	adc	r25, r25
    18ac:	82 0f       	add	r24, r18
    18ae:	93 1f       	adc	r25, r19
    18b0:	fc 01       	movw	r30, r24
    18b2:	eb 5f       	subi	r30, 0xFB	; 251
    18b4:	fd 4f       	sbci	r31, 0xFD	; 253
    18b6:	80 81       	ld	r24, Z
    18b8:	28 2f       	mov	r18, r24
    18ba:	30 e0       	ldi	r19, 0x00	; 0
    18bc:	81 e0       	ldi	r24, 0x01	; 1
    18be:	90 e0       	ldi	r25, 0x00	; 0
    18c0:	02 2e       	mov	r0, r18
    18c2:	02 c0       	rjmp	.+4      	; 0x18c8 <Port_Init+0x4b2>
    18c4:	88 0f       	add	r24, r24
    18c6:	99 1f       	adc	r25, r25
    18c8:	0a 94       	dec	r0
    18ca:	e2 f7       	brpl	.-8      	; 0x18c4 <Port_Init+0x4ae>
    18cc:	84 2b       	or	r24, r20
    18ce:	8c 93       	st	X, r24
    18d0:	1f c1       	rjmp	.+574    	; 0x1b10 <Port_Init+0x6fa>
					}
					else if (PinCfgs[i].Dir==Dio_INPUT)
    18d2:	89 81       	ldd	r24, Y+1	; 0x01
    18d4:	28 2f       	mov	r18, r24
    18d6:	30 e0       	ldi	r19, 0x00	; 0
    18d8:	c9 01       	movw	r24, r18
    18da:	88 0f       	add	r24, r24
    18dc:	99 1f       	adc	r25, r25
    18de:	82 0f       	add	r24, r18
    18e0:	93 1f       	adc	r25, r19
    18e2:	fc 01       	movw	r30, r24
    18e4:	ea 5f       	subi	r30, 0xFA	; 250
    18e6:	fd 4f       	sbci	r31, 0xFD	; 253
    18e8:	80 81       	ld	r24, Z
    18ea:	81 30       	cpi	r24, 0x01	; 1
    18ec:	01 f5       	brne	.+64     	; 0x192e <Port_Init+0x518>
					{
						CLR_BIT(DDRD,PinCfgs[i].Pin);
    18ee:	a1 e3       	ldi	r26, 0x31	; 49
    18f0:	b0 e0       	ldi	r27, 0x00	; 0
    18f2:	e1 e3       	ldi	r30, 0x31	; 49
    18f4:	f0 e0       	ldi	r31, 0x00	; 0
    18f6:	80 81       	ld	r24, Z
    18f8:	48 2f       	mov	r20, r24
    18fa:	89 81       	ldd	r24, Y+1	; 0x01
    18fc:	28 2f       	mov	r18, r24
    18fe:	30 e0       	ldi	r19, 0x00	; 0
    1900:	c9 01       	movw	r24, r18
    1902:	88 0f       	add	r24, r24
    1904:	99 1f       	adc	r25, r25
    1906:	82 0f       	add	r24, r18
    1908:	93 1f       	adc	r25, r19
    190a:	fc 01       	movw	r30, r24
    190c:	eb 5f       	subi	r30, 0xFB	; 251
    190e:	fd 4f       	sbci	r31, 0xFD	; 253
    1910:	80 81       	ld	r24, Z
    1912:	28 2f       	mov	r18, r24
    1914:	30 e0       	ldi	r19, 0x00	; 0
    1916:	81 e0       	ldi	r24, 0x01	; 1
    1918:	90 e0       	ldi	r25, 0x00	; 0
    191a:	02 2e       	mov	r0, r18
    191c:	02 c0       	rjmp	.+4      	; 0x1922 <Port_Init+0x50c>
    191e:	88 0f       	add	r24, r24
    1920:	99 1f       	adc	r25, r25
    1922:	0a 94       	dec	r0
    1924:	e2 f7       	brpl	.-8      	; 0x191e <Port_Init+0x508>
    1926:	80 95       	com	r24
    1928:	84 23       	and	r24, r20
    192a:	8c 93       	st	X, r24
    192c:	f1 c0       	rjmp	.+482    	; 0x1b10 <Port_Init+0x6fa>
					}
					else if (PinCfgs[i].Dir==Dio_INPULL)
    192e:	89 81       	ldd	r24, Y+1	; 0x01
    1930:	28 2f       	mov	r18, r24
    1932:	30 e0       	ldi	r19, 0x00	; 0
    1934:	c9 01       	movw	r24, r18
    1936:	88 0f       	add	r24, r24
    1938:	99 1f       	adc	r25, r25
    193a:	82 0f       	add	r24, r18
    193c:	93 1f       	adc	r25, r19
    193e:	fc 01       	movw	r30, r24
    1940:	ea 5f       	subi	r30, 0xFA	; 250
    1942:	fd 4f       	sbci	r31, 0xFD	; 253
    1944:	80 81       	ld	r24, Z
    1946:	82 30       	cpi	r24, 0x02	; 2
    1948:	09 f0       	breq	.+2      	; 0x194c <Port_Init+0x536>
    194a:	e2 c0       	rjmp	.+452    	; 0x1b10 <Port_Init+0x6fa>
					{
						CLR_BIT(DDRD,PinCfgs[i].Pin);
    194c:	a1 e3       	ldi	r26, 0x31	; 49
    194e:	b0 e0       	ldi	r27, 0x00	; 0
    1950:	e1 e3       	ldi	r30, 0x31	; 49
    1952:	f0 e0       	ldi	r31, 0x00	; 0
    1954:	80 81       	ld	r24, Z
    1956:	48 2f       	mov	r20, r24
    1958:	89 81       	ldd	r24, Y+1	; 0x01
    195a:	28 2f       	mov	r18, r24
    195c:	30 e0       	ldi	r19, 0x00	; 0
    195e:	c9 01       	movw	r24, r18
    1960:	88 0f       	add	r24, r24
    1962:	99 1f       	adc	r25, r25
    1964:	82 0f       	add	r24, r18
    1966:	93 1f       	adc	r25, r19
    1968:	fc 01       	movw	r30, r24
    196a:	eb 5f       	subi	r30, 0xFB	; 251
    196c:	fd 4f       	sbci	r31, 0xFD	; 253
    196e:	80 81       	ld	r24, Z
    1970:	28 2f       	mov	r18, r24
    1972:	30 e0       	ldi	r19, 0x00	; 0
    1974:	81 e0       	ldi	r24, 0x01	; 1
    1976:	90 e0       	ldi	r25, 0x00	; 0
    1978:	02 c0       	rjmp	.+4      	; 0x197e <Port_Init+0x568>
    197a:	88 0f       	add	r24, r24
    197c:	99 1f       	adc	r25, r25
    197e:	2a 95       	dec	r18
    1980:	e2 f7       	brpl	.-8      	; 0x197a <Port_Init+0x564>
    1982:	80 95       	com	r24
    1984:	84 23       	and	r24, r20
    1986:	8c 93       	st	X, r24
						SET_BIT(PORTD,PinCfgs[i].Pin);
    1988:	a2 e3       	ldi	r26, 0x32	; 50
    198a:	b0 e0       	ldi	r27, 0x00	; 0
    198c:	e2 e3       	ldi	r30, 0x32	; 50
    198e:	f0 e0       	ldi	r31, 0x00	; 0
    1990:	80 81       	ld	r24, Z
    1992:	48 2f       	mov	r20, r24
    1994:	89 81       	ldd	r24, Y+1	; 0x01
    1996:	28 2f       	mov	r18, r24
    1998:	30 e0       	ldi	r19, 0x00	; 0
    199a:	c9 01       	movw	r24, r18
    199c:	88 0f       	add	r24, r24
    199e:	99 1f       	adc	r25, r25
    19a0:	82 0f       	add	r24, r18
    19a2:	93 1f       	adc	r25, r19
    19a4:	fc 01       	movw	r30, r24
    19a6:	eb 5f       	subi	r30, 0xFB	; 251
    19a8:	fd 4f       	sbci	r31, 0xFD	; 253
    19aa:	80 81       	ld	r24, Z
    19ac:	28 2f       	mov	r18, r24
    19ae:	30 e0       	ldi	r19, 0x00	; 0
    19b0:	81 e0       	ldi	r24, 0x01	; 1
    19b2:	90 e0       	ldi	r25, 0x00	; 0
    19b4:	02 2e       	mov	r0, r18
    19b6:	02 c0       	rjmp	.+4      	; 0x19bc <Port_Init+0x5a6>
    19b8:	88 0f       	add	r24, r24
    19ba:	99 1f       	adc	r25, r25
    19bc:	0a 94       	dec	r0
    19be:	e2 f7       	brpl	.-8      	; 0x19b8 <Port_Init+0x5a2>
    19c0:	84 2b       	or	r24, r20
    19c2:	8c 93       	st	X, r24
    19c4:	a5 c0       	rjmp	.+330    	; 0x1b10 <Port_Init+0x6fa>
					}
					break;
					case Dio_PORTE:
					if (PinCfgs[i].Dir==Dio_OUTPUT)
    19c6:	89 81       	ldd	r24, Y+1	; 0x01
    19c8:	28 2f       	mov	r18, r24
    19ca:	30 e0       	ldi	r19, 0x00	; 0
    19cc:	c9 01       	movw	r24, r18
    19ce:	88 0f       	add	r24, r24
    19d0:	99 1f       	adc	r25, r25
    19d2:	82 0f       	add	r24, r18
    19d4:	93 1f       	adc	r25, r19
    19d6:	fc 01       	movw	r30, r24
    19d8:	ea 5f       	subi	r30, 0xFA	; 250
    19da:	fd 4f       	sbci	r31, 0xFD	; 253
    19dc:	80 81       	ld	r24, Z
    19de:	88 23       	and	r24, r24
    19e0:	f9 f4       	brne	.+62     	; 0x1a20 <Port_Init+0x60a>
					{
						SET_BIT(DDRE,PinCfgs[i].Pin);
    19e2:	a2 e2       	ldi	r26, 0x22	; 34
    19e4:	b0 e0       	ldi	r27, 0x00	; 0
    19e6:	e2 e2       	ldi	r30, 0x22	; 34
    19e8:	f0 e0       	ldi	r31, 0x00	; 0
    19ea:	80 81       	ld	r24, Z
    19ec:	48 2f       	mov	r20, r24
    19ee:	89 81       	ldd	r24, Y+1	; 0x01
    19f0:	28 2f       	mov	r18, r24
    19f2:	30 e0       	ldi	r19, 0x00	; 0
    19f4:	c9 01       	movw	r24, r18
    19f6:	88 0f       	add	r24, r24
    19f8:	99 1f       	adc	r25, r25
    19fa:	82 0f       	add	r24, r18
    19fc:	93 1f       	adc	r25, r19
    19fe:	fc 01       	movw	r30, r24
    1a00:	eb 5f       	subi	r30, 0xFB	; 251
    1a02:	fd 4f       	sbci	r31, 0xFD	; 253
    1a04:	80 81       	ld	r24, Z
    1a06:	28 2f       	mov	r18, r24
    1a08:	30 e0       	ldi	r19, 0x00	; 0
    1a0a:	81 e0       	ldi	r24, 0x01	; 1
    1a0c:	90 e0       	ldi	r25, 0x00	; 0
    1a0e:	02 2e       	mov	r0, r18
    1a10:	02 c0       	rjmp	.+4      	; 0x1a16 <Port_Init+0x600>
    1a12:	88 0f       	add	r24, r24
    1a14:	99 1f       	adc	r25, r25
    1a16:	0a 94       	dec	r0
    1a18:	e2 f7       	brpl	.-8      	; 0x1a12 <Port_Init+0x5fc>
    1a1a:	84 2b       	or	r24, r20
    1a1c:	8c 93       	st	X, r24
    1a1e:	78 c0       	rjmp	.+240    	; 0x1b10 <Port_Init+0x6fa>
					}
					else if (PinCfgs[i].Dir==Dio_INPUT)
    1a20:	89 81       	ldd	r24, Y+1	; 0x01
    1a22:	28 2f       	mov	r18, r24
    1a24:	30 e0       	ldi	r19, 0x00	; 0
    1a26:	c9 01       	movw	r24, r18
    1a28:	88 0f       	add	r24, r24
    1a2a:	99 1f       	adc	r25, r25
    1a2c:	82 0f       	add	r24, r18
    1a2e:	93 1f       	adc	r25, r19
    1a30:	fc 01       	movw	r30, r24
    1a32:	ea 5f       	subi	r30, 0xFA	; 250
    1a34:	fd 4f       	sbci	r31, 0xFD	; 253
    1a36:	80 81       	ld	r24, Z
    1a38:	81 30       	cpi	r24, 0x01	; 1
    1a3a:	01 f5       	brne	.+64     	; 0x1a7c <Port_Init+0x666>
					{
						CLR_BIT(DDRE,PinCfgs[i].Pin);
    1a3c:	a2 e2       	ldi	r26, 0x22	; 34
    1a3e:	b0 e0       	ldi	r27, 0x00	; 0
    1a40:	e2 e2       	ldi	r30, 0x22	; 34
    1a42:	f0 e0       	ldi	r31, 0x00	; 0
    1a44:	80 81       	ld	r24, Z
    1a46:	48 2f       	mov	r20, r24
    1a48:	89 81       	ldd	r24, Y+1	; 0x01
    1a4a:	28 2f       	mov	r18, r24
    1a4c:	30 e0       	ldi	r19, 0x00	; 0
    1a4e:	c9 01       	movw	r24, r18
    1a50:	88 0f       	add	r24, r24
    1a52:	99 1f       	adc	r25, r25
    1a54:	82 0f       	add	r24, r18
    1a56:	93 1f       	adc	r25, r19
    1a58:	fc 01       	movw	r30, r24
    1a5a:	eb 5f       	subi	r30, 0xFB	; 251
    1a5c:	fd 4f       	sbci	r31, 0xFD	; 253
    1a5e:	80 81       	ld	r24, Z
    1a60:	28 2f       	mov	r18, r24
    1a62:	30 e0       	ldi	r19, 0x00	; 0
    1a64:	81 e0       	ldi	r24, 0x01	; 1
    1a66:	90 e0       	ldi	r25, 0x00	; 0
    1a68:	02 2e       	mov	r0, r18
    1a6a:	02 c0       	rjmp	.+4      	; 0x1a70 <Port_Init+0x65a>
    1a6c:	88 0f       	add	r24, r24
    1a6e:	99 1f       	adc	r25, r25
    1a70:	0a 94       	dec	r0
    1a72:	e2 f7       	brpl	.-8      	; 0x1a6c <Port_Init+0x656>
    1a74:	80 95       	com	r24
    1a76:	84 23       	and	r24, r20
    1a78:	8c 93       	st	X, r24
    1a7a:	4a c0       	rjmp	.+148    	; 0x1b10 <Port_Init+0x6fa>
					}
					else if (PinCfgs[i].Dir==Dio_INPULL)
    1a7c:	89 81       	ldd	r24, Y+1	; 0x01
    1a7e:	28 2f       	mov	r18, r24
    1a80:	30 e0       	ldi	r19, 0x00	; 0
    1a82:	c9 01       	movw	r24, r18
    1a84:	88 0f       	add	r24, r24
    1a86:	99 1f       	adc	r25, r25
    1a88:	82 0f       	add	r24, r18
    1a8a:	93 1f       	adc	r25, r19
    1a8c:	fc 01       	movw	r30, r24
    1a8e:	ea 5f       	subi	r30, 0xFA	; 250
    1a90:	fd 4f       	sbci	r31, 0xFD	; 253
    1a92:	80 81       	ld	r24, Z
    1a94:	82 30       	cpi	r24, 0x02	; 2
    1a96:	e1 f5       	brne	.+120    	; 0x1b10 <Port_Init+0x6fa>
					{
						CLR_BIT(DDRE,PinCfgs[i].Pin);
    1a98:	a2 e2       	ldi	r26, 0x22	; 34
    1a9a:	b0 e0       	ldi	r27, 0x00	; 0
    1a9c:	e2 e2       	ldi	r30, 0x22	; 34
    1a9e:	f0 e0       	ldi	r31, 0x00	; 0
    1aa0:	80 81       	ld	r24, Z
    1aa2:	48 2f       	mov	r20, r24
    1aa4:	89 81       	ldd	r24, Y+1	; 0x01
    1aa6:	28 2f       	mov	r18, r24
    1aa8:	30 e0       	ldi	r19, 0x00	; 0
    1aaa:	c9 01       	movw	r24, r18
    1aac:	88 0f       	add	r24, r24
    1aae:	99 1f       	adc	r25, r25
    1ab0:	82 0f       	add	r24, r18
    1ab2:	93 1f       	adc	r25, r19
    1ab4:	fc 01       	movw	r30, r24
    1ab6:	eb 5f       	subi	r30, 0xFB	; 251
    1ab8:	fd 4f       	sbci	r31, 0xFD	; 253
    1aba:	80 81       	ld	r24, Z
    1abc:	28 2f       	mov	r18, r24
    1abe:	30 e0       	ldi	r19, 0x00	; 0
    1ac0:	81 e0       	ldi	r24, 0x01	; 1
    1ac2:	90 e0       	ldi	r25, 0x00	; 0
    1ac4:	02 c0       	rjmp	.+4      	; 0x1aca <Port_Init+0x6b4>
    1ac6:	88 0f       	add	r24, r24
    1ac8:	99 1f       	adc	r25, r25
    1aca:	2a 95       	dec	r18
    1acc:	e2 f7       	brpl	.-8      	; 0x1ac6 <Port_Init+0x6b0>
    1ace:	80 95       	com	r24
    1ad0:	84 23       	and	r24, r20
    1ad2:	8c 93       	st	X, r24
						SET_BIT(PORTE,PinCfgs[i].Pin);
    1ad4:	a3 e2       	ldi	r26, 0x23	; 35
    1ad6:	b0 e0       	ldi	r27, 0x00	; 0
    1ad8:	e3 e2       	ldi	r30, 0x23	; 35
    1ada:	f0 e0       	ldi	r31, 0x00	; 0
    1adc:	80 81       	ld	r24, Z
    1ade:	48 2f       	mov	r20, r24
    1ae0:	89 81       	ldd	r24, Y+1	; 0x01
    1ae2:	28 2f       	mov	r18, r24
    1ae4:	30 e0       	ldi	r19, 0x00	; 0
    1ae6:	c9 01       	movw	r24, r18
    1ae8:	88 0f       	add	r24, r24
    1aea:	99 1f       	adc	r25, r25
    1aec:	82 0f       	add	r24, r18
    1aee:	93 1f       	adc	r25, r19
    1af0:	fc 01       	movw	r30, r24
    1af2:	eb 5f       	subi	r30, 0xFB	; 251
    1af4:	fd 4f       	sbci	r31, 0xFD	; 253
    1af6:	80 81       	ld	r24, Z
    1af8:	28 2f       	mov	r18, r24
    1afa:	30 e0       	ldi	r19, 0x00	; 0
    1afc:	81 e0       	ldi	r24, 0x01	; 1
    1afe:	90 e0       	ldi	r25, 0x00	; 0
    1b00:	02 2e       	mov	r0, r18
    1b02:	02 c0       	rjmp	.+4      	; 0x1b08 <Port_Init+0x6f2>
    1b04:	88 0f       	add	r24, r24
    1b06:	99 1f       	adc	r25, r25
    1b08:	0a 94       	dec	r0
    1b0a:	e2 f7       	brpl	.-8      	; 0x1b04 <Port_Init+0x6ee>
    1b0c:	84 2b       	or	r24, r20
    1b0e:	8c 93       	st	X, r24
#include "../../MCAL/PORT/Port_Cfg.h"
extern Pin_CfgType PinCfgs[];					   
void Port_Init (void)
{
	u8 i=0;
	for (i=0;i<64;i++)
    1b10:	89 81       	ldd	r24, Y+1	; 0x01
    1b12:	8f 5f       	subi	r24, 0xFF	; 255
    1b14:	89 83       	std	Y+1, r24	; 0x01
    1b16:	89 81       	ldd	r24, Y+1	; 0x01
    1b18:	80 34       	cpi	r24, 0x40	; 64
    1b1a:	08 f4       	brcc	.+2      	; 0x1b1e <Port_Init+0x708>
    1b1c:	85 cc       	rjmp	.-1782   	; 0x1428 <Port_Init+0x12>
						SET_BIT(PORTE,PinCfgs[i].Pin);
					}
					break;
		}
	}
}
    1b1e:	0f 90       	pop	r0
    1b20:	0f 90       	pop	r0
    1b22:	0f 90       	pop	r0
    1b24:	cf 91       	pop	r28
    1b26:	df 91       	pop	r29
    1b28:	08 95       	ret

00001b2a <GI_Enable>:
#include "BIT_MATH.h"
#include "../../MCAL/GI/GI_Interface.h"
#include "../../MCAL/GI/GI_register.h"

void GI_Enable (void)
{
    1b2a:	df 93       	push	r29
    1b2c:	cf 93       	push	r28
    1b2e:	cd b7       	in	r28, 0x3d	; 61
    1b30:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(SREG,I);
    1b32:	af e5       	ldi	r26, 0x5F	; 95
    1b34:	b0 e0       	ldi	r27, 0x00	; 0
    1b36:	ef e5       	ldi	r30, 0x5F	; 95
    1b38:	f0 e0       	ldi	r31, 0x00	; 0
    1b3a:	80 81       	ld	r24, Z
    1b3c:	80 68       	ori	r24, 0x80	; 128
    1b3e:	8c 93       	st	X, r24
}
    1b40:	cf 91       	pop	r28
    1b42:	df 91       	pop	r29
    1b44:	08 95       	ret

00001b46 <GI_Disable>:
void GI_Disable (void)
{
    1b46:	df 93       	push	r29
    1b48:	cf 93       	push	r28
    1b4a:	cd b7       	in	r28, 0x3d	; 61
    1b4c:	de b7       	in	r29, 0x3e	; 62
	CLR_BIT(SREG,I);
    1b4e:	af e5       	ldi	r26, 0x5F	; 95
    1b50:	b0 e0       	ldi	r27, 0x00	; 0
    1b52:	ef e5       	ldi	r30, 0x5F	; 95
    1b54:	f0 e0       	ldi	r31, 0x00	; 0
    1b56:	80 81       	ld	r24, Z
    1b58:	8f 77       	andi	r24, 0x7F	; 127
    1b5a:	8c 93       	st	X, r24
}
    1b5c:	cf 91       	pop	r28
    1b5e:	df 91       	pop	r29
    1b60:	08 95       	ret

00001b62 <Dio_WriteChannel>:
#include "../../MCAL/DIO/DIO.h"
#include "../../MCAL/PORT/Port.h"
#include "../../MCAL/DIO/Dio_Types.h"

void Dio_WriteChannel(Dio_ChannelType ChannelId,Dio_LevelType Level)
{
    1b62:	df 93       	push	r29
    1b64:	cf 93       	push	r28
    1b66:	00 d0       	rcall	.+0      	; 0x1b68 <Dio_WriteChannel+0x6>
    1b68:	00 d0       	rcall	.+0      	; 0x1b6a <Dio_WriteChannel+0x8>
    1b6a:	0f 92       	push	r0
    1b6c:	cd b7       	in	r28, 0x3d	; 61
    1b6e:	de b7       	in	r29, 0x3e	; 62
    1b70:	8a 83       	std	Y+2, r24	; 0x02
    1b72:	6b 83       	std	Y+3, r22	; 0x03
	Dio_PortType port=ChannelId/8;
    1b74:	8a 81       	ldd	r24, Y+2	; 0x02
    1b76:	86 95       	lsr	r24
    1b78:	86 95       	lsr	r24
    1b7a:	86 95       	lsr	r24
    1b7c:	89 83       	std	Y+1, r24	; 0x01
	switch(port)
    1b7e:	89 81       	ldd	r24, Y+1	; 0x01
    1b80:	28 2f       	mov	r18, r24
    1b82:	30 e0       	ldi	r19, 0x00	; 0
    1b84:	3d 83       	std	Y+5, r19	; 0x05
    1b86:	2c 83       	std	Y+4, r18	; 0x04
    1b88:	8c 81       	ldd	r24, Y+4	; 0x04
    1b8a:	9d 81       	ldd	r25, Y+5	; 0x05
    1b8c:	82 30       	cpi	r24, 0x02	; 2
    1b8e:	91 05       	cpc	r25, r1
    1b90:	09 f4       	brne	.+2      	; 0x1b94 <Dio_WriteChannel+0x32>
    1b92:	81 c0       	rjmp	.+258    	; 0x1c96 <Dio_WriteChannel+0x134>
    1b94:	2c 81       	ldd	r18, Y+4	; 0x04
    1b96:	3d 81       	ldd	r19, Y+5	; 0x05
    1b98:	23 30       	cpi	r18, 0x03	; 3
    1b9a:	31 05       	cpc	r19, r1
    1b9c:	5c f4       	brge	.+22     	; 0x1bb4 <Dio_WriteChannel+0x52>
    1b9e:	8c 81       	ldd	r24, Y+4	; 0x04
    1ba0:	9d 81       	ldd	r25, Y+5	; 0x05
    1ba2:	00 97       	sbiw	r24, 0x00	; 0
    1ba4:	a1 f0       	breq	.+40     	; 0x1bce <Dio_WriteChannel+0x6c>
    1ba6:	2c 81       	ldd	r18, Y+4	; 0x04
    1ba8:	3d 81       	ldd	r19, Y+5	; 0x05
    1baa:	21 30       	cpi	r18, 0x01	; 1
    1bac:	31 05       	cpc	r19, r1
    1bae:	09 f4       	brne	.+2      	; 0x1bb2 <Dio_WriteChannel+0x50>
    1bb0:	40 c0       	rjmp	.+128    	; 0x1c32 <Dio_WriteChannel+0xd0>
    1bb2:	06 c1       	rjmp	.+524    	; 0x1dc0 <Dio_WriteChannel+0x25e>
    1bb4:	8c 81       	ldd	r24, Y+4	; 0x04
    1bb6:	9d 81       	ldd	r25, Y+5	; 0x05
    1bb8:	83 30       	cpi	r24, 0x03	; 3
    1bba:	91 05       	cpc	r25, r1
    1bbc:	09 f4       	brne	.+2      	; 0x1bc0 <Dio_WriteChannel+0x5e>
    1bbe:	9d c0       	rjmp	.+314    	; 0x1cfa <Dio_WriteChannel+0x198>
    1bc0:	2c 81       	ldd	r18, Y+4	; 0x04
    1bc2:	3d 81       	ldd	r19, Y+5	; 0x05
    1bc4:	24 30       	cpi	r18, 0x04	; 4
    1bc6:	31 05       	cpc	r19, r1
    1bc8:	09 f4       	brne	.+2      	; 0x1bcc <Dio_WriteChannel+0x6a>
    1bca:	c9 c0       	rjmp	.+402    	; 0x1d5e <Dio_WriteChannel+0x1fc>
    1bcc:	f9 c0       	rjmp	.+498    	; 0x1dc0 <Dio_WriteChannel+0x25e>
	{
		case Dio_PORTA:
			if (Level)
    1bce:	8b 81       	ldd	r24, Y+3	; 0x03
    1bd0:	88 23       	and	r24, r24
    1bd2:	b9 f0       	breq	.+46     	; 0x1c02 <Dio_WriteChannel+0xa0>
			{
				SET_BIT(PORTA,ChannelId%8);
    1bd4:	ab e3       	ldi	r26, 0x3B	; 59
    1bd6:	b0 e0       	ldi	r27, 0x00	; 0
    1bd8:	eb e3       	ldi	r30, 0x3B	; 59
    1bda:	f0 e0       	ldi	r31, 0x00	; 0
    1bdc:	80 81       	ld	r24, Z
    1bde:	48 2f       	mov	r20, r24
    1be0:	8a 81       	ldd	r24, Y+2	; 0x02
    1be2:	88 2f       	mov	r24, r24
    1be4:	90 e0       	ldi	r25, 0x00	; 0
    1be6:	9c 01       	movw	r18, r24
    1be8:	27 70       	andi	r18, 0x07	; 7
    1bea:	30 70       	andi	r19, 0x00	; 0
    1bec:	81 e0       	ldi	r24, 0x01	; 1
    1bee:	90 e0       	ldi	r25, 0x00	; 0
    1bf0:	02 2e       	mov	r0, r18
    1bf2:	02 c0       	rjmp	.+4      	; 0x1bf8 <Dio_WriteChannel+0x96>
    1bf4:	88 0f       	add	r24, r24
    1bf6:	99 1f       	adc	r25, r25
    1bf8:	0a 94       	dec	r0
    1bfa:	e2 f7       	brpl	.-8      	; 0x1bf4 <Dio_WriteChannel+0x92>
    1bfc:	84 2b       	or	r24, r20
    1bfe:	8c 93       	st	X, r24
    1c00:	df c0       	rjmp	.+446    	; 0x1dc0 <Dio_WriteChannel+0x25e>
			}
			else
			{
				CLR_BIT(PORTA,ChannelId%8);
    1c02:	ab e3       	ldi	r26, 0x3B	; 59
    1c04:	b0 e0       	ldi	r27, 0x00	; 0
    1c06:	eb e3       	ldi	r30, 0x3B	; 59
    1c08:	f0 e0       	ldi	r31, 0x00	; 0
    1c0a:	80 81       	ld	r24, Z
    1c0c:	48 2f       	mov	r20, r24
    1c0e:	8a 81       	ldd	r24, Y+2	; 0x02
    1c10:	88 2f       	mov	r24, r24
    1c12:	90 e0       	ldi	r25, 0x00	; 0
    1c14:	9c 01       	movw	r18, r24
    1c16:	27 70       	andi	r18, 0x07	; 7
    1c18:	30 70       	andi	r19, 0x00	; 0
    1c1a:	81 e0       	ldi	r24, 0x01	; 1
    1c1c:	90 e0       	ldi	r25, 0x00	; 0
    1c1e:	02 2e       	mov	r0, r18
    1c20:	02 c0       	rjmp	.+4      	; 0x1c26 <Dio_WriteChannel+0xc4>
    1c22:	88 0f       	add	r24, r24
    1c24:	99 1f       	adc	r25, r25
    1c26:	0a 94       	dec	r0
    1c28:	e2 f7       	brpl	.-8      	; 0x1c22 <Dio_WriteChannel+0xc0>
    1c2a:	80 95       	com	r24
    1c2c:	84 23       	and	r24, r20
    1c2e:	8c 93       	st	X, r24
    1c30:	c7 c0       	rjmp	.+398    	; 0x1dc0 <Dio_WriteChannel+0x25e>
			}
		break;
		case Dio_PORTB :
			if (Level)
    1c32:	8b 81       	ldd	r24, Y+3	; 0x03
    1c34:	88 23       	and	r24, r24
    1c36:	b9 f0       	breq	.+46     	; 0x1c66 <Dio_WriteChannel+0x104>
			{
				SET_BIT(PORTB,ChannelId%8);
    1c38:	a8 e3       	ldi	r26, 0x38	; 56
    1c3a:	b0 e0       	ldi	r27, 0x00	; 0
    1c3c:	e8 e3       	ldi	r30, 0x38	; 56
    1c3e:	f0 e0       	ldi	r31, 0x00	; 0
    1c40:	80 81       	ld	r24, Z
    1c42:	48 2f       	mov	r20, r24
    1c44:	8a 81       	ldd	r24, Y+2	; 0x02
    1c46:	88 2f       	mov	r24, r24
    1c48:	90 e0       	ldi	r25, 0x00	; 0
    1c4a:	9c 01       	movw	r18, r24
    1c4c:	27 70       	andi	r18, 0x07	; 7
    1c4e:	30 70       	andi	r19, 0x00	; 0
    1c50:	81 e0       	ldi	r24, 0x01	; 1
    1c52:	90 e0       	ldi	r25, 0x00	; 0
    1c54:	02 2e       	mov	r0, r18
    1c56:	02 c0       	rjmp	.+4      	; 0x1c5c <Dio_WriteChannel+0xfa>
    1c58:	88 0f       	add	r24, r24
    1c5a:	99 1f       	adc	r25, r25
    1c5c:	0a 94       	dec	r0
    1c5e:	e2 f7       	brpl	.-8      	; 0x1c58 <Dio_WriteChannel+0xf6>
    1c60:	84 2b       	or	r24, r20
    1c62:	8c 93       	st	X, r24
    1c64:	ad c0       	rjmp	.+346    	; 0x1dc0 <Dio_WriteChannel+0x25e>
			}
			else
			{
				CLR_BIT(PORTB,ChannelId%8);
    1c66:	a8 e3       	ldi	r26, 0x38	; 56
    1c68:	b0 e0       	ldi	r27, 0x00	; 0
    1c6a:	e8 e3       	ldi	r30, 0x38	; 56
    1c6c:	f0 e0       	ldi	r31, 0x00	; 0
    1c6e:	80 81       	ld	r24, Z
    1c70:	48 2f       	mov	r20, r24
    1c72:	8a 81       	ldd	r24, Y+2	; 0x02
    1c74:	88 2f       	mov	r24, r24
    1c76:	90 e0       	ldi	r25, 0x00	; 0
    1c78:	9c 01       	movw	r18, r24
    1c7a:	27 70       	andi	r18, 0x07	; 7
    1c7c:	30 70       	andi	r19, 0x00	; 0
    1c7e:	81 e0       	ldi	r24, 0x01	; 1
    1c80:	90 e0       	ldi	r25, 0x00	; 0
    1c82:	02 2e       	mov	r0, r18
    1c84:	02 c0       	rjmp	.+4      	; 0x1c8a <Dio_WriteChannel+0x128>
    1c86:	88 0f       	add	r24, r24
    1c88:	99 1f       	adc	r25, r25
    1c8a:	0a 94       	dec	r0
    1c8c:	e2 f7       	brpl	.-8      	; 0x1c86 <Dio_WriteChannel+0x124>
    1c8e:	80 95       	com	r24
    1c90:	84 23       	and	r24, r20
    1c92:	8c 93       	st	X, r24
    1c94:	95 c0       	rjmp	.+298    	; 0x1dc0 <Dio_WriteChannel+0x25e>
			}
		break;
		case Dio_PORTC:
			if (Level)
    1c96:	8b 81       	ldd	r24, Y+3	; 0x03
    1c98:	88 23       	and	r24, r24
    1c9a:	b9 f0       	breq	.+46     	; 0x1cca <Dio_WriteChannel+0x168>
			{
				SET_BIT(PORTC,ChannelId%8);
    1c9c:	a5 e3       	ldi	r26, 0x35	; 53
    1c9e:	b0 e0       	ldi	r27, 0x00	; 0
    1ca0:	e5 e3       	ldi	r30, 0x35	; 53
    1ca2:	f0 e0       	ldi	r31, 0x00	; 0
    1ca4:	80 81       	ld	r24, Z
    1ca6:	48 2f       	mov	r20, r24
    1ca8:	8a 81       	ldd	r24, Y+2	; 0x02
    1caa:	88 2f       	mov	r24, r24
    1cac:	90 e0       	ldi	r25, 0x00	; 0
    1cae:	9c 01       	movw	r18, r24
    1cb0:	27 70       	andi	r18, 0x07	; 7
    1cb2:	30 70       	andi	r19, 0x00	; 0
    1cb4:	81 e0       	ldi	r24, 0x01	; 1
    1cb6:	90 e0       	ldi	r25, 0x00	; 0
    1cb8:	02 2e       	mov	r0, r18
    1cba:	02 c0       	rjmp	.+4      	; 0x1cc0 <Dio_WriteChannel+0x15e>
    1cbc:	88 0f       	add	r24, r24
    1cbe:	99 1f       	adc	r25, r25
    1cc0:	0a 94       	dec	r0
    1cc2:	e2 f7       	brpl	.-8      	; 0x1cbc <Dio_WriteChannel+0x15a>
    1cc4:	84 2b       	or	r24, r20
    1cc6:	8c 93       	st	X, r24
    1cc8:	7b c0       	rjmp	.+246    	; 0x1dc0 <Dio_WriteChannel+0x25e>
			}
			else
			{
				CLR_BIT(PORTC,ChannelId%8);
    1cca:	a5 e3       	ldi	r26, 0x35	; 53
    1ccc:	b0 e0       	ldi	r27, 0x00	; 0
    1cce:	e5 e3       	ldi	r30, 0x35	; 53
    1cd0:	f0 e0       	ldi	r31, 0x00	; 0
    1cd2:	80 81       	ld	r24, Z
    1cd4:	48 2f       	mov	r20, r24
    1cd6:	8a 81       	ldd	r24, Y+2	; 0x02
    1cd8:	88 2f       	mov	r24, r24
    1cda:	90 e0       	ldi	r25, 0x00	; 0
    1cdc:	9c 01       	movw	r18, r24
    1cde:	27 70       	andi	r18, 0x07	; 7
    1ce0:	30 70       	andi	r19, 0x00	; 0
    1ce2:	81 e0       	ldi	r24, 0x01	; 1
    1ce4:	90 e0       	ldi	r25, 0x00	; 0
    1ce6:	02 2e       	mov	r0, r18
    1ce8:	02 c0       	rjmp	.+4      	; 0x1cee <Dio_WriteChannel+0x18c>
    1cea:	88 0f       	add	r24, r24
    1cec:	99 1f       	adc	r25, r25
    1cee:	0a 94       	dec	r0
    1cf0:	e2 f7       	brpl	.-8      	; 0x1cea <Dio_WriteChannel+0x188>
    1cf2:	80 95       	com	r24
    1cf4:	84 23       	and	r24, r20
    1cf6:	8c 93       	st	X, r24
    1cf8:	63 c0       	rjmp	.+198    	; 0x1dc0 <Dio_WriteChannel+0x25e>
			}
		break;
		case Dio_PORTD:
			if (Level)
    1cfa:	8b 81       	ldd	r24, Y+3	; 0x03
    1cfc:	88 23       	and	r24, r24
    1cfe:	b9 f0       	breq	.+46     	; 0x1d2e <Dio_WriteChannel+0x1cc>
			{
				SET_BIT(PORTD,ChannelId%8);
    1d00:	a2 e3       	ldi	r26, 0x32	; 50
    1d02:	b0 e0       	ldi	r27, 0x00	; 0
    1d04:	e2 e3       	ldi	r30, 0x32	; 50
    1d06:	f0 e0       	ldi	r31, 0x00	; 0
    1d08:	80 81       	ld	r24, Z
    1d0a:	48 2f       	mov	r20, r24
    1d0c:	8a 81       	ldd	r24, Y+2	; 0x02
    1d0e:	88 2f       	mov	r24, r24
    1d10:	90 e0       	ldi	r25, 0x00	; 0
    1d12:	9c 01       	movw	r18, r24
    1d14:	27 70       	andi	r18, 0x07	; 7
    1d16:	30 70       	andi	r19, 0x00	; 0
    1d18:	81 e0       	ldi	r24, 0x01	; 1
    1d1a:	90 e0       	ldi	r25, 0x00	; 0
    1d1c:	02 2e       	mov	r0, r18
    1d1e:	02 c0       	rjmp	.+4      	; 0x1d24 <Dio_WriteChannel+0x1c2>
    1d20:	88 0f       	add	r24, r24
    1d22:	99 1f       	adc	r25, r25
    1d24:	0a 94       	dec	r0
    1d26:	e2 f7       	brpl	.-8      	; 0x1d20 <Dio_WriteChannel+0x1be>
    1d28:	84 2b       	or	r24, r20
    1d2a:	8c 93       	st	X, r24
    1d2c:	49 c0       	rjmp	.+146    	; 0x1dc0 <Dio_WriteChannel+0x25e>
			}
			else
			{
				CLR_BIT(PORTD,ChannelId%8);
    1d2e:	a2 e3       	ldi	r26, 0x32	; 50
    1d30:	b0 e0       	ldi	r27, 0x00	; 0
    1d32:	e2 e3       	ldi	r30, 0x32	; 50
    1d34:	f0 e0       	ldi	r31, 0x00	; 0
    1d36:	80 81       	ld	r24, Z
    1d38:	48 2f       	mov	r20, r24
    1d3a:	8a 81       	ldd	r24, Y+2	; 0x02
    1d3c:	88 2f       	mov	r24, r24
    1d3e:	90 e0       	ldi	r25, 0x00	; 0
    1d40:	9c 01       	movw	r18, r24
    1d42:	27 70       	andi	r18, 0x07	; 7
    1d44:	30 70       	andi	r19, 0x00	; 0
    1d46:	81 e0       	ldi	r24, 0x01	; 1
    1d48:	90 e0       	ldi	r25, 0x00	; 0
    1d4a:	02 2e       	mov	r0, r18
    1d4c:	02 c0       	rjmp	.+4      	; 0x1d52 <Dio_WriteChannel+0x1f0>
    1d4e:	88 0f       	add	r24, r24
    1d50:	99 1f       	adc	r25, r25
    1d52:	0a 94       	dec	r0
    1d54:	e2 f7       	brpl	.-8      	; 0x1d4e <Dio_WriteChannel+0x1ec>
    1d56:	80 95       	com	r24
    1d58:	84 23       	and	r24, r20
    1d5a:	8c 93       	st	X, r24
    1d5c:	31 c0       	rjmp	.+98     	; 0x1dc0 <Dio_WriteChannel+0x25e>
			}
			break;
		case Dio_PORTE:
			if (Level)
    1d5e:	8b 81       	ldd	r24, Y+3	; 0x03
    1d60:	88 23       	and	r24, r24
    1d62:	b9 f0       	breq	.+46     	; 0x1d92 <Dio_WriteChannel+0x230>
			{
				SET_BIT(PORTE,ChannelId%8);
    1d64:	a3 e2       	ldi	r26, 0x23	; 35
    1d66:	b0 e0       	ldi	r27, 0x00	; 0
    1d68:	e3 e2       	ldi	r30, 0x23	; 35
    1d6a:	f0 e0       	ldi	r31, 0x00	; 0
    1d6c:	80 81       	ld	r24, Z
    1d6e:	48 2f       	mov	r20, r24
    1d70:	8a 81       	ldd	r24, Y+2	; 0x02
    1d72:	88 2f       	mov	r24, r24
    1d74:	90 e0       	ldi	r25, 0x00	; 0
    1d76:	9c 01       	movw	r18, r24
    1d78:	27 70       	andi	r18, 0x07	; 7
    1d7a:	30 70       	andi	r19, 0x00	; 0
    1d7c:	81 e0       	ldi	r24, 0x01	; 1
    1d7e:	90 e0       	ldi	r25, 0x00	; 0
    1d80:	02 2e       	mov	r0, r18
    1d82:	02 c0       	rjmp	.+4      	; 0x1d88 <Dio_WriteChannel+0x226>
    1d84:	88 0f       	add	r24, r24
    1d86:	99 1f       	adc	r25, r25
    1d88:	0a 94       	dec	r0
    1d8a:	e2 f7       	brpl	.-8      	; 0x1d84 <Dio_WriteChannel+0x222>
    1d8c:	84 2b       	or	r24, r20
    1d8e:	8c 93       	st	X, r24
    1d90:	17 c0       	rjmp	.+46     	; 0x1dc0 <Dio_WriteChannel+0x25e>
			}
			else
			{
				CLR_BIT(PORTE,ChannelId%8);
    1d92:	a3 e2       	ldi	r26, 0x23	; 35
    1d94:	b0 e0       	ldi	r27, 0x00	; 0
    1d96:	e3 e2       	ldi	r30, 0x23	; 35
    1d98:	f0 e0       	ldi	r31, 0x00	; 0
    1d9a:	80 81       	ld	r24, Z
    1d9c:	48 2f       	mov	r20, r24
    1d9e:	8a 81       	ldd	r24, Y+2	; 0x02
    1da0:	88 2f       	mov	r24, r24
    1da2:	90 e0       	ldi	r25, 0x00	; 0
    1da4:	9c 01       	movw	r18, r24
    1da6:	27 70       	andi	r18, 0x07	; 7
    1da8:	30 70       	andi	r19, 0x00	; 0
    1daa:	81 e0       	ldi	r24, 0x01	; 1
    1dac:	90 e0       	ldi	r25, 0x00	; 0
    1dae:	02 2e       	mov	r0, r18
    1db0:	02 c0       	rjmp	.+4      	; 0x1db6 <Dio_WriteChannel+0x254>
    1db2:	88 0f       	add	r24, r24
    1db4:	99 1f       	adc	r25, r25
    1db6:	0a 94       	dec	r0
    1db8:	e2 f7       	brpl	.-8      	; 0x1db2 <Dio_WriteChannel+0x250>
    1dba:	80 95       	com	r24
    1dbc:	84 23       	and	r24, r20
    1dbe:	8c 93       	st	X, r24
			}
			break;
		}
	

}
    1dc0:	0f 90       	pop	r0
    1dc2:	0f 90       	pop	r0
    1dc4:	0f 90       	pop	r0
    1dc6:	0f 90       	pop	r0
    1dc8:	0f 90       	pop	r0
    1dca:	cf 91       	pop	r28
    1dcc:	df 91       	pop	r29
    1dce:	08 95       	ret

00001dd0 <Dio_FlipChannel>:
void Dio_FlipChannel(Dio_ChannelType ChannelId)
{
    1dd0:	df 93       	push	r29
    1dd2:	cf 93       	push	r28
    1dd4:	00 d0       	rcall	.+0      	; 0x1dd6 <Dio_FlipChannel+0x6>
    1dd6:	00 d0       	rcall	.+0      	; 0x1dd8 <Dio_FlipChannel+0x8>
    1dd8:	0f 92       	push	r0
    1dda:	cd b7       	in	r28, 0x3d	; 61
    1ddc:	de b7       	in	r29, 0x3e	; 62
    1dde:	8b 83       	std	Y+3, r24	; 0x03
	Dio_PortType port=ChannelId/8;
    1de0:	8b 81       	ldd	r24, Y+3	; 0x03
    1de2:	86 95       	lsr	r24
    1de4:	86 95       	lsr	r24
    1de6:	86 95       	lsr	r24
    1de8:	8a 83       	std	Y+2, r24	; 0x02
	u8 pin=ChannelId%8;
    1dea:	8b 81       	ldd	r24, Y+3	; 0x03
    1dec:	87 70       	andi	r24, 0x07	; 7
    1dee:	89 83       	std	Y+1, r24	; 0x01
	switch(port)
    1df0:	8a 81       	ldd	r24, Y+2	; 0x02
    1df2:	28 2f       	mov	r18, r24
    1df4:	30 e0       	ldi	r19, 0x00	; 0
    1df6:	3d 83       	std	Y+5, r19	; 0x05
    1df8:	2c 83       	std	Y+4, r18	; 0x04
    1dfa:	8c 81       	ldd	r24, Y+4	; 0x04
    1dfc:	9d 81       	ldd	r25, Y+5	; 0x05
    1dfe:	82 30       	cpi	r24, 0x02	; 2
    1e00:	91 05       	cpc	r25, r1
    1e02:	09 f4       	brne	.+2      	; 0x1e06 <Dio_FlipChannel+0x36>
    1e04:	44 c0       	rjmp	.+136    	; 0x1e8e <Dio_FlipChannel+0xbe>
    1e06:	2c 81       	ldd	r18, Y+4	; 0x04
    1e08:	3d 81       	ldd	r19, Y+5	; 0x05
    1e0a:	23 30       	cpi	r18, 0x03	; 3
    1e0c:	31 05       	cpc	r19, r1
    1e0e:	54 f4       	brge	.+20     	; 0x1e24 <Dio_FlipChannel+0x54>
    1e10:	8c 81       	ldd	r24, Y+4	; 0x04
    1e12:	9d 81       	ldd	r25, Y+5	; 0x05
    1e14:	00 97       	sbiw	r24, 0x00	; 0
    1e16:	99 f0       	breq	.+38     	; 0x1e3e <Dio_FlipChannel+0x6e>
    1e18:	2c 81       	ldd	r18, Y+4	; 0x04
    1e1a:	3d 81       	ldd	r19, Y+5	; 0x05
    1e1c:	21 30       	cpi	r18, 0x01	; 1
    1e1e:	31 05       	cpc	r19, r1
    1e20:	11 f1       	breq	.+68     	; 0x1e66 <Dio_FlipChannel+0x96>
    1e22:	70 c0       	rjmp	.+224    	; 0x1f04 <Dio_FlipChannel+0x134>
    1e24:	8c 81       	ldd	r24, Y+4	; 0x04
    1e26:	9d 81       	ldd	r25, Y+5	; 0x05
    1e28:	83 30       	cpi	r24, 0x03	; 3
    1e2a:	91 05       	cpc	r25, r1
    1e2c:	09 f4       	brne	.+2      	; 0x1e30 <Dio_FlipChannel+0x60>
    1e2e:	43 c0       	rjmp	.+134    	; 0x1eb6 <Dio_FlipChannel+0xe6>
    1e30:	2c 81       	ldd	r18, Y+4	; 0x04
    1e32:	3d 81       	ldd	r19, Y+5	; 0x05
    1e34:	24 30       	cpi	r18, 0x04	; 4
    1e36:	31 05       	cpc	r19, r1
    1e38:	09 f4       	brne	.+2      	; 0x1e3c <Dio_FlipChannel+0x6c>
    1e3a:	51 c0       	rjmp	.+162    	; 0x1ede <Dio_FlipChannel+0x10e>
    1e3c:	63 c0       	rjmp	.+198    	; 0x1f04 <Dio_FlipChannel+0x134>
	{
		case Dio_PORTA:
		TOG_BIT(PORTA,pin);
    1e3e:	ab e3       	ldi	r26, 0x3B	; 59
    1e40:	b0 e0       	ldi	r27, 0x00	; 0
    1e42:	eb e3       	ldi	r30, 0x3B	; 59
    1e44:	f0 e0       	ldi	r31, 0x00	; 0
    1e46:	80 81       	ld	r24, Z
    1e48:	48 2f       	mov	r20, r24
    1e4a:	89 81       	ldd	r24, Y+1	; 0x01
    1e4c:	28 2f       	mov	r18, r24
    1e4e:	30 e0       	ldi	r19, 0x00	; 0
    1e50:	81 e0       	ldi	r24, 0x01	; 1
    1e52:	90 e0       	ldi	r25, 0x00	; 0
    1e54:	02 2e       	mov	r0, r18
    1e56:	02 c0       	rjmp	.+4      	; 0x1e5c <Dio_FlipChannel+0x8c>
    1e58:	88 0f       	add	r24, r24
    1e5a:	99 1f       	adc	r25, r25
    1e5c:	0a 94       	dec	r0
    1e5e:	e2 f7       	brpl	.-8      	; 0x1e58 <Dio_FlipChannel+0x88>
    1e60:	84 27       	eor	r24, r20
    1e62:	8c 93       	st	X, r24
    1e64:	4f c0       	rjmp	.+158    	; 0x1f04 <Dio_FlipChannel+0x134>
		break;
		case Dio_PORTB :
		TOG_BIT(PORTB,pin);
    1e66:	a8 e3       	ldi	r26, 0x38	; 56
    1e68:	b0 e0       	ldi	r27, 0x00	; 0
    1e6a:	e8 e3       	ldi	r30, 0x38	; 56
    1e6c:	f0 e0       	ldi	r31, 0x00	; 0
    1e6e:	80 81       	ld	r24, Z
    1e70:	48 2f       	mov	r20, r24
    1e72:	89 81       	ldd	r24, Y+1	; 0x01
    1e74:	28 2f       	mov	r18, r24
    1e76:	30 e0       	ldi	r19, 0x00	; 0
    1e78:	81 e0       	ldi	r24, 0x01	; 1
    1e7a:	90 e0       	ldi	r25, 0x00	; 0
    1e7c:	02 2e       	mov	r0, r18
    1e7e:	02 c0       	rjmp	.+4      	; 0x1e84 <Dio_FlipChannel+0xb4>
    1e80:	88 0f       	add	r24, r24
    1e82:	99 1f       	adc	r25, r25
    1e84:	0a 94       	dec	r0
    1e86:	e2 f7       	brpl	.-8      	; 0x1e80 <Dio_FlipChannel+0xb0>
    1e88:	84 27       	eor	r24, r20
    1e8a:	8c 93       	st	X, r24
    1e8c:	3b c0       	rjmp	.+118    	; 0x1f04 <Dio_FlipChannel+0x134>
		break;
		case Dio_PORTC:
		TOG_BIT(PORTC,pin);
    1e8e:	a5 e3       	ldi	r26, 0x35	; 53
    1e90:	b0 e0       	ldi	r27, 0x00	; 0
    1e92:	e5 e3       	ldi	r30, 0x35	; 53
    1e94:	f0 e0       	ldi	r31, 0x00	; 0
    1e96:	80 81       	ld	r24, Z
    1e98:	48 2f       	mov	r20, r24
    1e9a:	89 81       	ldd	r24, Y+1	; 0x01
    1e9c:	28 2f       	mov	r18, r24
    1e9e:	30 e0       	ldi	r19, 0x00	; 0
    1ea0:	81 e0       	ldi	r24, 0x01	; 1
    1ea2:	90 e0       	ldi	r25, 0x00	; 0
    1ea4:	02 2e       	mov	r0, r18
    1ea6:	02 c0       	rjmp	.+4      	; 0x1eac <Dio_FlipChannel+0xdc>
    1ea8:	88 0f       	add	r24, r24
    1eaa:	99 1f       	adc	r25, r25
    1eac:	0a 94       	dec	r0
    1eae:	e2 f7       	brpl	.-8      	; 0x1ea8 <Dio_FlipChannel+0xd8>
    1eb0:	84 27       	eor	r24, r20
    1eb2:	8c 93       	st	X, r24
    1eb4:	27 c0       	rjmp	.+78     	; 0x1f04 <Dio_FlipChannel+0x134>
		break;
		case Dio_PORTD:
		TOG_BIT(PORTD,pin);
    1eb6:	a2 e3       	ldi	r26, 0x32	; 50
    1eb8:	b0 e0       	ldi	r27, 0x00	; 0
    1eba:	e2 e3       	ldi	r30, 0x32	; 50
    1ebc:	f0 e0       	ldi	r31, 0x00	; 0
    1ebe:	80 81       	ld	r24, Z
    1ec0:	48 2f       	mov	r20, r24
    1ec2:	89 81       	ldd	r24, Y+1	; 0x01
    1ec4:	28 2f       	mov	r18, r24
    1ec6:	30 e0       	ldi	r19, 0x00	; 0
    1ec8:	81 e0       	ldi	r24, 0x01	; 1
    1eca:	90 e0       	ldi	r25, 0x00	; 0
    1ecc:	02 2e       	mov	r0, r18
    1ece:	02 c0       	rjmp	.+4      	; 0x1ed4 <Dio_FlipChannel+0x104>
    1ed0:	88 0f       	add	r24, r24
    1ed2:	99 1f       	adc	r25, r25
    1ed4:	0a 94       	dec	r0
    1ed6:	e2 f7       	brpl	.-8      	; 0x1ed0 <Dio_FlipChannel+0x100>
    1ed8:	84 27       	eor	r24, r20
    1eda:	8c 93       	st	X, r24
    1edc:	13 c0       	rjmp	.+38     	; 0x1f04 <Dio_FlipChannel+0x134>
		break;
		case Dio_PORTE:
		TOG_BIT(PORTE,pin);
    1ede:	a3 e2       	ldi	r26, 0x23	; 35
    1ee0:	b0 e0       	ldi	r27, 0x00	; 0
    1ee2:	e3 e2       	ldi	r30, 0x23	; 35
    1ee4:	f0 e0       	ldi	r31, 0x00	; 0
    1ee6:	80 81       	ld	r24, Z
    1ee8:	48 2f       	mov	r20, r24
    1eea:	89 81       	ldd	r24, Y+1	; 0x01
    1eec:	28 2f       	mov	r18, r24
    1eee:	30 e0       	ldi	r19, 0x00	; 0
    1ef0:	81 e0       	ldi	r24, 0x01	; 1
    1ef2:	90 e0       	ldi	r25, 0x00	; 0
    1ef4:	02 2e       	mov	r0, r18
    1ef6:	02 c0       	rjmp	.+4      	; 0x1efc <Dio_FlipChannel+0x12c>
    1ef8:	88 0f       	add	r24, r24
    1efa:	99 1f       	adc	r25, r25
    1efc:	0a 94       	dec	r0
    1efe:	e2 f7       	brpl	.-8      	; 0x1ef8 <Dio_FlipChannel+0x128>
    1f00:	84 27       	eor	r24, r20
    1f02:	8c 93       	st	X, r24
		break;
	}
}
    1f04:	0f 90       	pop	r0
    1f06:	0f 90       	pop	r0
    1f08:	0f 90       	pop	r0
    1f0a:	0f 90       	pop	r0
    1f0c:	0f 90       	pop	r0
    1f0e:	cf 91       	pop	r28
    1f10:	df 91       	pop	r29
    1f12:	08 95       	ret

00001f14 <Dio_ReadChannel>:

Dio_LevelType Dio_ReadChannel(Dio_ChannelType ChannelId)
{
    1f14:	df 93       	push	r29
    1f16:	cf 93       	push	r28
    1f18:	00 d0       	rcall	.+0      	; 0x1f1a <Dio_ReadChannel+0x6>
    1f1a:	00 d0       	rcall	.+0      	; 0x1f1c <Dio_ReadChannel+0x8>
    1f1c:	00 d0       	rcall	.+0      	; 0x1f1e <Dio_ReadChannel+0xa>
    1f1e:	cd b7       	in	r28, 0x3d	; 61
    1f20:	de b7       	in	r29, 0x3e	; 62
    1f22:	8c 83       	std	Y+4, r24	; 0x04
	Dio_PortType port=ChannelId/8;
    1f24:	8c 81       	ldd	r24, Y+4	; 0x04
    1f26:	86 95       	lsr	r24
    1f28:	86 95       	lsr	r24
    1f2a:	86 95       	lsr	r24
    1f2c:	8b 83       	std	Y+3, r24	; 0x03
	u8 pin=ChannelId%8;
    1f2e:	8c 81       	ldd	r24, Y+4	; 0x04
    1f30:	87 70       	andi	r24, 0x07	; 7
    1f32:	8a 83       	std	Y+2, r24	; 0x02
	Dio_LevelType Level=STD_LOW;
    1f34:	19 82       	std	Y+1, r1	; 0x01
	switch(port)
    1f36:	8b 81       	ldd	r24, Y+3	; 0x03
    1f38:	28 2f       	mov	r18, r24
    1f3a:	30 e0       	ldi	r19, 0x00	; 0
    1f3c:	3e 83       	std	Y+6, r19	; 0x06
    1f3e:	2d 83       	std	Y+5, r18	; 0x05
    1f40:	4d 81       	ldd	r20, Y+5	; 0x05
    1f42:	5e 81       	ldd	r21, Y+6	; 0x06
    1f44:	42 30       	cpi	r20, 0x02	; 2
    1f46:	51 05       	cpc	r21, r1
    1f48:	09 f4       	brne	.+2      	; 0x1f4c <Dio_ReadChannel+0x38>
    1f4a:	41 c0       	rjmp	.+130    	; 0x1fce <Dio_ReadChannel+0xba>
    1f4c:	8d 81       	ldd	r24, Y+5	; 0x05
    1f4e:	9e 81       	ldd	r25, Y+6	; 0x06
    1f50:	83 30       	cpi	r24, 0x03	; 3
    1f52:	91 05       	cpc	r25, r1
    1f54:	5c f4       	brge	.+22     	; 0x1f6c <Dio_ReadChannel+0x58>
    1f56:	2d 81       	ldd	r18, Y+5	; 0x05
    1f58:	3e 81       	ldd	r19, Y+6	; 0x06
    1f5a:	21 15       	cp	r18, r1
    1f5c:	31 05       	cpc	r19, r1
    1f5e:	99 f0       	breq	.+38     	; 0x1f86 <Dio_ReadChannel+0x72>
    1f60:	4d 81       	ldd	r20, Y+5	; 0x05
    1f62:	5e 81       	ldd	r21, Y+6	; 0x06
    1f64:	41 30       	cpi	r20, 0x01	; 1
    1f66:	51 05       	cpc	r21, r1
    1f68:	01 f1       	breq	.+64     	; 0x1faa <Dio_ReadChannel+0x96>
    1f6a:	66 c0       	rjmp	.+204    	; 0x2038 <Dio_ReadChannel+0x124>
    1f6c:	8d 81       	ldd	r24, Y+5	; 0x05
    1f6e:	9e 81       	ldd	r25, Y+6	; 0x06
    1f70:	83 30       	cpi	r24, 0x03	; 3
    1f72:	91 05       	cpc	r25, r1
    1f74:	09 f4       	brne	.+2      	; 0x1f78 <Dio_ReadChannel+0x64>
    1f76:	3d c0       	rjmp	.+122    	; 0x1ff2 <Dio_ReadChannel+0xde>
    1f78:	2d 81       	ldd	r18, Y+5	; 0x05
    1f7a:	3e 81       	ldd	r19, Y+6	; 0x06
    1f7c:	24 30       	cpi	r18, 0x04	; 4
    1f7e:	31 05       	cpc	r19, r1
    1f80:	09 f4       	brne	.+2      	; 0x1f84 <Dio_ReadChannel+0x70>
    1f82:	49 c0       	rjmp	.+146    	; 0x2016 <Dio_ReadChannel+0x102>
    1f84:	59 c0       	rjmp	.+178    	; 0x2038 <Dio_ReadChannel+0x124>
	{
		case Dio_PORTA:
			Level=GET_BIT(PINA,pin);
    1f86:	e9 e3       	ldi	r30, 0x39	; 57
    1f88:	f0 e0       	ldi	r31, 0x00	; 0
    1f8a:	80 81       	ld	r24, Z
    1f8c:	28 2f       	mov	r18, r24
    1f8e:	30 e0       	ldi	r19, 0x00	; 0
    1f90:	8a 81       	ldd	r24, Y+2	; 0x02
    1f92:	88 2f       	mov	r24, r24
    1f94:	90 e0       	ldi	r25, 0x00	; 0
    1f96:	a9 01       	movw	r20, r18
    1f98:	02 c0       	rjmp	.+4      	; 0x1f9e <Dio_ReadChannel+0x8a>
    1f9a:	55 95       	asr	r21
    1f9c:	47 95       	ror	r20
    1f9e:	8a 95       	dec	r24
    1fa0:	e2 f7       	brpl	.-8      	; 0x1f9a <Dio_ReadChannel+0x86>
    1fa2:	ca 01       	movw	r24, r20
    1fa4:	81 70       	andi	r24, 0x01	; 1
    1fa6:	89 83       	std	Y+1, r24	; 0x01
    1fa8:	47 c0       	rjmp	.+142    	; 0x2038 <Dio_ReadChannel+0x124>
		break;
		case Dio_PORTB :
			Level=GET_BIT(PINB,pin);
    1faa:	e6 e3       	ldi	r30, 0x36	; 54
    1fac:	f0 e0       	ldi	r31, 0x00	; 0
    1fae:	80 81       	ld	r24, Z
    1fb0:	28 2f       	mov	r18, r24
    1fb2:	30 e0       	ldi	r19, 0x00	; 0
    1fb4:	8a 81       	ldd	r24, Y+2	; 0x02
    1fb6:	88 2f       	mov	r24, r24
    1fb8:	90 e0       	ldi	r25, 0x00	; 0
    1fba:	a9 01       	movw	r20, r18
    1fbc:	02 c0       	rjmp	.+4      	; 0x1fc2 <Dio_ReadChannel+0xae>
    1fbe:	55 95       	asr	r21
    1fc0:	47 95       	ror	r20
    1fc2:	8a 95       	dec	r24
    1fc4:	e2 f7       	brpl	.-8      	; 0x1fbe <Dio_ReadChannel+0xaa>
    1fc6:	ca 01       	movw	r24, r20
    1fc8:	81 70       	andi	r24, 0x01	; 1
    1fca:	89 83       	std	Y+1, r24	; 0x01
    1fcc:	35 c0       	rjmp	.+106    	; 0x2038 <Dio_ReadChannel+0x124>
	
		break;
		case Dio_PORTC:
			Level=GET_BIT(PINC,pin);
    1fce:	e3 e3       	ldi	r30, 0x33	; 51
    1fd0:	f0 e0       	ldi	r31, 0x00	; 0
    1fd2:	80 81       	ld	r24, Z
    1fd4:	28 2f       	mov	r18, r24
    1fd6:	30 e0       	ldi	r19, 0x00	; 0
    1fd8:	8a 81       	ldd	r24, Y+2	; 0x02
    1fda:	88 2f       	mov	r24, r24
    1fdc:	90 e0       	ldi	r25, 0x00	; 0
    1fde:	a9 01       	movw	r20, r18
    1fe0:	02 c0       	rjmp	.+4      	; 0x1fe6 <Dio_ReadChannel+0xd2>
    1fe2:	55 95       	asr	r21
    1fe4:	47 95       	ror	r20
    1fe6:	8a 95       	dec	r24
    1fe8:	e2 f7       	brpl	.-8      	; 0x1fe2 <Dio_ReadChannel+0xce>
    1fea:	ca 01       	movw	r24, r20
    1fec:	81 70       	andi	r24, 0x01	; 1
    1fee:	89 83       	std	Y+1, r24	; 0x01
    1ff0:	23 c0       	rjmp	.+70     	; 0x2038 <Dio_ReadChannel+0x124>
		break;
		case Dio_PORTD:
			Level=GET_BIT(PIND,pin);
    1ff2:	e0 e3       	ldi	r30, 0x30	; 48
    1ff4:	f0 e0       	ldi	r31, 0x00	; 0
    1ff6:	80 81       	ld	r24, Z
    1ff8:	28 2f       	mov	r18, r24
    1ffa:	30 e0       	ldi	r19, 0x00	; 0
    1ffc:	8a 81       	ldd	r24, Y+2	; 0x02
    1ffe:	88 2f       	mov	r24, r24
    2000:	90 e0       	ldi	r25, 0x00	; 0
    2002:	a9 01       	movw	r20, r18
    2004:	02 c0       	rjmp	.+4      	; 0x200a <Dio_ReadChannel+0xf6>
    2006:	55 95       	asr	r21
    2008:	47 95       	ror	r20
    200a:	8a 95       	dec	r24
    200c:	e2 f7       	brpl	.-8      	; 0x2006 <Dio_ReadChannel+0xf2>
    200e:	ca 01       	movw	r24, r20
    2010:	81 70       	andi	r24, 0x01	; 1
    2012:	89 83       	std	Y+1, r24	; 0x01
    2014:	11 c0       	rjmp	.+34     	; 0x2038 <Dio_ReadChannel+0x124>
		break;
		case Dio_PORTE:
			Level=GET_BIT(PINE,pin);
    2016:	e1 e2       	ldi	r30, 0x21	; 33
    2018:	f0 e0       	ldi	r31, 0x00	; 0
    201a:	80 81       	ld	r24, Z
    201c:	28 2f       	mov	r18, r24
    201e:	30 e0       	ldi	r19, 0x00	; 0
    2020:	8a 81       	ldd	r24, Y+2	; 0x02
    2022:	88 2f       	mov	r24, r24
    2024:	90 e0       	ldi	r25, 0x00	; 0
    2026:	a9 01       	movw	r20, r18
    2028:	02 c0       	rjmp	.+4      	; 0x202e <Dio_ReadChannel+0x11a>
    202a:	55 95       	asr	r21
    202c:	47 95       	ror	r20
    202e:	8a 95       	dec	r24
    2030:	e2 f7       	brpl	.-8      	; 0x202a <Dio_ReadChannel+0x116>
    2032:	ca 01       	movw	r24, r20
    2034:	81 70       	andi	r24, 0x01	; 1
    2036:	89 83       	std	Y+1, r24	; 0x01
		break;
	}
	return Level;
    2038:	89 81       	ldd	r24, Y+1	; 0x01
}
    203a:	26 96       	adiw	r28, 0x06	; 6
    203c:	0f b6       	in	r0, 0x3f	; 63
    203e:	f8 94       	cli
    2040:	de bf       	out	0x3e, r29	; 62
    2042:	0f be       	out	0x3f, r0	; 63
    2044:	cd bf       	out	0x3d, r28	; 61
    2046:	cf 91       	pop	r28
    2048:	df 91       	pop	r29
    204a:	08 95       	ret

0000204c <MOTOR_Forward>:




void MOTOR_Forward (void)
{
    204c:	df 93       	push	r29
    204e:	cf 93       	push	r28
    2050:	cd b7       	in	r28, 0x3d	; 61
    2052:	de b7       	in	r29, 0x3e	; 62
	TMR0_SetDutyCycle(MOTOR_F_DUTY); //PWM on Timer Pin
    2054:	86 e4       	ldi	r24, 0x46	; 70
    2056:	0e 94 fb 03 	call	0x7f6	; 0x7f6 <TMR0_SetDutyCycle>
	Dio_WriteChannel(I3,STD_HIGH);
    205a:	84 e1       	ldi	r24, 0x14	; 20
    205c:	61 e0       	ldi	r22, 0x01	; 1
    205e:	0e 94 b1 0d 	call	0x1b62	; 0x1b62 <Dio_WriteChannel>
	Dio_WriteChannel(I4,STD_LOW);
    2062:	85 e1       	ldi	r24, 0x15	; 21
    2064:	60 e0       	ldi	r22, 0x00	; 0
    2066:	0e 94 b1 0d 	call	0x1b62	; 0x1b62 <Dio_WriteChannel>
}
    206a:	cf 91       	pop	r28
    206c:	df 91       	pop	r29
    206e:	08 95       	ret

00002070 <MOTOR_Backward>:

void MOTOR_Backward (void)
{
    2070:	df 93       	push	r29
    2072:	cf 93       	push	r28
    2074:	cd b7       	in	r28, 0x3d	; 61
    2076:	de b7       	in	r29, 0x3e	; 62
	TMR0_SetDutyCycle(MOTOR_B_DUTY); //PWM on Timer Pin
    2078:	86 e4       	ldi	r24, 0x46	; 70
    207a:	0e 94 fb 03 	call	0x7f6	; 0x7f6 <TMR0_SetDutyCycle>
	Dio_WriteChannel(I3,STD_LOW);
    207e:	84 e1       	ldi	r24, 0x14	; 20
    2080:	60 e0       	ldi	r22, 0x00	; 0
    2082:	0e 94 b1 0d 	call	0x1b62	; 0x1b62 <Dio_WriteChannel>
	Dio_WriteChannel(I4,STD_HIGH);
    2086:	85 e1       	ldi	r24, 0x15	; 21
    2088:	61 e0       	ldi	r22, 0x01	; 1
    208a:	0e 94 b1 0d 	call	0x1b62	; 0x1b62 <Dio_WriteChannel>
}
    208e:	cf 91       	pop	r28
    2090:	df 91       	pop	r29
    2092:	08 95       	ret

00002094 <MOTOR_Stop>:

void MOTOR_Stop (void)
{
    2094:	df 93       	push	r29
    2096:	cf 93       	push	r28
    2098:	cd b7       	in	r28, 0x3d	; 61
    209a:	de b7       	in	r29, 0x3e	; 62
	TMR0_SetDutyCycle(0); //PWM on Timer Pin
    209c:	80 e0       	ldi	r24, 0x00	; 0
    209e:	0e 94 fb 03 	call	0x7f6	; 0x7f6 <TMR0_SetDutyCycle>
	Dio_WriteChannel(I3,STD_LOW);
    20a2:	84 e1       	ldi	r24, 0x14	; 20
    20a4:	60 e0       	ldi	r22, 0x00	; 0
    20a6:	0e 94 b1 0d 	call	0x1b62	; 0x1b62 <Dio_WriteChannel>
	Dio_WriteChannel(I4,STD_LOW);
    20aa:	85 e1       	ldi	r24, 0x15	; 21
    20ac:	60 e0       	ldi	r22, 0x00	; 0
    20ae:	0e 94 b1 0d 	call	0x1b62	; 0x1b62 <Dio_WriteChannel>
}
    20b2:	cf 91       	pop	r28
    20b4:	df 91       	pop	r29
    20b6:	08 95       	ret

000020b8 <MOTOR_Forward_SetSpeed>:

void MOTOR_Forward_SetSpeed (u8 speed)
{
    20b8:	df 93       	push	r29
    20ba:	cf 93       	push	r28
    20bc:	0f 92       	push	r0
    20be:	cd b7       	in	r28, 0x3d	; 61
    20c0:	de b7       	in	r29, 0x3e	; 62
    20c2:	89 83       	std	Y+1, r24	; 0x01
		TMR0_SetDutyCycle(speed);
    20c4:	89 81       	ldd	r24, Y+1	; 0x01
    20c6:	0e 94 fb 03 	call	0x7f6	; 0x7f6 <TMR0_SetDutyCycle>
		Dio_WriteChannel(I3,STD_HIGH);
    20ca:	84 e1       	ldi	r24, 0x14	; 20
    20cc:	61 e0       	ldi	r22, 0x01	; 1
    20ce:	0e 94 b1 0d 	call	0x1b62	; 0x1b62 <Dio_WriteChannel>
		Dio_WriteChannel(I4,STD_LOW);
    20d2:	85 e1       	ldi	r24, 0x15	; 21
    20d4:	60 e0       	ldi	r22, 0x00	; 0
    20d6:	0e 94 b1 0d 	call	0x1b62	; 0x1b62 <Dio_WriteChannel>
}
    20da:	0f 90       	pop	r0
    20dc:	cf 91       	pop	r28
    20de:	df 91       	pop	r29
    20e0:	08 95       	ret

000020e2 <MOTOR_steering_Control>:
/*******************************steering motor******************************************************************/

void MOTOR_steering_Control(u8 steeringstatus)
{
    20e2:	df 93       	push	r29
    20e4:	cf 93       	push	r28
    20e6:	00 d0       	rcall	.+0      	; 0x20e8 <MOTOR_steering_Control+0x6>
    20e8:	0f 92       	push	r0
    20ea:	cd b7       	in	r28, 0x3d	; 61
    20ec:	de b7       	in	r29, 0x3e	; 62
    20ee:	89 83       	std	Y+1, r24	; 0x01
	//1 step on
	//off motor
	
	switch (steeringstatus)
    20f0:	89 81       	ldd	r24, Y+1	; 0x01
    20f2:	28 2f       	mov	r18, r24
    20f4:	30 e0       	ldi	r19, 0x00	; 0
    20f6:	3b 83       	std	Y+3, r19	; 0x03
    20f8:	2a 83       	std	Y+2, r18	; 0x02
    20fa:	8a 81       	ldd	r24, Y+2	; 0x02
    20fc:	9b 81       	ldd	r25, Y+3	; 0x03
    20fe:	84 30       	cpi	r24, 0x04	; 4
    2100:	91 05       	cpc	r25, r1
    2102:	b1 f0       	breq	.+44     	; 0x2130 <MOTOR_steering_Control+0x4e>
    2104:	2a 81       	ldd	r18, Y+2	; 0x02
    2106:	3b 81       	ldd	r19, Y+3	; 0x03
    2108:	29 30       	cpi	r18, 0x09	; 9
    210a:	31 05       	cpc	r19, r1
    210c:	e9 f0       	breq	.+58     	; 0x2148 <MOTOR_steering_Control+0x66>
    210e:	8a 81       	ldd	r24, Y+2	; 0x02
    2110:	9b 81       	ldd	r25, Y+3	; 0x03
    2112:	83 30       	cpi	r24, 0x03	; 3
    2114:	91 05       	cpc	r25, r1
    2116:	19 f5       	brne	.+70     	; 0x215e <MOTOR_steering_Control+0x7c>
	{
		case STEERING_RIGHT  :
		Dio_WriteChannel(I1,STD_HIGH);
    2118:	82 e1       	ldi	r24, 0x12	; 18
    211a:	61 e0       	ldi	r22, 0x01	; 1
    211c:	0e 94 b1 0d 	call	0x1b62	; 0x1b62 <Dio_WriteChannel>
		Dio_WriteChannel(I2,STD_LOW);
    2120:	83 e1       	ldi	r24, 0x13	; 19
    2122:	60 e0       	ldi	r22, 0x00	; 0
    2124:	0e 94 b1 0d 	call	0x1b62	; 0x1b62 <Dio_WriteChannel>
		TMR2_SetDutyCycle(MOTOR_R_DUTY);
    2128:	83 e6       	ldi	r24, 0x63	; 99
    212a:	0e 94 4c 05 	call	0xa98	; 0xa98 <TMR2_SetDutyCycle>
    212e:	17 c0       	rjmp	.+46     	; 0x215e <MOTOR_steering_Control+0x7c>
		break;
		case STEERING_LEFT :
		Dio_WriteChannel(I1,STD_LOW);
    2130:	82 e1       	ldi	r24, 0x12	; 18
    2132:	60 e0       	ldi	r22, 0x00	; 0
    2134:	0e 94 b1 0d 	call	0x1b62	; 0x1b62 <Dio_WriteChannel>
		Dio_WriteChannel(I2,STD_HIGH);
    2138:	83 e1       	ldi	r24, 0x13	; 19
    213a:	61 e0       	ldi	r22, 0x01	; 1
    213c:	0e 94 b1 0d 	call	0x1b62	; 0x1b62 <Dio_WriteChannel>
		TMR2_SetDutyCycle(MOTOR_L_DUTY);
    2140:	83 e6       	ldi	r24, 0x63	; 99
    2142:	0e 94 4c 05 	call	0xa98	; 0xa98 <TMR2_SetDutyCycle>
    2146:	0b c0       	rjmp	.+22     	; 0x215e <MOTOR_steering_Control+0x7c>
		break;
		case STEERING_STRAIGHT :
		Dio_WriteChannel(I1,STD_LOW);
    2148:	82 e1       	ldi	r24, 0x12	; 18
    214a:	60 e0       	ldi	r22, 0x00	; 0
    214c:	0e 94 b1 0d 	call	0x1b62	; 0x1b62 <Dio_WriteChannel>
		Dio_WriteChannel(I2,STD_LOW);
    2150:	83 e1       	ldi	r24, 0x13	; 19
    2152:	60 e0       	ldi	r22, 0x00	; 0
    2154:	0e 94 b1 0d 	call	0x1b62	; 0x1b62 <Dio_WriteChannel>
		TMR2_SetDutyCycle(0);
    2158:	80 e0       	ldi	r24, 0x00	; 0
    215a:	0e 94 4c 05 	call	0xa98	; 0xa98 <TMR2_SetDutyCycle>
		break;
	}
}
    215e:	0f 90       	pop	r0
    2160:	0f 90       	pop	r0
    2162:	0f 90       	pop	r0
    2164:	cf 91       	pop	r28
    2166:	df 91       	pop	r29
    2168:	08 95       	ret

0000216a <MCP2515_ReadRegister>:
#include "../../HAL/CANMCB/MCP2515_private.h"
#include "../../HAL/CANMCB/MCP2515_cfg.h"

volatile u8 buffer[14];
u8 MCP2515_ReadRegister (u8 address)
{
    216a:	df 93       	push	r29
    216c:	cf 93       	push	r28
    216e:	00 d0       	rcall	.+0      	; 0x2170 <MCP2515_ReadRegister+0x6>
    2170:	cd b7       	in	r28, 0x3d	; 61
    2172:	de b7       	in	r29, 0x3e	; 62
    2174:	8a 83       	std	Y+2, r24	; 0x02
	u8 readValue=0;
    2176:	19 82       	std	Y+1, r1	; 0x01

	//catch bus
	SPI_ChipSelect(1);
    2178:	81 e0       	ldi	r24, 0x01	; 1
    217a:	0e 94 13 12 	call	0x2426	; 0x2426 <SPI_ChipSelect>
	
	// read instrunction to can read register MCP
	SPI_MasterTransmit(READ_INSTRUCTION); 
    217e:	83 e0       	ldi	r24, 0x03	; 3
    2180:	0e 94 40 09 	call	0x1280	; 0x1280 <SPI_MasterTransmit>
	//sending address register of mcp
	SPI_MasterTransmit(address); 
    2184:	8a 81       	ldd	r24, Y+2	; 0x02
    2186:	0e 94 40 09 	call	0x1280	; 0x1280 <SPI_MasterTransmit>
	//dont care sending data but we recieve data out
	readValue=SPI_MasterTransmit(0);
    218a:	80 e0       	ldi	r24, 0x00	; 0
    218c:	0e 94 40 09 	call	0x1280	; 0x1280 <SPI_MasterTransmit>
    2190:	89 83       	std	Y+1, r24	; 0x01
	
	//leave bus
	SPI_ChipSelect(0);
    2192:	80 e0       	ldi	r24, 0x00	; 0
    2194:	0e 94 13 12 	call	0x2426	; 0x2426 <SPI_ChipSelect>
	return readValue;
    2198:	89 81       	ldd	r24, Y+1	; 0x01
}
    219a:	0f 90       	pop	r0
    219c:	0f 90       	pop	r0
    219e:	cf 91       	pop	r28
    21a0:	df 91       	pop	r29
    21a2:	08 95       	ret

000021a4 <MCP2515_bufferGet>:
void MCP2515_bufferGet (u8*buff)
{
    21a4:	df 93       	push	r29
    21a6:	cf 93       	push	r28
    21a8:	00 d0       	rcall	.+0      	; 0x21aa <MCP2515_bufferGet+0x6>
    21aa:	0f 92       	push	r0
    21ac:	cd b7       	in	r28, 0x3d	; 61
    21ae:	de b7       	in	r29, 0x3e	; 62
    21b0:	9b 83       	std	Y+3, r25	; 0x03
    21b2:	8a 83       	std	Y+2, r24	; 0x02
	for (u8 i=0;i<14;i++)
    21b4:	19 82       	std	Y+1, r1	; 0x01
    21b6:	13 c0       	rjmp	.+38     	; 0x21de <MCP2515_bufferGet+0x3a>
	{
		buff[i]=buffer[i];
    21b8:	89 81       	ldd	r24, Y+1	; 0x01
    21ba:	28 2f       	mov	r18, r24
    21bc:	30 e0       	ldi	r19, 0x00	; 0
    21be:	8a 81       	ldd	r24, Y+2	; 0x02
    21c0:	9b 81       	ldd	r25, Y+3	; 0x03
    21c2:	dc 01       	movw	r26, r24
    21c4:	a2 0f       	add	r26, r18
    21c6:	b3 1f       	adc	r27, r19
    21c8:	89 81       	ldd	r24, Y+1	; 0x01
    21ca:	88 2f       	mov	r24, r24
    21cc:	90 e0       	ldi	r25, 0x00	; 0
    21ce:	fc 01       	movw	r30, r24
    21d0:	ee 54       	subi	r30, 0x4E	; 78
    21d2:	fd 4f       	sbci	r31, 0xFD	; 253
    21d4:	80 81       	ld	r24, Z
    21d6:	8c 93       	st	X, r24
	SPI_ChipSelect(0);
	return readValue;
}
void MCP2515_bufferGet (u8*buff)
{
	for (u8 i=0;i<14;i++)
    21d8:	89 81       	ldd	r24, Y+1	; 0x01
    21da:	8f 5f       	subi	r24, 0xFF	; 255
    21dc:	89 83       	std	Y+1, r24	; 0x01
    21de:	89 81       	ldd	r24, Y+1	; 0x01
    21e0:	8e 30       	cpi	r24, 0x0E	; 14
    21e2:	50 f3       	brcs	.-44     	; 0x21b8 <MCP2515_bufferGet+0x14>
	{
		buff[i]=buffer[i];
	}
}
    21e4:	0f 90       	pop	r0
    21e6:	0f 90       	pop	r0
    21e8:	0f 90       	pop	r0
    21ea:	cf 91       	pop	r28
    21ec:	df 91       	pop	r29
    21ee:	08 95       	ret

000021f0 <MCP2515_WriteRegister>:
void MCP2515_WriteRegister (u8 address,u8 data )
{
    21f0:	df 93       	push	r29
    21f2:	cf 93       	push	r28
    21f4:	00 d0       	rcall	.+0      	; 0x21f6 <MCP2515_WriteRegister+0x6>
    21f6:	cd b7       	in	r28, 0x3d	; 61
    21f8:	de b7       	in	r29, 0x3e	; 62
    21fa:	89 83       	std	Y+1, r24	; 0x01
    21fc:	6a 83       	std	Y+2, r22	; 0x02
	//catch bus
	SPI_ChipSelect(1);
    21fe:	81 e0       	ldi	r24, 0x01	; 1
    2200:	0e 94 13 12 	call	0x2426	; 0x2426 <SPI_ChipSelect>
	// Write instrunction to can write on register MCP
	SPI_MasterTransmit(WRITE_INSTRUCTION);
    2204:	82 e0       	ldi	r24, 0x02	; 2
    2206:	0e 94 40 09 	call	0x1280	; 0x1280 <SPI_MasterTransmit>
	//sending address register of mcp
	SPI_MasterTransmit(address);
    220a:	89 81       	ldd	r24, Y+1	; 0x01
    220c:	0e 94 40 09 	call	0x1280	; 0x1280 <SPI_MasterTransmit>
	//send data to register 
	SPI_MasterTransmit(data);
    2210:	8a 81       	ldd	r24, Y+2	; 0x02
    2212:	0e 94 40 09 	call	0x1280	; 0x1280 <SPI_MasterTransmit>
	//leave bus
	SPI_ChipSelect(0);
    2216:	80 e0       	ldi	r24, 0x00	; 0
    2218:	0e 94 13 12 	call	0x2426	; 0x2426 <SPI_ChipSelect>
}
    221c:	0f 90       	pop	r0
    221e:	0f 90       	pop	r0
    2220:	cf 91       	pop	r28
    2222:	df 91       	pop	r29
    2224:	08 95       	ret

00002226 <MCP2515_Reset>:
void MCP2515_Reset (void)
{
    2226:	df 93       	push	r29
    2228:	cf 93       	push	r28
    222a:	cd b7       	in	r28, 0x3d	; 61
    222c:	de b7       	in	r29, 0x3e	; 62
	//catch bus
	SPI_ChipSelect(1);
    222e:	81 e0       	ldi	r24, 0x01	; 1
    2230:	0e 94 13 12 	call	0x2426	; 0x2426 <SPI_ChipSelect>
	
	// instrunction reset
	SPI_MasterTransmit(RESET_INSTRUCTION);
    2234:	80 ec       	ldi	r24, 0xC0	; 192
    2236:	0e 94 40 09 	call	0x1280	; 0x1280 <SPI_MasterTransmit>
	
	//leave bus
	SPI_ChipSelect(0);
    223a:	80 e0       	ldi	r24, 0x00	; 0
    223c:	0e 94 13 12 	call	0x2426	; 0x2426 <SPI_ChipSelect>

}
    2240:	cf 91       	pop	r28
    2242:	df 91       	pop	r29
    2244:	08 95       	ret

00002246 <MCP2515_Modify>:
void MCP2515_Modify (u8 address,u8 mask,u8 data )
{
    2246:	df 93       	push	r29
    2248:	cf 93       	push	r28
    224a:	00 d0       	rcall	.+0      	; 0x224c <MCP2515_Modify+0x6>
    224c:	0f 92       	push	r0
    224e:	cd b7       	in	r28, 0x3d	; 61
    2250:	de b7       	in	r29, 0x3e	; 62
    2252:	89 83       	std	Y+1, r24	; 0x01
    2254:	6a 83       	std	Y+2, r22	; 0x02
    2256:	4b 83       	std	Y+3, r20	; 0x03
	//catch bus
	SPI_ChipSelect(1);
    2258:	81 e0       	ldi	r24, 0x01	; 1
    225a:	0e 94 13 12 	call	0x2426	; 0x2426 <SPI_ChipSelect>
	
	// instrunction MODIFY
	SPI_MasterTransmit(MODIFY_INSTRUCTION);
    225e:	85 e0       	ldi	r24, 0x05	; 5
    2260:	0e 94 40 09 	call	0x1280	; 0x1280 <SPI_MasterTransmit>
	//sending address register of mcp
	SPI_MasterTransmit(address);
    2264:	89 81       	ldd	r24, Y+1	; 0x01
    2266:	0e 94 40 09 	call	0x1280	; 0x1280 <SPI_MasterTransmit>
	// send maskable byte
	SPI_MasterTransmit(mask);
    226a:	8a 81       	ldd	r24, Y+2	; 0x02
    226c:	0e 94 40 09 	call	0x1280	; 0x1280 <SPI_MasterTransmit>
	// send data will be maksed
	SPI_MasterTransmit(data);
    2270:	8b 81       	ldd	r24, Y+3	; 0x03
    2272:	0e 94 40 09 	call	0x1280	; 0x1280 <SPI_MasterTransmit>
	
	//leave bus
	SPI_ChipSelect(0);
    2276:	80 e0       	ldi	r24, 0x00	; 0
    2278:	0e 94 13 12 	call	0x2426	; 0x2426 <SPI_ChipSelect>
}
    227c:	0f 90       	pop	r0
    227e:	0f 90       	pop	r0
    2280:	0f 90       	pop	r0
    2282:	cf 91       	pop	r28
    2284:	df 91       	pop	r29
    2286:	08 95       	ret

00002288 <MCP2515_SetBitTiming>:
void MCP2515_SetBitTiming (u8 CNF1Value,u8 CNF2Value,u8 CNF3Value)
{
    2288:	df 93       	push	r29
    228a:	cf 93       	push	r28
    228c:	00 d0       	rcall	.+0      	; 0x228e <MCP2515_SetBitTiming+0x6>
    228e:	0f 92       	push	r0
    2290:	cd b7       	in	r28, 0x3d	; 61
    2292:	de b7       	in	r29, 0x3e	; 62
    2294:	89 83       	std	Y+1, r24	; 0x01
    2296:	6a 83       	std	Y+2, r22	; 0x02
    2298:	4b 83       	std	Y+3, r20	; 0x03
	MCP2515_WriteRegister(CNF1,CNF1Value);
    229a:	8a e2       	ldi	r24, 0x2A	; 42
    229c:	69 81       	ldd	r22, Y+1	; 0x01
    229e:	0e 94 f8 10 	call	0x21f0	; 0x21f0 <MCP2515_WriteRegister>
	MCP2515_WriteRegister(CNF2,CNF2Value);
    22a2:	89 e2       	ldi	r24, 0x29	; 41
    22a4:	6a 81       	ldd	r22, Y+2	; 0x02
    22a6:	0e 94 f8 10 	call	0x21f0	; 0x21f0 <MCP2515_WriteRegister>
	MCP2515_WriteRegister(CNF3,CNF3Value);
    22aa:	88 e2       	ldi	r24, 0x28	; 40
    22ac:	6b 81       	ldd	r22, Y+3	; 0x03
    22ae:	0e 94 f8 10 	call	0x21f0	; 0x21f0 <MCP2515_WriteRegister>
}
    22b2:	0f 90       	pop	r0
    22b4:	0f 90       	pop	r0
    22b6:	0f 90       	pop	r0
    22b8:	cf 91       	pop	r28
    22ba:	df 91       	pop	r29
    22bc:	08 95       	ret

000022be <MCP2515_SetMode>:
void MCP2515_SetMode (u8 mode)
{
    22be:	df 93       	push	r29
    22c0:	cf 93       	push	r28
    22c2:	0f 92       	push	r0
    22c4:	cd b7       	in	r28, 0x3d	; 61
    22c6:	de b7       	in	r29, 0x3e	; 62
    22c8:	89 83       	std	Y+1, r24	; 0x01
	MCP2515_Modify(CANCTRL,0xE0,mode<<5);//E for change last 3 bits only and shift 5 to get last 5 bits 
    22ca:	89 81       	ldd	r24, Y+1	; 0x01
    22cc:	98 2f       	mov	r25, r24
    22ce:	92 95       	swap	r25
    22d0:	99 0f       	add	r25, r25
    22d2:	90 7e       	andi	r25, 0xE0	; 224
    22d4:	8f e0       	ldi	r24, 0x0F	; 15
    22d6:	60 ee       	ldi	r22, 0xE0	; 224
    22d8:	49 2f       	mov	r20, r25
    22da:	0e 94 23 11 	call	0x2246	; 0x2246 <MCP2515_Modify>
	
	while ((MCP2515_ReadRegister(CANSTAT)>>5)!=mode);  // to check if we selected right mode its additional 
    22de:	8e e0       	ldi	r24, 0x0E	; 14
    22e0:	0e 94 b5 10 	call	0x216a	; 0x216a <MCP2515_ReadRegister>
    22e4:	98 2f       	mov	r25, r24
    22e6:	92 95       	swap	r25
    22e8:	96 95       	lsr	r25
    22ea:	97 70       	andi	r25, 0x07	; 7
    22ec:	89 81       	ldd	r24, Y+1	; 0x01
    22ee:	98 17       	cp	r25, r24
    22f0:	b1 f7       	brne	.-20     	; 0x22de <MCP2515_SetMode+0x20>
	
}
    22f2:	0f 90       	pop	r0
    22f4:	cf 91       	pop	r28
    22f6:	df 91       	pop	r29
    22f8:	08 95       	ret

000022fa <MCP2515_TransmiterInit>:
void MCP2515_TransmiterInit(void)
{
    22fa:	df 93       	push	r29
    22fc:	cf 93       	push	r28
    22fe:	cd b7       	in	r28, 0x3d	; 61
    2300:	de b7       	in	r29, 0x3e	; 62
	//spi master init
	SPI_ChipSelect(0);
    2302:	80 e0       	ldi	r24, 0x00	; 0
    2304:	0e 94 13 12 	call	0x2426	; 0x2426 <SPI_ChipSelect>
	SPI_MasterCan_Init();
    2308:	0e 94 e2 08 	call	0x11c4	; 0x11c4 <SPI_MasterCan_Init>
    
	//reset  mcp
	MCP2515_Reset();
    230c:	0e 94 13 11 	call	0x2226	; 0x2226 <MCP2515_Reset>
	
	//to select config mode and enable clock 
    MCP2515_WriteRegister(CANCTRL,0x84);
    2310:	8f e0       	ldi	r24, 0x0F	; 15
    2312:	64 e8       	ldi	r22, 0x84	; 132
    2314:	0e 94 f8 10 	call	0x21f0	; 0x21f0 <MCP2515_WriteRegister>
	while ((MCP2515_ReadRegister(CANSTAT)>>5)!=CFG_MODE);  // to check if we selected right mode its additional
    2318:	8e e0       	ldi	r24, 0x0E	; 14
    231a:	0e 94 b5 10 	call	0x216a	; 0x216a <MCP2515_ReadRegister>
    231e:	82 95       	swap	r24
    2320:	86 95       	lsr	r24
    2322:	87 70       	andi	r24, 0x07	; 7
    2324:	84 30       	cpi	r24, 0x04	; 4
    2326:	c1 f7       	brne	.-16     	; 0x2318 <MCP2515_TransmiterInit+0x1e>
	
	//select bit timing
	MCP2515_SetBitTiming((2<<6),(1<<7)|(6<<3)|(1),(5));   //cnf1-> 0b1000000   01 for 3 TQ,cnf2 
    2328:	80 e8       	ldi	r24, 0x80	; 128
    232a:	61 eb       	ldi	r22, 0xB1	; 177
    232c:	45 e0       	ldi	r20, 0x05	; 5
    232e:	0e 94 44 11 	call	0x2288	; 0x2288 <MCP2515_SetBitTiming>
	MCP2515_SetMode(NORMAL_MODE);
    2332:	80 e0       	ldi	r24, 0x00	; 0
    2334:	0e 94 5f 11 	call	0x22be	; 0x22be <MCP2515_SetMode>
	//MCP2515_SetMode(LOOP_BACK_MODE); //loop back testing
}
    2338:	cf 91       	pop	r28
    233a:	df 91       	pop	r29
    233c:	08 95       	ret

0000233e <MCP2515_SendMessage>:
void MCP2515_SendMessage(u8 bufId,u32 msgId,u8 dcl,u8*data)
{
    233e:	0f 93       	push	r16
    2340:	1f 93       	push	r17
    2342:	df 93       	push	r29
    2344:	cf 93       	push	r28
    2346:	cd b7       	in	r28, 0x3d	; 61
    2348:	de b7       	in	r29, 0x3e	; 62
    234a:	29 97       	sbiw	r28, 0x09	; 9
    234c:	0f b6       	in	r0, 0x3f	; 63
    234e:	f8 94       	cli
    2350:	de bf       	out	0x3e, r29	; 62
    2352:	0f be       	out	0x3f, r0	; 63
    2354:	cd bf       	out	0x3d, r28	; 61
    2356:	8a 83       	std	Y+2, r24	; 0x02
    2358:	4b 83       	std	Y+3, r20	; 0x03
    235a:	5c 83       	std	Y+4, r21	; 0x04
    235c:	6d 83       	std	Y+5, r22	; 0x05
    235e:	7e 83       	std	Y+6, r23	; 0x06
    2360:	2f 83       	std	Y+7, r18	; 0x07
    2362:	19 87       	std	Y+9, r17	; 0x09
    2364:	08 87       	std	Y+8, r16	; 0x08
	//catch bus
	SPI_ChipSelect(1);
    2366:	81 e0       	ldi	r24, 0x01	; 1
    2368:	0e 94 13 12 	call	0x2426	; 0x2426 <SPI_ChipSelect>
	//write register
	SPI_MasterTransmit(WRITE_INSTRUCTION);
    236c:	82 e0       	ldi	r24, 0x02	; 2
    236e:	0e 94 40 09 	call	0x1280	; 0x1280 <SPI_MasterTransmit>
	//Send address first address on buffer
		SPI_MasterTransmit(TXB0CTRL);
    2372:	80 e3       	ldi	r24, 0x30	; 48
    2374:	0e 94 40 09 	call	0x1280	; 0x1280 <SPI_MasterTransmit>

	//setup priority  "mandatory"
	SPI_MasterTransmit(dcl>>6); 
    2378:	8f 81       	ldd	r24, Y+7	; 0x07
    237a:	82 95       	swap	r24
    237c:	86 95       	lsr	r24
    237e:	86 95       	lsr	r24
    2380:	83 70       	andi	r24, 0x03	; 3
    2382:	0e 94 40 09 	call	0x1280	; 0x1280 <SPI_MasterTransmit>
	//send msgid
	SPI_MasterTransmit((u8)(msgId>>3)); //last 8 bits
    2386:	8b 81       	ldd	r24, Y+3	; 0x03
    2388:	9c 81       	ldd	r25, Y+4	; 0x04
    238a:	ad 81       	ldd	r26, Y+5	; 0x05
    238c:	be 81       	ldd	r27, Y+6	; 0x06
    238e:	68 94       	set
    2390:	12 f8       	bld	r1, 2
    2392:	b6 95       	lsr	r27
    2394:	a7 95       	ror	r26
    2396:	97 95       	ror	r25
    2398:	87 95       	ror	r24
    239a:	16 94       	lsr	r1
    239c:	d1 f7       	brne	.-12     	; 0x2392 <MCP2515_SendMessage+0x54>
    239e:	0e 94 40 09 	call	0x1280	; 0x1280 <SPI_MasterTransmit>
	SPI_MasterTransmit((u8)(msgId<<5)); //first 3 bits
    23a2:	8b 81       	ldd	r24, Y+3	; 0x03
    23a4:	82 95       	swap	r24
    23a6:	88 0f       	add	r24, r24
    23a8:	80 7e       	andi	r24, 0xE0	; 224
    23aa:	0e 94 40 09 	call	0x1280	; 0x1280 <SPI_MasterTransmit>
	//no there externalID
	SPI_MasterTransmit(0);
    23ae:	80 e0       	ldi	r24, 0x00	; 0
    23b0:	0e 94 40 09 	call	0x1280	; 0x1280 <SPI_MasterTransmit>
	SPI_MasterTransmit(0);
    23b4:	80 e0       	ldi	r24, 0x00	; 0
    23b6:	0e 94 40 09 	call	0x1280	; 0x1280 <SPI_MasterTransmit>
    //send dcl
	SPI_MasterTransmit(dcl&0x0f);
    23ba:	8f 81       	ldd	r24, Y+7	; 0x07
    23bc:	8f 70       	andi	r24, 0x0F	; 15
    23be:	0e 94 40 09 	call	0x1280	; 0x1280 <SPI_MasterTransmit>
	//send data
	for (u8 i=0;i<(dcl&0x0f);i++)
    23c2:	19 82       	std	Y+1, r1	; 0x01
    23c4:	0e c0       	rjmp	.+28     	; 0x23e2 <MCP2515_SendMessage+0xa4>
	{
		SPI_MasterTransmit(data[i]);
    23c6:	89 81       	ldd	r24, Y+1	; 0x01
    23c8:	28 2f       	mov	r18, r24
    23ca:	30 e0       	ldi	r19, 0x00	; 0
    23cc:	88 85       	ldd	r24, Y+8	; 0x08
    23ce:	99 85       	ldd	r25, Y+9	; 0x09
    23d0:	fc 01       	movw	r30, r24
    23d2:	e2 0f       	add	r30, r18
    23d4:	f3 1f       	adc	r31, r19
    23d6:	80 81       	ld	r24, Z
    23d8:	0e 94 40 09 	call	0x1280	; 0x1280 <SPI_MasterTransmit>
	SPI_MasterTransmit(0);
	SPI_MasterTransmit(0);
    //send dcl
	SPI_MasterTransmit(dcl&0x0f);
	//send data
	for (u8 i=0;i<(dcl&0x0f);i++)
    23dc:	89 81       	ldd	r24, Y+1	; 0x01
    23de:	8f 5f       	subi	r24, 0xFF	; 255
    23e0:	89 83       	std	Y+1, r24	; 0x01
    23e2:	89 81       	ldd	r24, Y+1	; 0x01
    23e4:	28 2f       	mov	r18, r24
    23e6:	30 e0       	ldi	r19, 0x00	; 0
    23e8:	8f 81       	ldd	r24, Y+7	; 0x07
    23ea:	88 2f       	mov	r24, r24
    23ec:	90 e0       	ldi	r25, 0x00	; 0
    23ee:	8f 70       	andi	r24, 0x0F	; 15
    23f0:	90 70       	andi	r25, 0x00	; 0
    23f2:	28 17       	cp	r18, r24
    23f4:	39 07       	cpc	r19, r25
    23f6:	3c f3       	brlt	.-50     	; 0x23c6 <MCP2515_SendMessage+0x88>
	{
		SPI_MasterTransmit(data[i]);
	}
	//leave bus
	SPI_ChipSelect(0);
    23f8:	80 e0       	ldi	r24, 0x00	; 0
    23fa:	0e 94 13 12 	call	0x2426	; 0x2426 <SPI_ChipSelect>
	//here you can send anothers buffers.....
	
	SPI_ChipSelect(1);
    23fe:	81 e0       	ldi	r24, 0x01	; 1
    2400:	0e 94 13 12 	call	0x2426	; 0x2426 <SPI_ChipSelect>
	//send request to send for buffer 0
	SPI_MasterTransmit(REQUEST_TO_SEND_B0);
    2404:	81 e8       	ldi	r24, 0x81	; 129
    2406:	0e 94 40 09 	call	0x1280	; 0x1280 <SPI_MasterTransmit>
	SPI_ChipSelect(0);
    240a:	80 e0       	ldi	r24, 0x00	; 0
    240c:	0e 94 13 12 	call	0x2426	; 0x2426 <SPI_ChipSelect>
	
	
}
    2410:	29 96       	adiw	r28, 0x09	; 9
    2412:	0f b6       	in	r0, 0x3f	; 63
    2414:	f8 94       	cli
    2416:	de bf       	out	0x3e, r29	; 62
    2418:	0f be       	out	0x3f, r0	; 63
    241a:	cd bf       	out	0x3d, r28	; 61
    241c:	cf 91       	pop	r28
    241e:	df 91       	pop	r29
    2420:	1f 91       	pop	r17
    2422:	0f 91       	pop	r16
    2424:	08 95       	ret

00002426 <SPI_ChipSelect>:


void SPI_ChipSelect (u8 state)
{
    2426:	df 93       	push	r29
    2428:	cf 93       	push	r28
    242a:	0f 92       	push	r0
    242c:	cd b7       	in	r28, 0x3d	; 61
    242e:	de b7       	in	r29, 0x3e	; 62
    2430:	89 83       	std	Y+1, r24	; 0x01
	if (state==1)
    2432:	89 81       	ldd	r24, Y+1	; 0x01
    2434:	81 30       	cpi	r24, 0x01	; 1
    2436:	29 f4       	brne	.+10     	; 0x2442 <SPI_ChipSelect+0x1c>
	{
		Dio_WriteChannel(SPI_SS_PIN,LOW);
    2438:	88 e0       	ldi	r24, 0x08	; 8
    243a:	60 e0       	ldi	r22, 0x00	; 0
    243c:	0e 94 b1 0d 	call	0x1b62	; 0x1b62 <Dio_WriteChannel>
    2440:	04 c0       	rjmp	.+8      	; 0x244a <SPI_ChipSelect+0x24>
	}
	else
	{
		Dio_WriteChannel(SPI_SS_PIN,HIGH);
    2442:	88 e0       	ldi	r24, 0x08	; 8
    2444:	61 e0       	ldi	r22, 0x01	; 1
    2446:	0e 94 b1 0d 	call	0x1b62	; 0x1b62 <Dio_WriteChannel>
	}
}
    244a:	0f 90       	pop	r0
    244c:	cf 91       	pop	r28
    244e:	df 91       	pop	r29
    2450:	08 95       	ret

00002452 <MCP2515_SetMask>:

/*receiver */
void MCP2515_SetMask (u8 address,u32 value,u8 extendedFlag)
{
    2452:	df 93       	push	r29
    2454:	cf 93       	push	r28
    2456:	00 d0       	rcall	.+0      	; 0x2458 <MCP2515_SetMask+0x6>
    2458:	00 d0       	rcall	.+0      	; 0x245a <MCP2515_SetMask+0x8>
    245a:	00 d0       	rcall	.+0      	; 0x245c <MCP2515_SetMask+0xa>
    245c:	cd b7       	in	r28, 0x3d	; 61
    245e:	de b7       	in	r29, 0x3e	; 62
    2460:	89 83       	std	Y+1, r24	; 0x01
    2462:	4a 83       	std	Y+2, r20	; 0x02
    2464:	5b 83       	std	Y+3, r21	; 0x03
    2466:	6c 83       	std	Y+4, r22	; 0x04
    2468:	7d 83       	std	Y+5, r23	; 0x05
    246a:	2e 83       	std	Y+6, r18	; 0x06
	//catch bus
	SPI_ChipSelect(1);
    246c:	81 e0       	ldi	r24, 0x01	; 1
    246e:	0e 94 13 12 	call	0x2426	; 0x2426 <SPI_ChipSelect>
	SPI_MasterTransmit(WRITE_INSTRUCTION);
    2472:	82 e0       	ldi	r24, 0x02	; 2
    2474:	0e 94 40 09 	call	0x1280	; 0x1280 <SPI_MasterTransmit>
	SPI_MasterTransmit(address);
    2478:	89 81       	ldd	r24, Y+1	; 0x01
    247a:	0e 94 40 09 	call	0x1280	; 0x1280 <SPI_MasterTransmit>
	
	if (extendedFlag)
    247e:	8e 81       	ldd	r24, Y+6	; 0x06
    2480:	88 23       	and	r24, r24
    2482:	b9 f1       	breq	.+110    	; 0x24f2 <MCP2515_SetMask+0xa0>
	{
		SPI_MasterTransmit((u8)(value>>3)); 
    2484:	8a 81       	ldd	r24, Y+2	; 0x02
    2486:	9b 81       	ldd	r25, Y+3	; 0x03
    2488:	ac 81       	ldd	r26, Y+4	; 0x04
    248a:	bd 81       	ldd	r27, Y+5	; 0x05
    248c:	68 94       	set
    248e:	12 f8       	bld	r1, 2
    2490:	b6 95       	lsr	r27
    2492:	a7 95       	ror	r26
    2494:	97 95       	ror	r25
    2496:	87 95       	ror	r24
    2498:	16 94       	lsr	r1
    249a:	d1 f7       	brne	.-12     	; 0x2490 <MCP2515_SetMask+0x3e>
    249c:	0e 94 40 09 	call	0x1280	; 0x1280 <SPI_MasterTransmit>
		SPI_MasterTransmit((u8)(value<<5)|(1<<3)|(u8)(value>>27)); //first 3 bits and get last 3 bits  and enable extended
    24a0:	8a 81       	ldd	r24, Y+2	; 0x02
    24a2:	28 2f       	mov	r18, r24
    24a4:	22 95       	swap	r18
    24a6:	22 0f       	add	r18, r18
    24a8:	20 7e       	andi	r18, 0xE0	; 224
    24aa:	8a 81       	ldd	r24, Y+2	; 0x02
    24ac:	9b 81       	ldd	r25, Y+3	; 0x03
    24ae:	ac 81       	ldd	r26, Y+4	; 0x04
    24b0:	bd 81       	ldd	r27, Y+5	; 0x05
    24b2:	07 2e       	mov	r0, r23
    24b4:	7b e1       	ldi	r23, 0x1B	; 27
    24b6:	b6 95       	lsr	r27
    24b8:	a7 95       	ror	r26
    24ba:	97 95       	ror	r25
    24bc:	87 95       	ror	r24
    24be:	7a 95       	dec	r23
    24c0:	d1 f7       	brne	.-12     	; 0x24b6 <MCP2515_SetMask+0x64>
    24c2:	70 2d       	mov	r23, r0
    24c4:	82 2b       	or	r24, r18
    24c6:	88 60       	ori	r24, 0x08	; 8
    24c8:	0e 94 40 09 	call	0x1280	; 0x1280 <SPI_MasterTransmit>
		SPI_MasterTransmit((u8)(value>>19)); 
    24cc:	8a 81       	ldd	r24, Y+2	; 0x02
    24ce:	9b 81       	ldd	r25, Y+3	; 0x03
    24d0:	ac 81       	ldd	r26, Y+4	; 0x04
    24d2:	bd 81       	ldd	r27, Y+5	; 0x05
    24d4:	07 2e       	mov	r0, r23
    24d6:	73 e1       	ldi	r23, 0x13	; 19
    24d8:	b6 95       	lsr	r27
    24da:	a7 95       	ror	r26
    24dc:	97 95       	ror	r25
    24de:	87 95       	ror	r24
    24e0:	7a 95       	dec	r23
    24e2:	d1 f7       	brne	.-12     	; 0x24d8 <MCP2515_SetMask+0x86>
    24e4:	70 2d       	mov	r23, r0
    24e6:	0e 94 40 09 	call	0x1280	; 0x1280 <SPI_MasterTransmit>
		SPI_MasterTransmit((u8)(value<<11)); 	
    24ea:	80 e0       	ldi	r24, 0x00	; 0
    24ec:	0e 94 40 09 	call	0x1280	; 0x1280 <SPI_MasterTransmit>
    24f0:	14 c0       	rjmp	.+40     	; 0x251a <MCP2515_SetMask+0xc8>
	}
	else
	{
		SPI_MasterTransmit((u8)(value>>3)); //last 8 bits
    24f2:	8a 81       	ldd	r24, Y+2	; 0x02
    24f4:	9b 81       	ldd	r25, Y+3	; 0x03
    24f6:	ac 81       	ldd	r26, Y+4	; 0x04
    24f8:	bd 81       	ldd	r27, Y+5	; 0x05
    24fa:	68 94       	set
    24fc:	12 f8       	bld	r1, 2
    24fe:	b6 95       	lsr	r27
    2500:	a7 95       	ror	r26
    2502:	97 95       	ror	r25
    2504:	87 95       	ror	r24
    2506:	16 94       	lsr	r1
    2508:	d1 f7       	brne	.-12     	; 0x24fe <MCP2515_SetMask+0xac>
    250a:	0e 94 40 09 	call	0x1280	; 0x1280 <SPI_MasterTransmit>
		SPI_MasterTransmit((u8)(value<<5)); //first 3 bits
    250e:	8a 81       	ldd	r24, Y+2	; 0x02
    2510:	82 95       	swap	r24
    2512:	88 0f       	add	r24, r24
    2514:	80 7e       	andi	r24, 0xE0	; 224
    2516:	0e 94 40 09 	call	0x1280	; 0x1280 <SPI_MasterTransmit>
	}
	SPI_ChipSelect(0);	
    251a:	80 e0       	ldi	r24, 0x00	; 0
    251c:	0e 94 13 12 	call	0x2426	; 0x2426 <SPI_ChipSelect>
}
    2520:	26 96       	adiw	r28, 0x06	; 6
    2522:	0f b6       	in	r0, 0x3f	; 63
    2524:	f8 94       	cli
    2526:	de bf       	out	0x3e, r29	; 62
    2528:	0f be       	out	0x3f, r0	; 63
    252a:	cd bf       	out	0x3d, r28	; 61
    252c:	cf 91       	pop	r28
    252e:	df 91       	pop	r29
    2530:	08 95       	ret

00002532 <MCP2515_receiverInit>:

void MCP2515_receiverInit(void)
{
    2532:	df 93       	push	r29
    2534:	cf 93       	push	r28
    2536:	cd b7       	in	r28, 0x3d	; 61
    2538:	de b7       	in	r29, 0x3e	; 62
	//spi master init
	SPI_ChipSelect(0);
    253a:	80 e0       	ldi	r24, 0x00	; 0
    253c:	0e 94 13 12 	call	0x2426	; 0x2426 <SPI_ChipSelect>
	SPI_MasterCan_Init();
    2540:	0e 94 e2 08 	call	0x11c4	; 0x11c4 <SPI_MasterCan_Init>
	//reset  mcp
	MCP2515_Reset();
    2544:	0e 94 13 11 	call	0x2226	; 0x2226 <MCP2515_Reset>
	//to select config mode and enable clock
	MCP2515_WriteRegister(CANCTRL,0x84);
    2548:	8f e0       	ldi	r24, 0x0F	; 15
    254a:	64 e8       	ldi	r22, 0x84	; 132
    254c:	0e 94 f8 10 	call	0x21f0	; 0x21f0 <MCP2515_WriteRegister>
	while ((MCP2515_ReadRegister(CANSTAT)>>5)!=CFG_MODE);  // to check if we selected right mode its additional
    2550:	8e e0       	ldi	r24, 0x0E	; 14
    2552:	0e 94 b5 10 	call	0x216a	; 0x216a <MCP2515_ReadRegister>
    2556:	82 95       	swap	r24
    2558:	86 95       	lsr	r24
    255a:	87 70       	andi	r24, 0x07	; 7
    255c:	84 30       	cpi	r24, 0x04	; 4
    255e:	c1 f7       	brne	.-16     	; 0x2550 <MCP2515_receiverInit+0x1e>
	//select bit timing
	MCP2515_SetBitTiming(0x80,0xb1,0x5);   //cnf1-> 0b1000000   01 for 3 TQ,cnf2
    2560:	80 e8       	ldi	r24, 0x80	; 128
    2562:	61 eb       	ldi	r22, 0xB1	; 177
    2564:	45 e0       	ldi	r20, 0x05	; 5
    2566:	0e 94 44 11 	call	0x2288	; 0x2288 <MCP2515_SetBitTiming>
	// set mask all msgs accepted
	MCP2515_SetMask(RXM0SIDH,MASK_RXB0,1);
    256a:	80 e2       	ldi	r24, 0x20	; 32
    256c:	40 e0       	ldi	r20, 0x00	; 0
    256e:	50 e0       	ldi	r21, 0x00	; 0
    2570:	60 e0       	ldi	r22, 0x00	; 0
    2572:	70 e0       	ldi	r23, 0x00	; 0
    2574:	21 e0       	ldi	r18, 0x01	; 1
    2576:	0e 94 29 12 	call	0x2452	; 0x2452 <MCP2515_SetMask>
	MCP2515_SetMask(RXM1SIDH,MASK_RXB1,1);
    257a:	84 e2       	ldi	r24, 0x24	; 36
    257c:	40 e0       	ldi	r20, 0x00	; 0
    257e:	50 e0       	ldi	r21, 0x00	; 0
    2580:	60 e0       	ldi	r22, 0x00	; 0
    2582:	70 e0       	ldi	r23, 0x00	; 0
    2584:	21 e0       	ldi	r18, 0x01	; 1
    2586:	0e 94 29 12 	call	0x2452	; 0x2452 <MCP2515_SetMask>
	//enable interrupt rx
	MCP2515_WriteRegister(CANINTE,1<<0);
    258a:	8b e2       	ldi	r24, 0x2B	; 43
    258c:	61 e0       	ldi	r22, 0x01	; 1
    258e:	0e 94 f8 10 	call	0x21f0	; 0x21f0 <MCP2515_WriteRegister>
	
	MCP2515_SetMode(NORMAL_MODE);
    2592:	80 e0       	ldi	r24, 0x00	; 0
    2594:	0e 94 5f 11 	call	0x22be	; 0x22be <MCP2515_SetMode>
	//MCP2515_SetMode(LOOP_BACK_MODE); //loop back testing
	
}
    2598:	cf 91       	pop	r28
    259a:	df 91       	pop	r29
    259c:	08 95       	ret

0000259e <MCP2515_receiverB0>:

void MCP2515_receiverB0 (void)
{
    259e:	0f 93       	push	r16
    25a0:	1f 93       	push	r17
    25a2:	df 93       	push	r29
    25a4:	cf 93       	push	r28
    25a6:	0f 92       	push	r0
    25a8:	cd b7       	in	r28, 0x3d	; 61
    25aa:	de b7       	in	r29, 0x3e	; 62
	//catch bus
	SPI_ChipSelect(1);
    25ac:	81 e0       	ldi	r24, 0x01	; 1
    25ae:	0e 94 13 12 	call	0x2426	; 0x2426 <SPI_ChipSelect>
	SPI_MasterTransmit(READ_INSTRUCTION);
    25b2:	83 e0       	ldi	r24, 0x03	; 3
    25b4:	0e 94 40 09 	call	0x1280	; 0x1280 <SPI_MasterTransmit>
	SPI_MasterTransmit(RXB0CTRL);
    25b8:	80 e6       	ldi	r24, 0x60	; 96
    25ba:	0e 94 40 09 	call	0x1280	; 0x1280 <SPI_MasterTransmit>
	for (u8 i=0 ;i<14;i++)
    25be:	19 82       	std	Y+1, r1	; 0x01
    25c0:	0d c0       	rjmp	.+26     	; 0x25dc <MCP2515_receiverB0+0x3e>
	{
		buffer[i]=SPI_MasterTransmit(0);
    25c2:	89 81       	ldd	r24, Y+1	; 0x01
    25c4:	08 2f       	mov	r16, r24
    25c6:	10 e0       	ldi	r17, 0x00	; 0
    25c8:	80 e0       	ldi	r24, 0x00	; 0
    25ca:	0e 94 40 09 	call	0x1280	; 0x1280 <SPI_MasterTransmit>
    25ce:	f8 01       	movw	r30, r16
    25d0:	ee 54       	subi	r30, 0x4E	; 78
    25d2:	fd 4f       	sbci	r31, 0xFD	; 253
    25d4:	80 83       	st	Z, r24
{
	//catch bus
	SPI_ChipSelect(1);
	SPI_MasterTransmit(READ_INSTRUCTION);
	SPI_MasterTransmit(RXB0CTRL);
	for (u8 i=0 ;i<14;i++)
    25d6:	89 81       	ldd	r24, Y+1	; 0x01
    25d8:	8f 5f       	subi	r24, 0xFF	; 255
    25da:	89 83       	std	Y+1, r24	; 0x01
    25dc:	89 81       	ldd	r24, Y+1	; 0x01
    25de:	8e 30       	cpi	r24, 0x0E	; 14
    25e0:	80 f3       	brcs	.-32     	; 0x25c2 <MCP2515_receiverB0+0x24>
	{
		buffer[i]=SPI_MasterTransmit(0);
	}
	SPI_ChipSelect(0);
    25e2:	80 e0       	ldi	r24, 0x00	; 0
    25e4:	0e 94 13 12 	call	0x2426	; 0x2426 <SPI_ChipSelect>
	//clear interrupt rx
	MCP2515_WriteRegister(CANINTF,0);
    25e8:	8c e2       	ldi	r24, 0x2C	; 44
    25ea:	60 e0       	ldi	r22, 0x00	; 0
    25ec:	0e 94 f8 10 	call	0x21f0	; 0x21f0 <MCP2515_WriteRegister>
}
    25f0:	0f 90       	pop	r0
    25f2:	cf 91       	pop	r28
    25f4:	df 91       	pop	r29
    25f6:	1f 91       	pop	r17
    25f8:	0f 91       	pop	r16
    25fa:	08 95       	ret

000025fc <RX_Interrupt>:
u8 motor_status ;

/*************************************************ISR FUNC******************************************/

void RX_Interrupt (void)
{
    25fc:	df 93       	push	r29
    25fe:	cf 93       	push	r28
    2600:	cd b7       	in	r28, 0x3d	; 61
    2602:	de b7       	in	r29, 0x3e	; 62
	//read UART buffer
	UART_DATA= UART_ReceiveNum(); //Read data with no block
    2604:	0e 94 4f 02 	call	0x49e	; 0x49e <UART_ReceiveNum>
    2608:	80 93 c3 02 	sts	0x02C3, r24
	UART_FLAG=ENABLE;
    260c:	81 e0       	ldi	r24, 0x01	; 1
    260e:	80 93 c9 02 	sts	0x02C9, r24
}
    2612:	cf 91       	pop	r28
    2614:	df 91       	pop	r29
    2616:	08 95       	ret

00002618 <MOTOR_Init>:


/*********************************************Init & Runnble*******************************************/

void MOTOR_Init (void)
{
    2618:	df 93       	push	r29
    261a:	cf 93       	push	r28
    261c:	cd b7       	in	r28, 0x3d	; 61
    261e:	de b7       	in	r29, 0x3e	; 62
	Port_Init();
    2620:	0e 94 0b 0a 	call	0x1416	; 0x1416 <Port_Init>
	while (Dio_ReadChannel(KEY_ACCESS_PIN)==DISABLE);// key access  off
    2624:	80 e1       	ldi	r24, 0x10	; 16
    2626:	0e 94 8a 0f 	call	0x1f14	; 0x1f14 <Dio_ReadChannel>
    262a:	88 23       	and	r24, r24
    262c:	d9 f3       	breq	.-10     	; 0x2624 <MOTOR_Init+0xc>
	TMR0_Init();
    262e:	0e 94 98 03 	call	0x730	; 0x730 <TMR0_Init>
	TMR0_Start();
    2632:	0e 94 df 03 	call	0x7be	; 0x7be <TMR0_Start>
	TIMER2_Init(TIMER2_PHASECORRECT_MODE,TIMER2_SCALER_64);
    2636:	81 e0       	ldi	r24, 0x01	; 1
    2638:	63 e0       	ldi	r22, 0x03	; 3
    263a:	0e 94 6a 04 	call	0x8d4	; 0x8d4 <TIMER2_Init>
	TIMER2_OC2Mode(OC2_NON_INVERTING);
    263e:	82 e0       	ldi	r24, 0x02	; 2
    2640:	0e 94 e5 04 	call	0x9ca	; 0x9ca <TIMER2_OC2Mode>
 	UART_Init();
    2644:	0e 94 ea 01 	call	0x3d4	; 0x3d4 <UART_Init>
    MCP2515_TransmiterInit();
    2648:	0e 94 7d 11 	call	0x22fa	; 0x22fa <MCP2515_TransmiterInit>
	MCP2515_receiverInit();
    264c:	0e 94 99 12 	call	0x2532	; 0x2532 <MCP2515_receiverInit>
	UART_RX_SetCallBack(RX_Interrupt);
    2650:	8e ef       	ldi	r24, 0xFE	; 254
    2652:	92 e1       	ldi	r25, 0x12	; 18
    2654:	0e 94 ea 02 	call	0x5d4	; 0x5d4 <UART_RX_SetCallBack>
	UART_RX_InterruptEnable();
    2658:	0e 94 b2 02 	call	0x564	; 0x564 <UART_RX_InterruptEnable>
	UART_Send_String("5/ACC ON - 6/ACC OFF - 7/lane on - 8/lane off - 9/save zone \r\n");
    265c:	80 e0       	ldi	r24, 0x00	; 0
    265e:	91 e0       	ldi	r25, 0x01	; 1
    2660:	0e 94 26 02 	call	0x44c	; 0x44c <UART_Send_String>

	
	
}
    2664:	cf 91       	pop	r28
    2666:	df 91       	pop	r29
    2668:	08 95       	ret

0000266a <UART_Get>:

void UART_Get (void)
{
    266a:	df 93       	push	r29
    266c:	cf 93       	push	r28
    266e:	cd b7       	in	r28, 0x3d	; 61
    2670:	de b7       	in	r29, 0x3e	; 62
	if (UART_FLAG==ENABLE) // if UART Received any data save it in (UART_DATA) And CLR the flag
    2672:	80 91 c9 02 	lds	r24, 0x02C9
    2676:	81 30       	cpi	r24, 0x01	; 1
    2678:	09 f0       	breq	.+2      	; 0x267c <UART_Get+0x12>
    267a:	45 c0       	rjmp	.+138    	; 0x2706 <UART_Get+0x9c>
	{
		
	if(UART_DATA<UART_MAX_NUM_MANUAL_MSG) //MANUAL_mode
    267c:	80 91 c3 02 	lds	r24, 0x02C3
    2680:	85 30       	cpi	r24, 0x05	; 5
    2682:	18 f4       	brcc	.+6      	; 0x268a <UART_Get+0x20>
	{
		
		MANIUAL_FLAG = ENABLE ; 
    2684:	81 e0       	ldi	r24, 0x01	; 1
    2686:	80 93 c1 02 	sts	0x02C1, r24
		
	}
	if (UART_DATA==UART_ACC_ON_MSG) //ACC mode on
    268a:	80 91 c3 02 	lds	r24, 0x02C3
    268e:	85 30       	cpi	r24, 0x05	; 5
    2690:	31 f4       	brne	.+12     	; 0x269e <UART_Get+0x34>
	{
		
		ACC_FLAG = ENABLE ; 
    2692:	81 e0       	ldi	r24, 0x01	; 1
    2694:	80 93 c8 02 	sts	0x02C8, r24
		LANE_KEEP_FLAG=ENABLE;
    2698:	81 e0       	ldi	r24, 0x01	; 1
    269a:	80 93 c6 02 	sts	0x02C6, r24
	}
	if(UART_DATA==UART_ACC_OFF_MSG) // ACC mode off
    269e:	80 91 c3 02 	lds	r24, 0x02C3
    26a2:	86 30       	cpi	r24, 0x06	; 6
    26a4:	71 f4       	brne	.+28     	; 0x26c2 <UART_Get+0x58>
	{
		UART_Send_String("\r\n ACC IS OFF RETURN TO MANIUAL MODE \r\n");
    26a6:	8f e3       	ldi	r24, 0x3F	; 63
    26a8:	91 e0       	ldi	r25, 0x01	; 1
    26aa:	0e 94 26 02 	call	0x44c	; 0x44c <UART_Send_String>
		ACC_FLAG =DISABLE ;
    26ae:	10 92 c8 02 	sts	0x02C8, r1
		LANE_KEEP_FLAG=DISABLE;
    26b2:	10 92 c6 02 	sts	0x02C6, r1
		MANIUAL_FLAG=ENABLE;
    26b6:	81 e0       	ldi	r24, 0x01	; 1
    26b8:	80 93 c1 02 	sts	0x02C1, r24
		msgReq1=ENABLE; //send msg acc
    26bc:	81 e0       	ldi	r24, 0x01	; 1
    26be:	80 93 c4 02 	sts	0x02C4, r24
	}
	if(UART_DATA==UART_LANE_ON_MSG) // lane keep on
    26c2:	80 91 c3 02 	lds	r24, 0x02C3
    26c6:	87 30       	cpi	r24, 0x07	; 7
    26c8:	61 f4       	brne	.+24     	; 0x26e2 <UART_Get+0x78>
	{
		UART_Send_String("\r\n lanekeep on \r\n");
    26ca:	87 e6       	ldi	r24, 0x67	; 103
    26cc:	91 e0       	ldi	r25, 0x01	; 1
    26ce:	0e 94 26 02 	call	0x44c	; 0x44c <UART_Send_String>
		LANE_KEEP_FLAG =ENABLE ;
    26d2:	81 e0       	ldi	r24, 0x01	; 1
    26d4:	80 93 c6 02 	sts	0x02C6, r24
		MANIUAL_FLAG=DISABLE;
    26d8:	10 92 c1 02 	sts	0x02C1, r1
		msgReq2=ENABLE; //send msg lanekeep
    26dc:	81 e0       	ldi	r24, 0x01	; 1
    26de:	80 93 c7 02 	sts	0x02C7, r24
	}
	if(UART_DATA==UART_LANE_OFF_MSG) // lane keep off
    26e2:	80 91 c3 02 	lds	r24, 0x02C3
    26e6:	88 30       	cpi	r24, 0x08	; 8
    26e8:	61 f4       	brne	.+24     	; 0x2702 <UART_Get+0x98>
	{
		UART_Send_String("\r\n lanekeep oFF \r\n");
    26ea:	89 e7       	ldi	r24, 0x79	; 121
    26ec:	91 e0       	ldi	r25, 0x01	; 1
    26ee:	0e 94 26 02 	call	0x44c	; 0x44c <UART_Send_String>
		LANE_KEEP_FLAG=DISABLE;
    26f2:	10 92 c6 02 	sts	0x02C6, r1
		MANIUAL_FLAG=ENABLE;
    26f6:	81 e0       	ldi	r24, 0x01	; 1
    26f8:	80 93 c1 02 	sts	0x02C1, r24
		msgReq2=ENABLE; //send msg lanekeep
    26fc:	81 e0       	ldi	r24, 0x01	; 1
    26fe:	80 93 c7 02 	sts	0x02C7, r24
	}
	UART_FLAG=DISABLE;	
    2702:	10 92 c9 02 	sts	0x02C9, r1
}
	
}
    2706:	cf 91       	pop	r28
    2708:	df 91       	pop	r29
    270a:	08 95       	ret

0000270c <CarDirection>:




void CarDirection (void)
{
    270c:	df 93       	push	r29
    270e:	cf 93       	push	r28
    2710:	00 d0       	rcall	.+0      	; 0x2712 <CarDirection+0x6>
    2712:	cd b7       	in	r28, 0x3d	; 61
    2714:	de b7       	in	r29, 0x3e	; 62
	
	if (MANIUAL_FLAG==ENABLE && ACC_FLAG == DISABLE)//IF  ACC Off
    2716:	80 91 c1 02 	lds	r24, 0x02C1
    271a:	81 30       	cpi	r24, 0x01	; 1
    271c:	49 f5       	brne	.+82     	; 0x2770 <CarDirection+0x64>
    271e:	80 91 c8 02 	lds	r24, 0x02C8
    2722:	88 23       	and	r24, r24
    2724:	29 f5       	brne	.+74     	; 0x2770 <CarDirection+0x64>
	{
		
		motor_status = UART_DATA ;
    2726:	80 91 c3 02 	lds	r24, 0x02C3
    272a:	80 93 c2 02 	sts	0x02C2, r24
		
		//motor_status from uart data
		switch (motor_status)
    272e:	80 91 c2 02 	lds	r24, 0x02C2
    2732:	28 2f       	mov	r18, r24
    2734:	30 e0       	ldi	r19, 0x00	; 0
    2736:	3a 83       	std	Y+2, r19	; 0x02
    2738:	29 83       	std	Y+1, r18	; 0x01
    273a:	89 81       	ldd	r24, Y+1	; 0x01
    273c:	9a 81       	ldd	r25, Y+2	; 0x02
    273e:	84 30       	cpi	r24, 0x04	; 4
    2740:	91 05       	cpc	r25, r1
    2742:	59 f0       	breq	.+22     	; 0x275a <CarDirection+0x4e>
    2744:	29 81       	ldd	r18, Y+1	; 0x01
    2746:	3a 81       	ldd	r19, Y+2	; 0x02
    2748:	29 30       	cpi	r18, 0x09	; 9
    274a:	31 05       	cpc	r19, r1
    274c:	71 f0       	breq	.+28     	; 0x276a <CarDirection+0x5e>
    274e:	89 81       	ldd	r24, Y+1	; 0x01
    2750:	9a 81       	ldd	r25, Y+2	; 0x02
    2752:	83 30       	cpi	r24, 0x03	; 3
    2754:	91 05       	cpc	r25, r1
    2756:	29 f0       	breq	.+10     	; 0x2762 <CarDirection+0x56>
    2758:	0b c0       	rjmp	.+22     	; 0x2770 <CarDirection+0x64>
		{
			
			case MOTOR_LEFT :  MOTOR_steering_Control (MOTOR_LEFT) ;   break;
    275a:	84 e0       	ldi	r24, 0x04	; 4
    275c:	0e 94 71 10 	call	0x20e2	; 0x20e2 <MOTOR_steering_Control>
    2760:	07 c0       	rjmp	.+14     	; 0x2770 <CarDirection+0x64>
			case MOTOR_RIGHT:  MOTOR_steering_Control (MOTOR_RIGHT) ;  break;
    2762:	83 e0       	ldi	r24, 0x03	; 3
    2764:	0e 94 71 10 	call	0x20e2	; 0x20e2 <MOTOR_steering_Control>
    2768:	03 c0       	rjmp	.+6      	; 0x2770 <CarDirection+0x64>
			case MOTOR_STRAIGHT:  MOTOR_steering_Control (MOTOR_STRAIGHT) ;  break;
    276a:	89 e0       	ldi	r24, 0x09	; 9
    276c:	0e 94 71 10 	call	0x20e2	; 0x20e2 <MOTOR_steering_Control>
		}
	}
	
	if (LANE_KEEP_FLAG==ENABLE)
    2770:	80 91 c6 02 	lds	r24, 0x02C6
    2774:	81 30       	cpi	r24, 0x01	; 1
    2776:	b1 f4       	brne	.+44     	; 0x27a4 <CarDirection+0x98>
	{
		if(dir_COM==ALARM_LANE_MSG_ON)// if acc off but lane keep on set alarm
    2778:	80 91 af 02 	lds	r24, 0x02AF
    277c:	85 30       	cpi	r24, 0x05	; 5
    277e:	29 f4       	brne	.+10     	; 0x278a <CarDirection+0x7e>
		{
			Dio_WriteChannel(ALARM_LANE_KEEP,STD_HIGH);
    2780:	84 e0       	ldi	r24, 0x04	; 4
    2782:	61 e0       	ldi	r22, 0x01	; 1
    2784:	0e 94 b1 0d 	call	0x1b62	; 0x1b62 <Dio_WriteChannel>
    2788:	0d c0       	rjmp	.+26     	; 0x27a4 <CarDirection+0x98>
		}
		else if(dir_COM==ALARM_LANE_MSG_OFF)// if acc off but lane keep on set alarm
    278a:	80 91 af 02 	lds	r24, 0x02AF
    278e:	86 30       	cpi	r24, 0x06	; 6
    2790:	29 f4       	brne	.+10     	; 0x279c <CarDirection+0x90>
		{
			Dio_WriteChannel(ALARM_LANE_KEEP,STD_LOW);
    2792:	84 e0       	ldi	r24, 0x04	; 4
    2794:	60 e0       	ldi	r22, 0x00	; 0
    2796:	0e 94 b1 0d 	call	0x1b62	; 0x1b62 <Dio_WriteChannel>
    279a:	04 c0       	rjmp	.+8      	; 0x27a4 <CarDirection+0x98>
		}
		else
		{
			//read spi and set on motor_status
			MOTOR_steering_Control(dir_COM); //3 RIGHt   4 LEFT    9 STRAIGHT   
    279c:	80 91 af 02 	lds	r24, 0x02AF
    27a0:	0e 94 71 10 	call	0x20e2	; 0x20e2 <MOTOR_steering_Control>
		}
	}
}
    27a4:	0f 90       	pop	r0
    27a6:	0f 90       	pop	r0
    27a8:	cf 91       	pop	r28
    27aa:	df 91       	pop	r29
    27ac:	08 95       	ret

000027ae <CarSpeed>:

void CarSpeed (void)
{
    27ae:	df 93       	push	r29
    27b0:	cf 93       	push	r28
    27b2:	00 d0       	rcall	.+0      	; 0x27b4 <CarSpeed+0x6>
    27b4:	00 d0       	rcall	.+0      	; 0x27b6 <CarSpeed+0x8>
    27b6:	cd b7       	in	r28, 0x3d	; 61
    27b8:	de b7       	in	r29, 0x3e	; 62
	static u8 flag=DISABLE;
	
	if (MANIUAL_FLAG==ENABLE && ACC_FLAG == DISABLE)//IF NOT ACC ON
    27ba:	80 91 c1 02 	lds	r24, 0x02C1
    27be:	81 30       	cpi	r24, 0x01	; 1
    27c0:	21 f5       	brne	.+72     	; 0x280a <CarSpeed+0x5c>
    27c2:	80 91 c8 02 	lds	r24, 0x02C8
    27c6:	88 23       	and	r24, r24
    27c8:	01 f5       	brne	.+64     	; 0x280a <CarSpeed+0x5c>
	{
		
		motor_status = UART_DATA ;
    27ca:	80 91 c3 02 	lds	r24, 0x02C3
    27ce:	80 93 c2 02 	sts	0x02C2, r24
		
		//motor_status from uart data
		switch (motor_status)
    27d2:	80 91 c2 02 	lds	r24, 0x02C2
    27d6:	28 2f       	mov	r18, r24
    27d8:	30 e0       	ldi	r19, 0x00	; 0
    27da:	3c 83       	std	Y+4, r19	; 0x04
    27dc:	2b 83       	std	Y+3, r18	; 0x03
    27de:	8b 81       	ldd	r24, Y+3	; 0x03
    27e0:	9c 81       	ldd	r25, Y+4	; 0x04
    27e2:	81 30       	cpi	r24, 0x01	; 1
    27e4:	91 05       	cpc	r25, r1
    27e6:	61 f0       	breq	.+24     	; 0x2800 <CarSpeed+0x52>
    27e8:	2b 81       	ldd	r18, Y+3	; 0x03
    27ea:	3c 81       	ldd	r19, Y+4	; 0x04
    27ec:	22 30       	cpi	r18, 0x02	; 2
    27ee:	31 05       	cpc	r19, r1
    27f0:	51 f0       	breq	.+20     	; 0x2806 <CarSpeed+0x58>
    27f2:	8b 81       	ldd	r24, Y+3	; 0x03
    27f4:	9c 81       	ldd	r25, Y+4	; 0x04
    27f6:	00 97       	sbiw	r24, 0x00	; 0
    27f8:	41 f4       	brne	.+16     	; 0x280a <CarSpeed+0x5c>
		{
			case MOTOR_STOP :      MOTOR_Stop();     break ;
    27fa:	0e 94 4a 10 	call	0x2094	; 0x2094 <MOTOR_Stop>
    27fe:	05 c0       	rjmp	.+10     	; 0x280a <CarSpeed+0x5c>
			case MOTOR_FORWARED:   MOTOR_Forward();  break ;
    2800:	0e 94 26 10 	call	0x204c	; 0x204c <MOTOR_Forward>
    2804:	02 c0       	rjmp	.+4      	; 0x280a <CarSpeed+0x5c>
			case MOTOR_BACKWARD:   MOTOR_Backward(); break ;
    2806:	0e 94 38 10 	call	0x2070	; 0x2070 <MOTOR_Backward>
		}
		
	}
	
	
	if ( ACC_FLAG == ENABLE ) //IF ACC ON
    280a:	80 91 c8 02 	lds	r24, 0x02C8
    280e:	81 30       	cpi	r24, 0x01	; 1
    2810:	09 f0       	breq	.+2      	; 0x2814 <CarSpeed+0x66>
    2812:	9d c0       	rjmp	.+314    	; 0x294e <CarSpeed+0x1a0>
	{
			
			flag=ENABLE;
    2814:	81 e0       	ldi	r24, 0x01	; 1
    2816:	80 93 ab 02 	sts	0x02AB, r24
			
			speed_UART = UART_DATA ; //save speed from uart to use it at frist time in acc mode
    281a:	80 91 c3 02 	lds	r24, 0x02C3
    281e:	80 93 ac 02 	sts	0x02AC, r24
			if (FristTimeOnAcc==DISABLE)
    2822:	80 91 c0 02 	lds	r24, 0x02C0
    2826:	88 23       	and	r24, r24
    2828:	09 f0       	breq	.+2      	; 0x282c <CarSpeed+0x7e>
    282a:	7a c0       	rjmp	.+244    	; 0x2920 <CarSpeed+0x172>
			{
				switch (speed_UART)
    282c:	80 91 ac 02 	lds	r24, 0x02AC
    2830:	28 2f       	mov	r18, r24
    2832:	30 e0       	ldi	r19, 0x00	; 0
    2834:	3a 83       	std	Y+2, r19	; 0x02
    2836:	29 83       	std	Y+1, r18	; 0x01
    2838:	89 81       	ldd	r24, Y+1	; 0x01
    283a:	9a 81       	ldd	r25, Y+2	; 0x02
    283c:	82 30       	cpi	r24, 0x02	; 2
    283e:	91 05       	cpc	r25, r1
    2840:	e9 f1       	breq	.+122    	; 0x28bc <CarSpeed+0x10e>
    2842:	29 81       	ldd	r18, Y+1	; 0x01
    2844:	3a 81       	ldd	r19, Y+2	; 0x02
    2846:	23 30       	cpi	r18, 0x03	; 3
    2848:	31 05       	cpc	r19, r1
    284a:	54 f4       	brge	.+20     	; 0x2860 <CarSpeed+0xb2>
    284c:	89 81       	ldd	r24, Y+1	; 0x01
    284e:	9a 81       	ldd	r25, Y+2	; 0x02
    2850:	00 97       	sbiw	r24, 0x00	; 0
    2852:	91 f0       	breq	.+36     	; 0x2878 <CarSpeed+0xca>
    2854:	29 81       	ldd	r18, Y+1	; 0x01
    2856:	3a 81       	ldd	r19, Y+2	; 0x02
    2858:	21 30       	cpi	r18, 0x01	; 1
    285a:	31 05       	cpc	r19, r1
    285c:	f1 f0       	breq	.+60     	; 0x289a <CarSpeed+0xec>
    285e:	60 c0       	rjmp	.+192    	; 0x2920 <CarSpeed+0x172>
    2860:	89 81       	ldd	r24, Y+1	; 0x01
    2862:	9a 81       	ldd	r25, Y+2	; 0x02
    2864:	83 30       	cpi	r24, 0x03	; 3
    2866:	91 05       	cpc	r25, r1
    2868:	d1 f1       	breq	.+116    	; 0x28de <CarSpeed+0x130>
    286a:	29 81       	ldd	r18, Y+1	; 0x01
    286c:	3a 81       	ldd	r19, Y+2	; 0x02
    286e:	24 30       	cpi	r18, 0x04	; 4
    2870:	31 05       	cpc	r19, r1
    2872:	09 f4       	brne	.+2      	; 0x2876 <CarSpeed+0xc8>
    2874:	45 c0       	rjmp	.+138    	; 0x2900 <CarSpeed+0x152>
    2876:	54 c0       	rjmp	.+168    	; 0x2920 <CarSpeed+0x172>
				{
					case SPEED_0 : speed_COM = SET_SPEED0 ; default_speed = SET_SPEED0; MOTOR_Forward_SetSpeed(speed_COM); FristTimeOnAcc=ENABLE; msgReq1=ENABLE; break;
    2878:	8e e1       	ldi	r24, 0x1E	; 30
    287a:	80 93 ae 02 	sts	0x02AE, r24
    287e:	8e e1       	ldi	r24, 0x1E	; 30
    2880:	80 93 ad 02 	sts	0x02AD, r24
    2884:	80 91 ae 02 	lds	r24, 0x02AE
    2888:	0e 94 5c 10 	call	0x20b8	; 0x20b8 <MOTOR_Forward_SetSpeed>
    288c:	81 e0       	ldi	r24, 0x01	; 1
    288e:	80 93 c0 02 	sts	0x02C0, r24
    2892:	81 e0       	ldi	r24, 0x01	; 1
    2894:	80 93 c4 02 	sts	0x02C4, r24
    2898:	43 c0       	rjmp	.+134    	; 0x2920 <CarSpeed+0x172>
					case SPEED_1 : speed_COM = SET_SPEED1 ; default_speed = SET_SPEED1 ; MOTOR_Forward_SetSpeed(speed_COM); FristTimeOnAcc=ENABLE; msgReq1=ENABLE; break;
    289a:	88 e2       	ldi	r24, 0x28	; 40
    289c:	80 93 ae 02 	sts	0x02AE, r24
    28a0:	88 e2       	ldi	r24, 0x28	; 40
    28a2:	80 93 ad 02 	sts	0x02AD, r24
    28a6:	80 91 ae 02 	lds	r24, 0x02AE
    28aa:	0e 94 5c 10 	call	0x20b8	; 0x20b8 <MOTOR_Forward_SetSpeed>
    28ae:	81 e0       	ldi	r24, 0x01	; 1
    28b0:	80 93 c0 02 	sts	0x02C0, r24
    28b4:	81 e0       	ldi	r24, 0x01	; 1
    28b6:	80 93 c4 02 	sts	0x02C4, r24
    28ba:	32 c0       	rjmp	.+100    	; 0x2920 <CarSpeed+0x172>
					case SPEED_2 : speed_COM = SET_SPEED2 ; default_speed = SET_SPEED2 ; MOTOR_Forward_SetSpeed(speed_COM); FristTimeOnAcc=ENABLE; msgReq1=ENABLE; break;
    28bc:	8c e3       	ldi	r24, 0x3C	; 60
    28be:	80 93 ae 02 	sts	0x02AE, r24
    28c2:	8c e3       	ldi	r24, 0x3C	; 60
    28c4:	80 93 ad 02 	sts	0x02AD, r24
    28c8:	80 91 ae 02 	lds	r24, 0x02AE
    28cc:	0e 94 5c 10 	call	0x20b8	; 0x20b8 <MOTOR_Forward_SetSpeed>
    28d0:	81 e0       	ldi	r24, 0x01	; 1
    28d2:	80 93 c0 02 	sts	0x02C0, r24
    28d6:	81 e0       	ldi	r24, 0x01	; 1
    28d8:	80 93 c4 02 	sts	0x02C4, r24
    28dc:	21 c0       	rjmp	.+66     	; 0x2920 <CarSpeed+0x172>
					case SPEED_3 : speed_COM = SET_SPEED3 ; default_speed = SET_SPEED3 ; MOTOR_Forward_SetSpeed(speed_COM); FristTimeOnAcc=ENABLE; msgReq1=ENABLE; break;
    28de:	80 e5       	ldi	r24, 0x50	; 80
    28e0:	80 93 ae 02 	sts	0x02AE, r24
    28e4:	80 e5       	ldi	r24, 0x50	; 80
    28e6:	80 93 ad 02 	sts	0x02AD, r24
    28ea:	80 91 ae 02 	lds	r24, 0x02AE
    28ee:	0e 94 5c 10 	call	0x20b8	; 0x20b8 <MOTOR_Forward_SetSpeed>
    28f2:	81 e0       	ldi	r24, 0x01	; 1
    28f4:	80 93 c0 02 	sts	0x02C0, r24
    28f8:	81 e0       	ldi	r24, 0x01	; 1
    28fa:	80 93 c4 02 	sts	0x02C4, r24
    28fe:	10 c0       	rjmp	.+32     	; 0x2920 <CarSpeed+0x172>
					case SPEED_4 : speed_COM = SET_SPEED4 ; default_speed = SET_SPEED4 ; MOTOR_Forward_SetSpeed(speed_COM); FristTimeOnAcc=ENABLE; msgReq1=ENABLE; break;
    2900:	8a e5       	ldi	r24, 0x5A	; 90
    2902:	80 93 ae 02 	sts	0x02AE, r24
    2906:	8a e5       	ldi	r24, 0x5A	; 90
    2908:	80 93 ad 02 	sts	0x02AD, r24
    290c:	80 91 ae 02 	lds	r24, 0x02AE
    2910:	0e 94 5c 10 	call	0x20b8	; 0x20b8 <MOTOR_Forward_SetSpeed>
    2914:	81 e0       	ldi	r24, 0x01	; 1
    2916:	80 93 c0 02 	sts	0x02C0, r24
    291a:	81 e0       	ldi	r24, 0x01	; 1
    291c:	80 93 c4 02 	sts	0x02C4, r24
				}
			}
			
			
			if(print_flag==DISABLE) // that means we still waiting the frist speed from the user
    2920:	80 91 c5 02 	lds	r24, 0x02C5
    2924:	88 23       	and	r24, r24
    2926:	59 f4       	brne	.+22     	; 0x293e <CarSpeed+0x190>
			{
				UART_Send_String("\r\n ACC IS ON PRESS 6 TO OFF THE MODE \r\n");
    2928:	8c e8       	ldi	r24, 0x8C	; 140
    292a:	91 e0       	ldi	r25, 0x01	; 1
    292c:	0e 94 26 02 	call	0x44c	; 0x44c <UART_Send_String>
				UART_Send_String("\r\n enter speed \r\n");
    2930:	84 eb       	ldi	r24, 0xB4	; 180
    2932:	91 e0       	ldi	r25, 0x01	; 1
    2934:	0e 94 26 02 	call	0x44c	; 0x44c <UART_Send_String>
				print_flag=ENABLE;
    2938:	81 e0       	ldi	r24, 0x01	; 1
    293a:	80 93 c5 02 	sts	0x02C5, r24
			}
			
			if(FristTimeOnAcc == ENABLE )
    293e:	80 91 c0 02 	lds	r24, 0x02C0
    2942:	81 30       	cpi	r24, 0x01	; 1
    2944:	21 f4       	brne	.+8      	; 0x294e <CarSpeed+0x1a0>
			{
				MOTOR_Forward_SetSpeed(speed_COM);
    2946:	80 91 ae 02 	lds	r24, 0x02AE
    294a:	0e 94 5c 10 	call	0x20b8	; 0x20b8 <MOTOR_Forward_SetSpeed>
				
			}
			
	}
		
		if(ACC_FLAG==DISABLE&&flag==ENABLE)
    294e:	80 91 c8 02 	lds	r24, 0x02C8
    2952:	88 23       	and	r24, r24
    2954:	61 f4       	brne	.+24     	; 0x296e <CarSpeed+0x1c0>
    2956:	80 91 ab 02 	lds	r24, 0x02AB
    295a:	81 30       	cpi	r24, 0x01	; 1
    295c:	41 f4       	brne	.+16     	; 0x296e <CarSpeed+0x1c0>
	 {
			/*when go out from acc mode motor will not stop and will continue with its last speed status in (acc on) 
			until read another motor status for the motor thrue uart*/
			 MOTOR_Forward_SetSpeed(default_speed); 
    295e:	80 91 ad 02 	lds	r24, 0x02AD
    2962:	0e 94 5c 10 	call	0x20b8	; 0x20b8 <MOTOR_Forward_SetSpeed>
			 FristTimeOnAcc=DISABLE; 
    2966:	10 92 c0 02 	sts	0x02C0, r1
			 flag=DISABLE;
    296a:	10 92 ab 02 	sts	0x02AB, r1
	 }
}
    296e:	0f 90       	pop	r0
    2970:	0f 90       	pop	r0
    2972:	0f 90       	pop	r0
    2974:	0f 90       	pop	r0
    2976:	cf 91       	pop	r28
    2978:	df 91       	pop	r29
    297a:	08 95       	ret

0000297c <COM_handle>:

void COM_handle (void)
{
    297c:	df 93       	push	r29
    297e:	cf 93       	push	r28
    2980:	cd b7       	in	r28, 0x3d	; 61
    2982:	de b7       	in	r29, 0x3e	; 62
     //transmit msg
	 COM_Tx(); 
    2984:	0e 94 c9 14 	call	0x2992	; 0x2992 <COM_Tx>
	 // receiver  msg
	 COM_Rx ();
    2988:	0e 94 4c 15 	call	0x2a98	; 0x2a98 <COM_Rx>
	
}
    298c:	cf 91       	pop	r28
    298e:	df 91       	pop	r29
    2990:	08 95       	ret

00002992 <COM_Tx>:
void COM_Tx (void)
{
    2992:	0f 93       	push	r16
    2994:	1f 93       	push	r17
    2996:	df 93       	push	r29
    2998:	cf 93       	push	r28
    299a:	cd b7       	in	r28, 0x3d	; 61
    299c:	de b7       	in	r29, 0x3e	; 62
    299e:	27 97       	sbiw	r28, 0x07	; 7
    29a0:	0f b6       	in	r0, 0x3f	; 63
    29a2:	f8 94       	cli
    29a4:	de bf       	out	0x3e, r29	; 62
    29a6:	0f be       	out	0x3f, r0	; 63
    29a8:	cd bf       	out	0x3d, r28	; 61
	u8 accData[2]={ACC_FLAG,speed_COM};
    29aa:	80 91 c8 02 	lds	r24, 0x02C8
    29ae:	90 91 ae 02 	lds	r25, 0x02AE
    29b2:	89 83       	std	Y+1, r24	; 0x01
    29b4:	9a 83       	std	Y+2, r25	; 0x02
	u8 laneFlag=LANE_KEEP_FLAG;
    29b6:	80 91 c6 02 	lds	r24, 0x02C6
    29ba:	8b 83       	std	Y+3, r24	; 0x03
	/* transmit msg */
	if (msgReq1) // check if ecu want send acc msg
    29bc:	80 91 c4 02 	lds	r24, 0x02C4
    29c0:	88 23       	and	r24, r24
    29c2:	71 f1       	breq	.+92     	; 0x2a20 <COM_Tx+0x8e>
	{
		UART_Send_String("ACC SENT \r\n");
    29c4:	86 ec       	ldi	r24, 0xC6	; 198
    29c6:	91 e0       	ldi	r25, 0x01	; 1
    29c8:	0e 94 26 02 	call	0x44c	; 0x44c <UART_Send_String>
		switch (ACC_FLAG)
    29cc:	80 91 c8 02 	lds	r24, 0x02C8
    29d0:	28 2f       	mov	r18, r24
    29d2:	30 e0       	ldi	r19, 0x00	; 0
    29d4:	3f 83       	std	Y+7, r19	; 0x07
    29d6:	2e 83       	std	Y+6, r18	; 0x06
    29d8:	8e 81       	ldd	r24, Y+6	; 0x06
    29da:	9f 81       	ldd	r25, Y+7	; 0x07
    29dc:	00 97       	sbiw	r24, 0x00	; 0
    29de:	31 f0       	breq	.+12     	; 0x29ec <COM_Tx+0x5a>
    29e0:	2e 81       	ldd	r18, Y+6	; 0x06
    29e2:	3f 81       	ldd	r19, Y+7	; 0x07
    29e4:	21 30       	cpi	r18, 0x01	; 1
    29e6:	31 05       	cpc	r19, r1
    29e8:	69 f0       	breq	.+26     	; 0x2a04 <COM_Tx+0x72>
    29ea:	17 c0       	rjmp	.+46     	; 0x2a1a <COM_Tx+0x88>
		{
			case ACC_OFF:
			//msg1 2 byte first byte acc flag on or off ,second byte speed of car
			MCP2515_SendMessage(CAN_TX_BUFF_0,CAN_ACC_MSG,CAN_ACC_OFF_DLC,&accData[0]);
    29ec:	80 e0       	ldi	r24, 0x00	; 0
    29ee:	41 e0       	ldi	r20, 0x01	; 1
    29f0:	50 e0       	ldi	r21, 0x00	; 0
    29f2:	60 e0       	ldi	r22, 0x00	; 0
    29f4:	70 e0       	ldi	r23, 0x00	; 0
    29f6:	21 e0       	ldi	r18, 0x01	; 1
    29f8:	fe 01       	movw	r30, r28
    29fa:	31 96       	adiw	r30, 0x01	; 1
    29fc:	8f 01       	movw	r16, r30
    29fe:	0e 94 9f 11 	call	0x233e	; 0x233e <MCP2515_SendMessage>
    2a02:	0b c0       	rjmp	.+22     	; 0x2a1a <COM_Tx+0x88>
			break;
			case ACC_ON:
			//msg1 2 byte first byte acc flag on or off ,second byte speed of car
			MCP2515_SendMessage(CAN_TX_BUFF_0,CAN_ACC_MSG,CAN_ACC_ON_DLC,accData);
    2a04:	80 e0       	ldi	r24, 0x00	; 0
    2a06:	41 e0       	ldi	r20, 0x01	; 1
    2a08:	50 e0       	ldi	r21, 0x00	; 0
    2a0a:	60 e0       	ldi	r22, 0x00	; 0
    2a0c:	70 e0       	ldi	r23, 0x00	; 0
    2a0e:	22 e0       	ldi	r18, 0x02	; 2
    2a10:	fe 01       	movw	r30, r28
    2a12:	31 96       	adiw	r30, 0x01	; 1
    2a14:	8f 01       	movw	r16, r30
    2a16:	0e 94 9f 11 	call	0x233e	; 0x233e <MCP2515_SendMessage>
			
			break;
		}
		msgReq1=DISABLE; // to disable req
    2a1a:	10 92 c4 02 	sts	0x02C4, r1
    2a1e:	31 c0       	rjmp	.+98     	; 0x2a82 <COM_Tx+0xf0>
	}
	else if (msgReq2)
    2a20:	80 91 c7 02 	lds	r24, 0x02C7
    2a24:	88 23       	and	r24, r24
    2a26:	69 f1       	breq	.+90     	; 0x2a82 <COM_Tx+0xf0>
	{
		switch (LANE_KEEP_FLAG)
    2a28:	80 91 c6 02 	lds	r24, 0x02C6
    2a2c:	28 2f       	mov	r18, r24
    2a2e:	30 e0       	ldi	r19, 0x00	; 0
    2a30:	3d 83       	std	Y+5, r19	; 0x05
    2a32:	2c 83       	std	Y+4, r18	; 0x04
    2a34:	8c 81       	ldd	r24, Y+4	; 0x04
    2a36:	9d 81       	ldd	r25, Y+5	; 0x05
    2a38:	00 97       	sbiw	r24, 0x00	; 0
    2a3a:	31 f0       	breq	.+12     	; 0x2a48 <COM_Tx+0xb6>
    2a3c:	2c 81       	ldd	r18, Y+4	; 0x04
    2a3e:	3d 81       	ldd	r19, Y+5	; 0x05
    2a40:	21 30       	cpi	r18, 0x01	; 1
    2a42:	31 05       	cpc	r19, r1
    2a44:	69 f0       	breq	.+26     	; 0x2a60 <COM_Tx+0xce>
    2a46:	17 c0       	rjmp	.+46     	; 0x2a76 <COM_Tx+0xe4>
		{
			case LANE_OFF:
			//msg2 1 byte lane flag on or off
			MCP2515_SendMessage(CAN_TX_BUFF_0,CAN_LANE_MSG,CAN_LANE_OFF_DLC,&laneFlag);
    2a48:	fe 01       	movw	r30, r28
    2a4a:	33 96       	adiw	r30, 0x03	; 3
    2a4c:	80 e0       	ldi	r24, 0x00	; 0
    2a4e:	42 e0       	ldi	r20, 0x02	; 2
    2a50:	50 e0       	ldi	r21, 0x00	; 0
    2a52:	60 e0       	ldi	r22, 0x00	; 0
    2a54:	70 e0       	ldi	r23, 0x00	; 0
    2a56:	22 e0       	ldi	r18, 0x02	; 2
    2a58:	8f 01       	movw	r16, r30
    2a5a:	0e 94 9f 11 	call	0x233e	; 0x233e <MCP2515_SendMessage>
    2a5e:	0b c0       	rjmp	.+22     	; 0x2a76 <COM_Tx+0xe4>
			break;
			case LANE_ON:
			//msg2 1 byte lane flag on or off
			MCP2515_SendMessage(CAN_TX_BUFF_0,CAN_LANE_MSG,CAN_LANE_ON_DLC,&laneFlag);
    2a60:	fe 01       	movw	r30, r28
    2a62:	33 96       	adiw	r30, 0x03	; 3
    2a64:	80 e0       	ldi	r24, 0x00	; 0
    2a66:	42 e0       	ldi	r20, 0x02	; 2
    2a68:	50 e0       	ldi	r21, 0x00	; 0
    2a6a:	60 e0       	ldi	r22, 0x00	; 0
    2a6c:	70 e0       	ldi	r23, 0x00	; 0
    2a6e:	22 e0       	ldi	r18, 0x02	; 2
    2a70:	8f 01       	movw	r16, r30
    2a72:	0e 94 9f 11 	call	0x233e	; 0x233e <MCP2515_SendMessage>
			break;
		}
		msgReq2=DISABLE;// to disable req
    2a76:	10 92 c7 02 	sts	0x02C7, r1
		UART_Send_String("LANE SENT \r\n");
    2a7a:	82 ed       	ldi	r24, 0xD2	; 210
    2a7c:	91 e0       	ldi	r25, 0x01	; 1
    2a7e:	0e 94 26 02 	call	0x44c	; 0x44c <UART_Send_String>
	}
}
    2a82:	27 96       	adiw	r28, 0x07	; 7
    2a84:	0f b6       	in	r0, 0x3f	; 63
    2a86:	f8 94       	cli
    2a88:	de bf       	out	0x3e, r29	; 62
    2a8a:	0f be       	out	0x3f, r0	; 63
    2a8c:	cd bf       	out	0x3d, r28	; 61
    2a8e:	cf 91       	pop	r28
    2a90:	df 91       	pop	r29
    2a92:	1f 91       	pop	r17
    2a94:	0f 91       	pop	r16
    2a96:	08 95       	ret

00002a98 <COM_Rx>:
void COM_Rx (void)
{
    2a98:	df 93       	push	r29
    2a9a:	cf 93       	push	r28
    2a9c:	cd b7       	in	r28, 0x3d	; 61
    2a9e:	de b7       	in	r29, 0x3e	; 62
    2aa0:	2f 97       	sbiw	r28, 0x0f	; 15
    2aa2:	0f b6       	in	r0, 0x3f	; 63
    2aa4:	f8 94       	cli
    2aa6:	de bf       	out	0x3e, r29	; 62
    2aa8:	0f be       	out	0x3f, r0	; 63
    2aaa:	cd bf       	out	0x3d, r28	; 61
	  u8 msgId=DISABLE;
    2aac:	19 82       	std	Y+1, r1	; 0x01
	  u8 recvData[14]={0};
    2aae:	8e e0       	ldi	r24, 0x0E	; 14
    2ab0:	fe 01       	movw	r30, r28
    2ab2:	32 96       	adiw	r30, 0x02	; 2
    2ab4:	df 01       	movw	r26, r30
    2ab6:	98 2f       	mov	r25, r24
    2ab8:	1d 92       	st	X+, r1
    2aba:	9a 95       	dec	r25
    2abc:	e9 f7       	brne	.-6      	; 0x2ab8 <COM_Rx+0x20>
	  // msg1 ->> speed acc
	  // msg2 ->> dir
	  //msg3 ->> emg
	  
	if (Dio_ReadChannel(CAN_INT_PIN)==LOW)
    2abe:	81 e0       	ldi	r24, 0x01	; 1
    2ac0:	0e 94 8a 0f 	call	0x1f14	; 0x1f14 <Dio_ReadChannel>
    2ac4:	88 23       	and	r24, r24
    2ac6:	c9 f5       	brne	.+114    	; 0x2b3a <COM_Rx+0xa2>
	{
		MCP2515_bufferGet(recvData);//get frame data
    2ac8:	ce 01       	movw	r24, r28
    2aca:	02 96       	adiw	r24, 0x02	; 2
    2acc:	0e 94 d2 10 	call	0x21a4	; 0x21a4 <MCP2515_bufferGet>
		MCP2515_receiverB0();
    2ad0:	0e 94 cf 12 	call	0x259e	; 0x259e <MCP2515_receiverB0>
		msgId=((recvData[2])>>5);
    2ad4:	8c 81       	ldd	r24, Y+4	; 0x04
    2ad6:	82 95       	swap	r24
    2ad8:	86 95       	lsr	r24
    2ada:	87 70       	andi	r24, 0x07	; 7
    2adc:	89 83       	std	Y+1, r24	; 0x01
		if (msgId==CAN_SPEED_MSG)
    2ade:	89 81       	ldd	r24, Y+1	; 0x01
    2ae0:	81 30       	cpi	r24, 0x01	; 1
    2ae2:	49 f4       	brne	.+18     	; 0x2af6 <COM_Rx+0x5e>
		{
			speed_COM=recvData[6];
    2ae4:	88 85       	ldd	r24, Y+8	; 0x08
    2ae6:	80 93 ae 02 	sts	0x02AE, r24
			msgId=DISABLE;	
    2aea:	19 82       	std	Y+1, r1	; 0x01
			UART_Send_String("ACC RECV \r\n");
    2aec:	8f ed       	ldi	r24, 0xDF	; 223
    2aee:	91 e0       	ldi	r25, 0x01	; 1
    2af0:	0e 94 26 02 	call	0x44c	; 0x44c <UART_Send_String>
    2af4:	22 c0       	rjmp	.+68     	; 0x2b3a <COM_Rx+0xa2>
		}
		else if (msgId==CAN_DIR_MSG)
    2af6:	89 81       	ldd	r24, Y+1	; 0x01
    2af8:	82 30       	cpi	r24, 0x02	; 2
    2afa:	49 f4       	brne	.+18     	; 0x2b0e <COM_Rx+0x76>
		{
			dir_COM=recvData[6]; 
    2afc:	88 85       	ldd	r24, Y+8	; 0x08
    2afe:	80 93 af 02 	sts	0x02AF, r24
			msgId=DISABLE;
    2b02:	19 82       	std	Y+1, r1	; 0x01
			UART_Send_String("LANE RECV \r\n");
    2b04:	8b ee       	ldi	r24, 0xEB	; 235
    2b06:	91 e0       	ldi	r25, 0x01	; 1
    2b08:	0e 94 26 02 	call	0x44c	; 0x44c <UART_Send_String>
    2b0c:	16 c0       	rjmp	.+44     	; 0x2b3a <COM_Rx+0xa2>
		}
		else if (msgId==CAN_EMG_MSG)
    2b0e:	89 81       	ldd	r24, Y+1	; 0x01
    2b10:	83 30       	cpi	r24, 0x03	; 3
    2b12:	99 f4       	brne	.+38     	; 0x2b3a <COM_Rx+0xa2>
		{
			UART_Send_String("EMG RECV \r\n");
    2b14:	88 ef       	ldi	r24, 0xF8	; 248
    2b16:	91 e0       	ldi	r25, 0x01	; 1
    2b18:	0e 94 26 02 	call	0x44c	; 0x44c <UART_Send_String>
			if (recvData[6]==CAN_EMG_FLAG_ON)
    2b1c:	88 85       	ldd	r24, Y+8	; 0x08
    2b1e:	81 30       	cpi	r24, 0x01	; 1
    2b20:	59 f4       	brne	.+22     	; 0x2b38 <COM_Rx+0xa0>
			{
				ACC_FLAG=DISABLE;
    2b22:	10 92 c8 02 	sts	0x02C8, r1
				LANE_KEEP_FLAG=DISABLE;
    2b26:	10 92 c6 02 	sts	0x02C6, r1
				MOTOR_Stop();
    2b2a:	0e 94 4a 10 	call	0x2094	; 0x2094 <MOTOR_Stop>
				MANIUAL_FLAG=ENABLE;
    2b2e:	81 e0       	ldi	r24, 0x01	; 1
    2b30:	80 93 c1 02 	sts	0x02C1, r24
				UART_DATA=DISABLE;
    2b34:	10 92 c3 02 	sts	0x02C3, r1
				if (recvData[7]==CAN_ACCIDENT_FLAG_ON)
				{
					//accident 
				}
			}
			msgId=DISABLE;
    2b38:	19 82       	std	Y+1, r1	; 0x01
		}
	}
}
    2b3a:	2f 96       	adiw	r28, 0x0f	; 15
    2b3c:	0f b6       	in	r0, 0x3f	; 63
    2b3e:	f8 94       	cli
    2b40:	de bf       	out	0x3e, r29	; 62
    2b42:	0f be       	out	0x3f, r0	; 63
    2b44:	cd bf       	out	0x3d, r28	; 61
    2b46:	cf 91       	pop	r28
    2b48:	df 91       	pop	r29
    2b4a:	08 95       	ret

00002b4c <vMillisIncrement>:
#include "MCAL/DIO/DIO.h"
#include "MCAL/PORT/Port.h"
#define   GLOBAL_ENABLE    sei
// ISR Callback
void vMillisIncrement(void)
{
    2b4c:	df 93       	push	r29
    2b4e:	cf 93       	push	r28
    2b50:	cd b7       	in	r28, 0x3d	; 61
    2b52:	de b7       	in	r29, 0x3e	; 62
	static u16 u16_MillisCounter=0;
	u16_MillisCounter++;
    2b54:	80 91 b0 02 	lds	r24, 0x02B0
    2b58:	90 91 b1 02 	lds	r25, 0x02B1
    2b5c:	01 96       	adiw	r24, 0x01	; 1
    2b5e:	90 93 b1 02 	sts	0x02B1, r25
    2b62:	80 93 b0 02 	sts	0x02B0, r24
	if (u16_MillisCounter>=TICK_TIME)
    2b66:	80 91 b0 02 	lds	r24, 0x02B0
    2b6a:	90 91 b1 02 	lds	r25, 0x02B1
    2b6e:	85 30       	cpi	r24, 0x05	; 5
    2b70:	91 05       	cpc	r25, r1
    2b72:	30 f0       	brcs	.+12     	; 0x2b80 <vMillisIncrement+0x34>
	{
		//blocked -> ready if its time
		OS_Task_Handler();
    2b74:	0e 94 f0 00 	call	0x1e0	; 0x1e0 <OS_Task_Handler>
		//reset counterl
		u16_MillisCounter=0;
    2b78:	10 92 b1 02 	sts	0x02B1, r1
    2b7c:	10 92 b0 02 	sts	0x02B0, r1
	}
}
    2b80:	cf 91       	pop	r28
    2b82:	df 91       	pop	r29
    2b84:	08 95       	ret

00002b86 <vInitEcu>:
void vInitEcu(void)
{
    2b86:	df 93       	push	r29
    2b88:	cf 93       	push	r28
    2b8a:	cd b7       	in	r28, 0x3d	; 61
    2b8c:	de b7       	in	r29, 0x3e	; 62
	
	TIMER1_Init(TIMER1_CTC_OCRA_TOP_MODE,TIMER1_SCALER_64);
    2b8e:	83 e0       	ldi	r24, 0x03	; 3
    2b90:	63 e0       	ldi	r22, 0x03	; 3
    2b92:	0e 94 73 05 	call	0xae6	; 0xae6 <TIMER1_Init>
	TIMER1_OC1AMode(OCRA_TOGGLE);
    2b96:	81 e0       	ldi	r24, 0x01	; 1
    2b98:	0e 94 6f 06 	call	0xcde	; 0xcde <TIMER1_OC1AMode>
	GLOBAL_ENABLE();
    2b9c:	78 94       	sei
	TIMER1_OC1A_Enable();
    2b9e:	0e 94 8a 07 	call	0xf14	; 0xf14 <TIMER1_OC1A_Enable>
	TIMER1_OC1A_SetCallBack(vMillisIncrement);
    2ba2:	86 ea       	ldi	r24, 0xA6	; 166
    2ba4:	95 e1       	ldi	r25, 0x15	; 21
    2ba6:	0e 94 f0 07 	call	0xfe0	; 0xfe0 <TIMER1_OC1A_SetCallBack>
	MOTOR_Init();
    2baa:	0e 94 0c 13 	call	0x2618	; 0x2618 <MOTOR_Init>
}
    2bae:	cf 91       	pop	r28
    2bb0:	df 91       	pop	r29
    2bb2:	08 95       	ret

00002bb4 <InitScheduler>:
void InitScheduler(void)
{
    2bb4:	df 93       	push	r29
    2bb6:	cf 93       	push	r28
    2bb8:	cd b7       	in	r28, 0x3d	; 61
    2bba:	de b7       	in	r29, 0x3e	; 62
	//func working on ms
	OS_TaskCreate(Task_UART_Get_20mS,20,BLOCKED,0);
    2bbc:	86 ec       	ldi	r24, 0xC6	; 198
    2bbe:	91 e0       	ldi	r25, 0x01	; 1
    2bc0:	64 e1       	ldi	r22, 0x14	; 20
    2bc2:	70 e0       	ldi	r23, 0x00	; 0
    2bc4:	41 e0       	ldi	r20, 0x01	; 1
    2bc6:	20 e0       	ldi	r18, 0x00	; 0
    2bc8:	0e 94 67 00 	call	0xce	; 0xce <OS_TaskCreate>
	OS_TaskCreate(Task_MOTOR_GetDirection_40mS,40,BLOCKED,0);
    2bcc:	88 ed       	ldi	r24, 0xD8	; 216
    2bce:	91 e0       	ldi	r25, 0x01	; 1
    2bd0:	68 e2       	ldi	r22, 0x28	; 40
    2bd2:	70 e0       	ldi	r23, 0x00	; 0
    2bd4:	41 e0       	ldi	r20, 0x01	; 1
    2bd6:	20 e0       	ldi	r18, 0x00	; 0
    2bd8:	0e 94 67 00 	call	0xce	; 0xce <OS_TaskCreate>
	OS_TaskCreate(Task_MOTOR_GetSpeed_50mS,50,BLOCKED,10);
    2bdc:	8f ec       	ldi	r24, 0xCF	; 207
    2bde:	91 e0       	ldi	r25, 0x01	; 1
    2be0:	62 e3       	ldi	r22, 0x32	; 50
    2be2:	70 e0       	ldi	r23, 0x00	; 0
    2be4:	41 e0       	ldi	r20, 0x01	; 1
    2be6:	2a e0       	ldi	r18, 0x0A	; 10
    2be8:	0e 94 67 00 	call	0xce	; 0xce <OS_TaskCreate>
	OS_TaskCreate(Task_MOTOR_COM_5mS,5,BLOCKED,0);
    2bec:	81 ee       	ldi	r24, 0xE1	; 225
    2bee:	91 e0       	ldi	r25, 0x01	; 1
    2bf0:	65 e0       	ldi	r22, 0x05	; 5
    2bf2:	70 e0       	ldi	r23, 0x00	; 0
    2bf4:	41 e0       	ldi	r20, 0x01	; 1
    2bf6:	20 e0       	ldi	r18, 0x00	; 0
    2bf8:	0e 94 67 00 	call	0xce	; 0xce <OS_TaskCreate>
}
    2bfc:	cf 91       	pop	r28
    2bfe:	df 91       	pop	r29
    2c00:	08 95       	ret

00002c02 <main>:


int main(void)
{
    2c02:	df 93       	push	r29
    2c04:	cf 93       	push	r28
    2c06:	cd b7       	in	r28, 0x3d	; 61
    2c08:	de b7       	in	r29, 0x3e	; 62
	vInitEcu();
    2c0a:	0e 94 c3 15 	call	0x2b86	; 0x2b86 <vInitEcu>
	InitScheduler();
    2c0e:	0e 94 da 15 	call	0x2bb4	; 0x2bb4 <InitScheduler>

	while(1)
	{
		
		OS_TaskExecution();
    2c12:	0e 94 81 01 	call	0x302	; 0x302 <OS_TaskExecution>
    2c16:	fd cf       	rjmp	.-6      	; 0x2c12 <main+0x10>

00002c18 <__udivmodhi4>:
    2c18:	aa 1b       	sub	r26, r26
    2c1a:	bb 1b       	sub	r27, r27
    2c1c:	51 e1       	ldi	r21, 0x11	; 17
    2c1e:	07 c0       	rjmp	.+14     	; 0x2c2e <__udivmodhi4_ep>

00002c20 <__udivmodhi4_loop>:
    2c20:	aa 1f       	adc	r26, r26
    2c22:	bb 1f       	adc	r27, r27
    2c24:	a6 17       	cp	r26, r22
    2c26:	b7 07       	cpc	r27, r23
    2c28:	10 f0       	brcs	.+4      	; 0x2c2e <__udivmodhi4_ep>
    2c2a:	a6 1b       	sub	r26, r22
    2c2c:	b7 0b       	sbc	r27, r23

00002c2e <__udivmodhi4_ep>:
    2c2e:	88 1f       	adc	r24, r24
    2c30:	99 1f       	adc	r25, r25
    2c32:	5a 95       	dec	r21
    2c34:	a9 f7       	brne	.-22     	; 0x2c20 <__udivmodhi4_loop>
    2c36:	80 95       	com	r24
    2c38:	90 95       	com	r25
    2c3a:	bc 01       	movw	r22, r24
    2c3c:	cd 01       	movw	r24, r26
    2c3e:	08 95       	ret

00002c40 <_exit>:
    2c40:	f8 94       	cli

00002c42 <__stop_program>:
    2c42:	ff cf       	rjmp	.-2      	; 0x2c42 <__stop_program>
